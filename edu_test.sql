-- phpMyAdmin SQL Dump
-- version 5.0.4
-- https://www.phpmyadmin.net/
--
-- Хост: 127.0.0.1:3306
-- Время создания: Мар 25 2022 г., 06:55
-- Версия сервера: 8.0.19
-- Версия PHP: 8.0.1

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
START TRANSACTION;
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- База данных: `edu_test`
--

-- --------------------------------------------------------

--
-- Структура таблицы `answers`
--

CREATE TABLE `answers` (
  `IDAnswer` int NOT NULL,
  `IDQuestion` int NOT NULL,
  `Name` varchar(5000) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL,
  `Code` varchar(5000) COLLATE utf8mb4_general_ci DEFAULT NULL,
  `IsTrue` tinyint(1) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;

--
-- Дамп данных таблицы `answers`
--

INSERT INTO `answers` (`IDAnswer`, `IDQuestion`, `Name`, `Code`, `IsTrue`) VALUES
(378, 111, 'тест&quot;', 'тест', 1),
(379, 112, '1&quot;', '', 1),
(380, 113, '', '', 1),
(642, 193, '&quot;&quot;', '', 0),
(643, 193, '0', '', 1),
(644, 193, 'Ошибка времени компиляции', '', 0),
(645, 193, 'Ошибка времени выполнения', '', 0),
(646, 194, '100', '', 0),
(647, 194, '0', '', 0),
(648, 194, 'Ошибка времени компиляции', '', 1),
(649, 194, 'Ошибка времени выполнения', '', 0),
(650, 195, 'Long', '', 0),
(651, 195, 'Float', '', 0),
(652, 195, 'Double', '', 0),
(653, 195, 'Decimal', '', 1),
(654, 196, '210', '', 0),
(655, 196, '210.12', '', 1),
(656, 196, 'Ошибка времени компиляции', '', 0),
(657, 196, 'Ошибка времени выполнения', '', 0),
(658, 197, '334', '', 1),
(659, 198, 'private', '', 1),
(660, 199, 'True', '', 0),
(661, 199, 'False', '', 1),
(662, 199, 'Ошибка', '', 0),
(663, 199, 'null', '', 0),
(664, 200, 'Ошибка времени компиляции', '', 0),
(665, 200, 'Ошибка времени выполнения', '', 0),
(666, 200, '1.01, 1.02, 1.03, 1.04,', '', 1),
(667, 200, '1, 1, 1, 1', '', 0),
(668, 201, '5', '', 0),
(669, 201, 'Wednesday', '', 0),
(670, 201, 'Ошибка времени компиляции', '', 1),
(671, 201, 'Ошибка времени выполнения', '', 0),
(672, 202, 'int[] arr = new int[5];', '', 1),
(673, 202, 'int[,] arr1 = new int[5,2];', '', 1),
(674, 202, 'int[][,] arr2 = new int[5][,];', '', 1),
(675, 202, 'int[] arr1 = new int[,];', '', 0),
(702, 212, 'null', '', 1),
(703, 212, '0', '', 0),
(704, 212, 'Ошибка времени компиляции', '', 0),
(705, 212, 'Ошибка времени выполнения', '', 0),
(706, 213, '', 'public ClickHandler OnClick;', 0),
(707, 213, '', 'public event ClickHandler OnClick;', 1),
(708, 213, '', 'public event void OnClick;', 0),
(709, 213, '', 'public ClickHandler event OnClick;', 0),
(710, 214, '20', '', 0),
(711, 214, '60', '', 0),
(712, 214, '0', '', 0),
(713, 214, 'Ошибка времени компиляции', '', 1),
(714, 215, 'uint', '', 0),
(715, 215, 'ushort', '', 0),
(716, 215, 'byte', '', 1),
(717, 215, 'sbyte', '', 0),
(718, 216, '65', '', 1),
(719, 216, 'Ошибка времени выполнения', '', 0),
(720, 216, 'Ошибка времени компиляции', '', 0),
(721, 217, 'test()', '', 0),
(722, 217, 'Ошибка времени выполнения', '', 0),
(723, 217, 'Ошибка времени компиляции', '', 1),
(724, 217, 'Ничего', '', 0),
(725, 218, '1', '', 1),
(726, 219, 'throw', '', 1),
(727, 220, 'Правда', '', 1),
(728, 220, 'Ложь', '', 0),
(730, 222, '', '', 1),
(731, 223, '2', '', 1),
(763, 235, 'Случайное число', '', 0),
(764, 235, 'Ошибка времени выполнения', '', 0),
(765, 235, 'Ошибка времени компиляции', '', 1),
(766, 235, '0', '', 0),
(767, 236, '0', '', 0),
(768, 236, '10', '', 1),
(769, 236, 'Ошибка времени выполнения', '', 0),
(770, 236, 'Ошибка времени компиляции', '', 0),
(771, 237, 'null', '', 0),
(772, 237, '0', '', 0),
(773, 237, 'Ошибка времени компиляции', '', 1),
(774, 237, 'Ошибка времени выполнения', '', 0),
(775, 238, 'BigInteger', '', 1),
(776, 239, '8', '', 1),
(777, 240, 'Public', '', 0),
(778, 240, 'Private', '', 0),
(779, 240, 'Internal', '', 1),
(780, 240, 'Protected', '', 0),
(781, 241, 'Правда', '', 0),
(782, 241, 'Ложь', '', 1),
(783, 242, '', 'int[] arr = new int[5];', 1),
(784, 242, '', 'int[] arr = new int[]{1, 2, 3, 4, 5};', 0),
(785, 242, '', 'var arr = new int[5]{1, 2, 3, 4, 5};', 1),
(786, 242, '', 'int[] arr = int[]{1, 2, 3, 4, 5};', 0),
(787, 242, '', 'int[] arr = {1, 2, 3, 4, 5};', 1),
(788, 242, '', 'var arr = {1, 2, 3, 4, 5};', 0),
(789, 243, '01234', '', 1),
(790, 243, '12345', '', 0),
(791, 243, 'Бесконечный цикл', '', 0),
(792, 243, 'Ошибка времени компиляции', '', 0),
(793, 244, 'Произошла ошибка!', '', 0),
(794, 244, 'Ошибка времени компиляции', '', 1),
(795, 244, 'Ничего', '', 0),
(796, 245, '', 'public static void Program()', 0),
(797, 245, '', 'public static void Main()', 1),
(798, 245, '', 'public static void main()', 0),
(799, 245, 'Ни один из перечисленных', '', 0),
(800, 246, 'Int32', '', 1),
(801, 246, 'Double', '', 1),
(802, 246, 'Decimal', '', 1),
(803, 246, 'Class', '', 0),
(804, 247, 'String', '', 1),
(805, 247, 'Long', '', 0),
(806, 247, 'Boolean', '', 0),
(807, 247, 'Ни один из перечисленных', '', 0),
(808, 248, 'Ссылочный тип', '', 0),
(809, 248, 'Тип значения', '', 1),
(810, 248, 'Класс', '', 0),
(811, 248, 'Строка', '', 0),
(812, 249, '', 'int[] intArray = new int[];', 0),
(813, 249, '', 'int intArray[] = new int[5];', 0),
(814, 249, '', 'int[] intArray = new int[5];', 1),
(815, 249, '', 'int[5] intArray = new int[];', 0),
(816, 250, 'var', '', 1),
(817, 251, '4', '', 1),
(818, 252, '1', '', 0),
(819, 252, '0', '', 1),
(820, 252, '-1', '', 0),
(821, 253, 'Значение будет присвоено во время выполнения программы', '', 1),
(822, 253, 'Значение будет присвоено во время компиляции программы', '', 0),
(823, 253, 'Значение будет присвоено при первом обращении к переменной', '', 0),
(824, 253, 'Ни один из перечисленных', '', 0),
(825, 254, 'За блоком try должен следовать блок catch, блок finally или оба', '', 1),
(826, 254, 'Блок finally не может включать оператор возврата (return)', '', 1),
(827, 254, 'Блок try может включать в себя другой блок try', '', 1),
(828, 254, 'Если ошибок не возникло, то блок finally выполняться не будет', '', 0),
(829, 255, 'Правда', '', 1),
(830, 255, 'Ложь', '', 0),
(831, 256, 'True', '', 0),
(832, 256, 'False', '', 1),
(833, 256, 'Ошибка времени компиляции', '', 0),
(834, 257, 'Ошибка времени компиляции', '', 1),
(835, 257, '11', '', 0),
(836, 257, '10', '', 0),
(837, 258, '', 'c = a&gt;b? b : a;', 1),
(838, 258, '', 'c = a&gt;b? a : b;', 0),
(839, 258, '', 'c = a&gt;b? return(b) : return (a);', 0),
(840, 258, '', 'c = a&gt;b? b : a&lt;b? a : b;', 0),
(841, 259, 'Класс может наследовать один или несколько классов', '', 1),
(842, 259, 'Структура может наследовать один или несколько классов', '', 1),
(843, 259, 'Интерфейс может наследовать один или несколько классов', '', 1),
(844, 260, 'Правда', '', 0),
(845, 260, 'Ложь', '', 1),
(846, 261, 'My name is Steve', '', 1),
(847, 262, 'unsafe', '', 0),
(848, 262, 'virtual', '', 0),
(849, 262, 'extern', '', 0),
(850, 262, 'volatile', '', 1),
(851, 263, 'Task', '', 1),
(852, 263, 'int', '', 0),
(853, 263, 'Task&lt;TResult&gt;', '', 1),
(854, 263, 'void', '', 0),
(855, 264, 'is', '', 0),
(856, 264, 'as', '', 1),
(857, 264, '=', '', 0),
(858, 264, '()', '', 0),
(859, 265, '3', '', 1);

-- --------------------------------------------------------

--
-- Структура таблицы `chapters`
--

CREATE TABLE `chapters` (
  `IDChapter` int NOT NULL,
  `SerialNumber` int NOT NULL,
  `Name` varchar(200) COLLATE utf8mb4_general_ci NOT NULL,
  `Description` varchar(1000) COLLATE utf8mb4_general_ci DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;

--
-- Дамп данных таблицы `chapters`
--

INSERT INTO `chapters` (`IDChapter`, `SerialNumber`, `Name`, `Description`) VALUES
(1, 1, 'Введение в C#', 'Знакомство с базовом синтаксисом для создания простых приложений с помощью C#.'),
(2, 2, 'Основы программирования на C#', 'Знакомство с базовом синтаксисом для создания простых приложений с помощью C#.'),
(3, 3, 'Классы, структуры и пространства имен', 'Знакомство с базовым элементом в объектно-ориентировонном программировании.'),
(4, 4, 'Объектно-ориентированное программирование', NULL),
(14, 5, 'Обработка исключений', 'Встроенные средства C# для корректной работы программы, в случае возникновения исключительных ситуаций.'),
(15, 6, 'Делегаты, события и лямбды', 'Способы работы с методами посредством вызовов делегатов при возникновении определенных событий.'),
(16, 7, 'Интерфейсы', ''),
(17, 8, 'Коллекции', 'Работа с различными представителями массивов.'),
(18, 9, 'Многопоточность', ''),
(19, 10, 'Aсинхронное программирование', 'Сведения о методах для создания асинхронных программ.'),
(20, 11, 'Dynamic Language Runtime', 'Знания о среде выполнения динамических языков.'),
(21, 12, 'Работа с файловой системой', '');

-- --------------------------------------------------------

--
-- Структура таблицы `common_statuses`
--

CREATE TABLE `common_statuses` (
  `IDStatus` int NOT NULL,
  `Name` varchar(30) COLLATE utf8mb4_general_ci NOT NULL,
  `Description` varchar(200) COLLATE utf8mb4_general_ci DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;

--
-- Дамп данных таблицы `common_statuses`
--

INSERT INTO `common_statuses` (`IDStatus`, `Name`, `Description`) VALUES
(1, 'Черновик', 'Отображается администраторам, но скрыта для пользователей'),
(2, 'Опубликована', 'Отображается для всех'),
(3, 'Удалена', 'Скрыта для всех');

-- --------------------------------------------------------

--
-- Структура таблицы `labs`
--

CREATE TABLE `labs` (
  `IDLab` int NOT NULL,
  `StartNumber` int NOT NULL,
  `EndNumber` int NOT NULL,
  `Theme` varchar(300) COLLATE utf8mb4_general_ci NOT NULL,
  `Goal` varchar(300) COLLATE utf8mb4_general_ci NOT NULL,
  `Equipment` varchar(300) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `Content` longtext COLLATE utf8mb4_general_ci NOT NULL,
  `IDStatus` int NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;

--
-- Дамп данных таблицы `labs`
--

INSERT INTO `labs` (`IDLab`, `StartNumber`, `EndNumber`, `Theme`, `Goal`, `Equipment`, `Content`, `IDStatus`) VALUES
(1, 1, 1, 'Создание, компилирование, отладка и выполнение проектов в интегрированной среде разработки.', 'Сформировать практические навыки и умения создавать простейшие приложения средствами Microsoft Visual Studio .NET.', 'ПК, среда разработки Microsoft Visual Studio .NET. ', '&lt;h1&gt;МЕТОДИЧЕСКИЕ УКАЗАНИЯ&lt;/h1&gt;\r\n&lt;p&gt;Среда разработки Microsoft Visual Studio .NET&lt;/p&gt;\r\n&lt;p&gt;Microsoft Visual Studio — линейка продуктов компании Майкрософт, включающих интегрированную среду разработки программного обеспечения и ряд других инструментальных средств. Данные продукты позволяют разрабатывать как консольные приложения, так и приложения с графическим интерфейсом, в том числе с поддержкой технологии Windows Forms, а также веб-сайты, веб-приложения, веб-службы как в родном, так и в управляемом кодах для всех платформ, поддерживаемых Microsoft Windows, Windows Mobile, Windows CE, .NET Framework, Xbox, Windows Phone .NET Compact Framework и Microsoft Silverlight. &lt;/p&gt;\r\n&lt;p&gt;В состав Visual Studio входит:&lt;/p&gt;\r\n&lt;ul&gt;\r\n	&lt;li&gt;Visual Basic .NET (Visual Basic чуть-чуть отличается синтаксисом)&lt;/li&gt;\r\n	&lt;li&gt;Visual C++&lt;/li&gt;\r\n	&lt;li&gt;Visual C#&lt;/li&gt;\r\n	&lt;li&gt;Visual F# (начиная с VB2010).&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;h3&gt;Вывод данных&lt;/h3&gt;\r\n&lt;p&gt;Для вывода данных используется метод WriteLine, реализованный в классе Console, который позволяет организовывать вывод данных на экран. Однако существует несколько способов применения данного метода:&lt;/p&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;Console.WriteLine(x); //на экран выводится значение идентификатора х&lt;/li&gt;\r\n	&lt;li&gt;Console.WriteLine(&quot;x=&quot; + x +&quot;y=&quot; + y); /* на экран выводится строка, образованная последовательным слиянием строки &quot;x=&quot;, значения x, строки &quot;у=&quot; и значения у */&lt;/li&gt;\r\n	&lt;li&gt;Console.WriteLine(&quot;x={0} y={1}&quot;, x, y); /* на экран выводится строка, формат которой задан первым аргументом метода, при этом вместо параметра {0} выводится значение x, а вместо {1} – значение y*/&lt;/li&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;Использование управляющих последовательностей:&lt;/p&gt;\r\n&lt;p&gt;Управляющей последовательностью называют определенный символ, предваряемый обратной косой чертой. Данная совокупность символов интерпретируется как одиночный символ и используется для представления кодов символов, не имеющих графического обозначения (например, символа перевода курсора на новую строку) или символов, имеющих специальное обозначение в символьных и строковых константах (например, апостроф).&lt;/p&gt;\r\n&lt;p&gt;Рассмотрим управляющие символы:&lt;/p&gt;\r\n&lt;table&gt;\r\n	&lt;tr&gt;\r\n		&lt;th&gt;Вид&lt;/th&gt;\r\n		&lt;th&gt;Наименование&lt;/th&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n		&lt;td&gt;\\b&lt;/td&gt;\r\n		&lt;td&gt;Возврат на шаг назад&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n		&lt;td&gt;f&lt;/td&gt;\r\n		&lt;td&gt;Перевод страницы&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n		&lt;td&gt;\r\n&lt;/td&gt;\r\n		&lt;td&gt;Перевод строки&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n		&lt;td&gt;\r\n&lt;/td&gt;\r\n		&lt;td&gt;Возврат каретки&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n		&lt;td&gt;	&lt;/td&gt;\r\n		&lt;td&gt;Горизонтальная табуляция&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n		&lt;td&gt;v&lt;/td&gt;\r\n		&lt;td&gt;Вертикальная табуляция&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n		&lt;td&gt;&lt;/td&gt;\r\n		&lt;td&gt;Обратная косая черта&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n		&lt;td&gt;&#039;&lt;/td&gt;\r\n		&lt;td&gt;Апостроф&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n		&lt;td&gt;&quot;&lt;/td&gt;\r\n		&lt;td&gt;Кавычки&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n&lt;/table&gt;\r\n&lt;p&gt;Пример:&lt;/p&gt;\r\n&lt;code&gt;\r\nstatic void Main()\r\n{\r\nConsole.WriteLine(&quot;Ура!\r\nСегодня &quot;Информатика&quot;!!!&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;h3&gt;Управление размером поля вывода:&lt;/h3&gt;\r\n&lt;p&gt;Первым аргументом WriteLine указывается строка вида {n, m} – где n определяет номер идентификатора из списка аргументов метода WriteLine, а m – количество позиций (размер поля вывода), отводимых под значение данного идентификатора. При этом значение идентификатора выравнивается по правому краю. Если выделенных позиций для размещения значения идентификатора окажется недостаточно, то автоматически добавиться необходимое количество позиций.&lt;/p&gt;\r\n&lt;p&gt;Пример:&lt;/p&gt;\r\n&lt;code&gt;\r\nstatic void Main()\r\n{\r\ndouble x= Math.E;\r\nConsole.WriteLine(&quot;E={0,20}&quot;, x);\r\nConsole.WriteLine(&quot;E={0,10}&quot;, x);\r\n}\r\n&lt;/code&gt;\r\n&lt;h3&gt;Управление размещением вещественных данных:&lt;/h3&gt;\r\n&lt;p&gt;Первым аргументом WriteLine указывается строка вида {n: ##.###} – где n определяет номер идентификатора из списка аргументов метода WriteLine, а ##.### определяет формат вывода вещественного числа. В данном случае под целую часть числа отводится две позиции, под дробную – три. Если выделенных позиций для размещения целой части значения идентификатора окажется недостаточно, то автоматически добавиться необходимое количество позиций.&lt;/p&gt;\r\n&lt;p&gt;Пример:&lt;/p&gt;\r\n&lt;code&gt;\r\nstatic void Main()\r\n{\r\ndouble x= Math.E;\r\nConsole.WriteLine(&quot;E={0:##.###}&quot;, x);\r\nConsole.WriteLine(&quot;E={0:.####}&quot;, x);\r\n}\r\n&lt;/code&gt;\r\n&lt;h1&gt;УСЛОВИЕ ЗАДАНИЙ&lt;/h1&gt;\r\n&lt;p&gt;&lt;strong&gt;Задание 1.&lt;/strong&gt; Наберите код программы:&lt;/p&gt;\r\n&lt;img src=&quot;https://sun9-13.userapi.com/impf/_wCsfiIxvatYn--dgpS8NVrw5DdITheTTGbRhA/CZUXJ_ANKnk.jpg?size=784x485&amp;quality=96&amp;sign=d735ca2e40f515b804a33ed678ba55fa&amp;type=album&quot; alt=&quot;image&quot;&gt;\r\n&lt;p&gt;Протестируйте результат (F5) при необходимости откорректируйте программный код.&lt;/p&gt;\r\n&lt;p&gt;&lt;strong&gt;Задание 2.&lt;/strong&gt; Наберите код программы: &lt;/p&gt;\r\n&lt;img src=&quot;https://sun9-39.userapi.com/impf/cjIcWmScXA1pLNTfIFY433tqQYahc_79TB_rmA/W0fP4-X5k-c.jpg?size=1038x260&amp;quality=96&amp;sign=e48e7fcccbfd2f935419a72d5e8073a5&amp;type=album&quot; alt=&quot;image&quot;&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;Протестируйте результат (F5) при необходимости откорректируйте программный код.&lt;/li&gt;\r\n	&lt;li&gt;Измените программу, добавив условие: если не введено имя, то выводится «неизвестный».&lt;/li&gt;\r\n&lt;img src=&quot;https://sun1.beltelecom-by-minsk.userapi.com/impf/Yj2pNOmEju2R5R69gVbMeZmBXoMe7I_CcPRsBw/il68X6X5SEg.jpg?size=1042x31&amp;quality=96&amp;sign=a1d4a0121b125f37739f0b1fff909db6&amp;type=album&quot; alt=&quot;image&quot;&gt;\r\n	&lt;li&gt;Протестируйте окончательный вариант.&lt;/li&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;&lt;strong&gt;Задание 3.&lt;/strong&gt; Создайте приложение Con03, которое по выведенному радиусу вычисляет и выводит на консоль длину окружности т площадь круга.&lt;/p&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;Наберите текст программы:&lt;/li&gt;\r\n&lt;img src=&quot;https://sun9-2.userapi.com/impf/029cjAk-6MwDPEHn_34z3sMIjuUkZqZdnKp15g/a1eJhU662_A.jpg?size=944x287&amp;quality=96&amp;sign=3cd6d426b2f67a1389838c0c90fa5d21&amp;type=album&quot; alt=&quot;image&quot;&gt;\r\n	&lt;li&gt;Протестируйте результат (F5) при необходимости откорректируйте программный код.&lt;/li&gt;\r\n&lt;/ol&gt;\r\n&lt;h1&gt;Задания для самостоятельной работы.&lt;/h1&gt;\r\n&lt;p&gt;Создайте консольное приложение sam*, которое вычисляет и выводит:&lt;/p&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;Среднее арифметическое sred двух введенных чисел a и b.&lt;/li&gt;\r\n	&lt;li&gt;Значение функции z=x2+xy-y2 (с клавиатуры вводятся x и y).&lt;/li&gt;\r\n	&lt;li&gt;Стоимость товара в двух валютах (например, stUr и stRu) по его стоимости в белорусских рублях stBr.&lt;/li&gt;\r\n	&lt;li&gt;Стоимость поездки на автомобиле stoim (вводятся: s – расстояние в км, b – расход бензина в л на 100км, с – цена бензина в руб за 1 литр.&lt;/li&gt;\r\n&lt;/ol&gt;\r\n&lt;h1&gt;КОНТРОЛЬНЫЕ ВОПРОСЫ&lt;/h1&gt;\r\n&lt;ul&gt;\r\n	&lt;li&gt;Дайте определение среде разработки Microsoft Visual Studio .NET. Назовите его возможности.&lt;/li&gt;\r\n	&lt;li&gt;Назовите, что входит в состав Microsoft Visual Studio .NET.&lt;/li&gt;\r\n	&lt;li&gt;Перечислите действия для создания нового проекта.&lt;/li&gt;\r\n	&lt;li&gt;Какова общая структура программы на С#.&lt;/li&gt;\r\n	&lt;li&gt;Существуют ли ограничения на множество целых чисел, используемых в языке С#?&lt;/li&gt;\r\n	&lt;li&gt;Какие формы записи вещественных чисел используются в языке С#?&lt;/li&gt;\r\n	&lt;li&gt;Из каких символов может состоять идентификатор?&lt;/li&gt;\r\n	&lt;li&gt;Чем вызвана необходимость использования комментариев в программе?&lt;/li&gt;\r\n	&lt;li&gt;Каково назначение методов write и writeline?&lt;/li&gt;\r\n&lt;/ul&gt;\r\n\r\n&lt;h1&gt;ДОМАШНЕЕ ЗАДАНИЕ&lt;/h1&gt;\r\n&lt;p&gt;Павловская Т. А., «С# Программирование на языке высокого уровня», c. 14-21.&lt;/p&gt;\r\n&lt;p&gt;Пахомов Б. И., «С# для начинающих», с. 23-32&lt;/p&gt;', 2),
(2, 2, 2, 'Разработка линейных программ.', 'Сформировать практические навыки и умения в написания программ, реализующих линейные алгоритмы.', 'ПК, ОС Windows, среда разработки Microsoft Visual Studio .NET.', '&lt;h1&gt;ТЕОРЕТИЧЕСКАЯ ЧАСТЬ&lt;/h1&gt;\r\n\r\n&lt;p&gt;Если в программе все операторы выполняются последовательно, один за другим, такая программа называется линейной.&lt;/p&gt;\r\n&lt;h3&gt;Типы данных&lt;/h3&gt;\r\n&lt;p&gt;С# является языком со строгой типизацией. В нем необходимо объявлять тип всех создаваемых программных элементов (например, переменных и т. д.), что позволяет компилятору предотвращать возникновение ошибок, следя за тем, чтобы объектам присваивались значения только разрешенного типа. Тип программного элемента сообщает компилятору о его размере.&lt;/p&gt;\r\n&lt;p&gt;В С# типы делятся на две группы: базовые типы, предлагаемые языком, и типы, определяемые пользователем. Также типы С# разбиваются на две другие категории: размерные типы и ссылочные типы. Почти все базовые типы являются размерными типами. Исключение составляют типы Object и String. Принципиальное различие между размерными и ссылочными типами состоит в способе хранения их значений в памяти. В первом случае фактическое значение хранится в стеке. Адрес переменной ссылочного типа тоже хранится в стеке, но сам объект хранится в куче.&lt;/p&gt;\r\n&lt;h3&gt;Основные типы переменных в С#&lt;/h3&gt;\r\n&lt;table&gt;\r\n	&lt;tr&gt;\r\n		&lt;th&gt;Тип&lt;/th&gt;\r\n		&lt;th&gt;Описание&lt;/th&gt;\r\n		&lt;th&gt;Диапазон значений&lt;/th&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n		&lt;td&gt;&lt;strong&gt;bool&lt;/strong&gt;&lt;/td&gt;\r\n		&lt;td&gt;логический&lt;/td&gt;\r\n		&lt;td&gt;true и false&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n		&lt;td&gt;&lt;strong&gt;char&lt;/strong&gt;&lt;/td&gt;\r\n		&lt;td&gt;символьный&lt;/td&gt;\r\n		&lt;td&gt;0 … 65535&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n		&lt;td&gt;&lt;strong&gt;string&lt;/strong&gt;&lt;/td&gt;\r\n		&lt;td&gt;строка&lt;/td&gt;\r\n		&lt;td&gt;последовательность символов&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n		&lt;td&gt;&lt;strong&gt;sbyte&lt;/strong&gt;&lt;/td&gt;\r\n		&lt;td&gt;байт&lt;/td&gt;\r\n		&lt;td&gt;-128 … 127&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	&lt;b&gt;byte&lt;/b&gt;&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	байт&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	0 … 255&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	&lt;b&gt;short&lt;/b&gt;&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	короткое целое&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	-32 768\r\n	… 32767&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	&lt;b&gt;ushort&lt;/b&gt;&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	короткое целое&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	0 … 65\r\n	535&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	&lt;b&gt;Int&lt;/b&gt;&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	целое&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	-2 147\r\n	483 648 …2147483647&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	&lt;b&gt;Uint&lt;/b&gt;&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	целое&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	0 … 4\r\n	294 967 295&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	&lt;b&gt;long&lt;/b&gt;&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	длинное целое&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	&lt;br/&gt;\r\n	&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	&lt;b&gt;ulong&lt;/b&gt;&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	длинное целое&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	&lt;br/&gt;\r\n	&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	&lt;b&gt;float&lt;/b&gt;&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	вещественное&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	3,4e-38 … 3,4e+38&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	&lt;b&gt;double&lt;/b&gt;&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	с повышенной\r\n	точностью&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	1,7e-308 … 1,7e+308&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;/table&gt;\r\n&lt;p&gt;\r\nПеременная\r\nпредставляет собой типизированную\r\nобласть памяти. Программист создает\r\nпеременную, объявляя ее тип и указывая\r\nимя. При объявлении переменной ее можно\r\nинициализировать (присвоить ей начальное\r\nзначение), а затем в любой момент ей\r\nможно присвоить новое значение, которое\r\nзаменит собой предыдущее.&lt;/p&gt;\r\n&lt;p&gt;Константа\r\n-\r\nэто переменная, значение которой нельзя\r\nизменить. Константы бывают трех видов:\r\nлитералы,\r\nсимволические константы и\r\nперечисления.&lt;/p&gt;\r\n&lt;ul&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Преобразование\r\n	типов данных осуществляется с помощью\r\n	класса &lt;b&gt;Convert&lt;/b&gt;\r\n	или метода &lt;b&gt;Parse&lt;/b&gt;.\r\n	\r\n	&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Для\r\n	преобразования строкового представления\r\n	целого числа в тип int\r\n	используется метод &lt;b&gt;int.Parse()&lt;/b&gt;&lt;b&gt;,&lt;/b&gt;\r\n	который реализован для всех числовых\r\n	типов данных. \r\n	&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Если\r\n	требуется преобразовать строковое\r\n	представление в вещественное, то\r\n	используется метод &lt;b&gt;float.Parse()&lt;/b&gt;\r\n	или&lt;b&gt; &lt;/b&gt;&lt;b&gt;double.Parse()&lt;/b&gt;.\r\n	\r\n	&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	случае, если соответствующее преобразование\r\n	выполнить невозможно, то выполнение\r\n	программы прерывается и генерируется\r\n	исключение System.FormatExeption\r\n	(входная строка имела неверный формат).&lt;/p&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;\r\nКласс\r\nConvert,\r\nопределенный в пространстве имен System\r\nобеспечивает\r\nнеобходимые преобразования между\r\nразличными типами. Методы класса\r\nConvert\r\nподдерживают общий способ выполнения\r\nпреобразований между типами. Класс\r\nConvert\r\nсодержит 15 статических методов\r\nвида\r\nTo\r\n&lt;Type&gt; (ToBoolean(),...ToUInt64()),\r\nгде Type может принимать значения от\r\nBoolean до UInt64 для всех встроенных типов.\r\nЕдинственным исключением\r\nявляется тип object,\r\n- метода\r\nToObject\r\nнет по понятным причинам, поскольку для\r\nвсех типов существует неявное\r\nпреобразование\r\nк типу object.&lt;/p&gt;\r\n&lt;p&gt;\r\nПорядок\r\nвычислений определяется приоритетом\r\nопераций. Основные правила соответствуют\r\nпринятым в математике. Операции языка\r\nС# (с учетом убывания приоритета):&lt;/p&gt;\r\n&lt;p&gt;&lt;b&gt;1.\r\nИнкремент (++) и декримент(--).&lt;/b&gt;&lt;/p&gt;\r\n&lt;p&gt;Эти\r\nоперации имеют две формы записи -\r\nпрефиксную,\r\nкогда\r\nоперация записывается перед операндом,\r\nи постфиксную\r\n- операция записывается после операнда.\r\nПрефиксная операция инкремента\r\n(декремента) увеличивает (уменьшает)\r\nсвой операнд и возвращает измененное\r\nзначение как результат. Постфиксные\r\nверсии инкремента и декремента возвращают\r\nпервоначальное значение операнда, а\r\nзатем изменяют его.&lt;/p&gt;\r\n&lt;p&gt;Пример:&lt;/p&gt;\r\n	&lt;table&gt;\r\n	\r\n	\r\n	&lt;tr&gt;\r\n	&lt;td&gt;\r\n&lt;code&gt;\r\nstatic void Main()\r\n{\r\nint i = 3, j = 4;\r\nConsole.WriteLine(&quot;{0} {1}&quot;, i, j);\r\nConsole.WriteLine(&quot;{0} {1}&quot;, ++i, --j);\r\nConsole.WriteLine(&quot;{0} {1}&quot;, i++, j--);\r\nConsole.WriteLine(&quot;{0} {1}&quot;, i, j);\r\n}\r\n&lt;/code&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Результат\r\n	работы программы:&lt;/p&gt;\r\n	&lt;p&gt;\r\n	3\r\n	4&lt;/p&gt;\r\n	&lt;p&gt;\r\n	4\r\n	3&lt;/p&gt;\r\n	&lt;p&gt;\r\n	4\r\n	3&lt;/p&gt;\r\n	&lt;p&gt;5\r\n	2&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;/table&gt;\r\n&lt;p&gt;&lt;b&gt;2.\r\nОперация new. &lt;/b&gt;Используется\r\nдля создания нового объекта. С помощью\r\nее можно создавать как объекты ссылочного\r\nтипа, так и размерные, например:&lt;/p&gt;\r\n&lt;code&gt;\r\nobject z=new object();\r\n\r\nint i=new int(); // то же самое, что и int i =0;\r\n&lt;/code&gt;\r\n&lt;b&gt;3.\r\nОтрицание:&lt;/b&gt;&lt;/p&gt;\r\n&lt;ul&gt;\r\n	&lt;li&gt;&lt;p&gt;Арифметическое\r\n	отрицание (-) – меняет знак операнда на\r\n	противоположный.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Логическое\r\n	отрицание (!) – определяет операцию\r\n	инверсия для логического типа.&lt;/p&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Пример:&lt;/p&gt;\r\n	&lt;table&gt;\r\n	\r\n	\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;code&gt;\r\nstatic void Main()\r\n\r\n{\r\n\r\nint i = 3, j=-4;\r\n\r\nbool a = true, b=false;\r\n\r\nConsole.WriteLine(&quot;{0} {1}&quot;, -i, -j);\r\n\r\nConsole.WriteLine(&quot;{0} {1}&quot;, !a, !b);\r\n\r\n}\r\n&lt;/code&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Результат\r\n	работы программы:&lt;/p&gt;\r\n	&lt;p&gt;\r\n	-3\r\n	4&lt;/p&gt;\r\n	&lt;p&gt;False\r\n	True&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;/table&gt;\r\n&lt;p&gt;&lt;b&gt;4.\r\nЯвное преобразование типа. &lt;/b&gt;Используется\r\nдля явного преобразования из одного\r\nтипа в другой. Формат операции:&lt;/p&gt;\r\n&lt;p&gt;(тип)\r\nвыражение;&lt;/p&gt;\r\n&lt;p&gt;Пример:&lt;/p&gt;\r\n	&lt;table&gt;\r\n	\r\n	\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;code&gt;\r\nstatic void Main()\r\n\r\n{\r\n\r\nint i = -4;\r\n\r\nbyte j = 4;\r\n\r\nint a = (int)j; //преобразование без потери точности\r\n\r\nbyte b = (byte)i; //преобразование с потерей точности\r\n\r\nConsole.WriteLine(&quot;{0} {1}&quot;, a, b);\r\n\r\n}\r\n&lt;/code&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Результат\r\n	работы программы:&lt;/p&gt;\r\n	&lt;p&gt;4\r\n	252&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;/table&gt;\r\n&lt;p&gt;&lt;b&gt;5.\r\nУмножение (*), деление (/) и деление с\r\nостатком (%).&lt;/b&gt;&lt;/p&gt;\r\n&lt;p&gt;Операции\r\nумножения и деления применимы для\r\nцелочисленных и вещественных типов\r\nданных. Для других типов эти операции\r\nприменимы, если для них возможно неявное\r\nпреобразование к целым или вещественным\r\nтипам. При этом тип результата равен\r\n&quot;наибольшему&quot; из типов операндов,\r\nно не менее int. Если оба операнда при\r\nделении целочисленные, то и результат\r\nтоже целочисленный.&lt;/p&gt;\r\n&lt;p&gt;Пример:&lt;/p&gt;\r\n&lt;table&gt;\r\n	\r\n	\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;code&gt;\r\nstatic void Main()\r\n\r\n{\r\n\r\nint i = 100, j = 15;\r\n\r\ndouble a = 14.2, b = 3.5;\r\n\r\nConsole.WriteLine(&quot;{0} {1} {2}&quot;, i*j, i/j, i%j);\r\n\r\nConsole.WriteLine(&quot;{0} {1} {2}&quot;, a * b, a / b, a % b);\r\n\r\n}\r\n&lt;/code&gt;&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Результат\r\n	работы программы:&lt;/p&gt;\r\n	&lt;p&gt;\r\n	1500\r\n	6 10&lt;/p&gt;\r\n	&lt;p&gt;49.7\r\n	4.05714285714286 0.1999999999999999&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n&lt;/table&gt;\r\n&lt;p&gt;&lt;b&gt;6.\r\nСложение (+) и вычитание (-).&lt;/b&gt;\r\nОперации сложения и вычитания применимы\r\nдля целочисленных и вещественных типов\r\nданных. Для других типов эти операции\r\nприменимы, если для них возможно неявное\r\nпреобразование к целым или вещественным\r\nтипам.&lt;/p&gt;\r\n&lt;p&gt;&lt;b&gt;7.\r\nОперации отношения ( &lt;, &lt;=, &gt;, &gt;=, ==,\r\n!=)&lt;/b&gt;.\r\nОперации отношения сравнивают значения\r\nлевого и правого операндов. Результат\r\nоперации логического типа: true - если\r\nзначения совпадают, false - в противном\r\nслучае.&lt;/p&gt;\r\n&lt;p&gt;Пример:&lt;/p&gt;\r\n	&lt;table&gt;\r\n	\r\n	\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;code&gt;\r\nstatic void Main()\r\n\r\n{\r\n\r\nint i = 15, j = 15;\r\n\r\nConsole.WriteLine(i\r\n\r\nConsole.WriteLine(i&lt;=j); //меньше или равно\r\n\r\nConsole.WriteLine(i&gt;j); //больше\r\n\r\nConsole.WriteLine(i&gt;=j); //больше или равно\r\n\r\nConsole.WriteLine(i==j); //равно\r\n\r\nConsole.WriteLine(i!=j); //не равно\r\n\r\n}\r\n&lt;/code&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Результат\r\n	работы программы:&lt;/p&gt;\r\n	&lt;p&gt;\r\n	False&lt;/p&gt;\r\n	&lt;p&gt;\r\n	True&lt;/p&gt;\r\n	&lt;p&gt;\r\n	False&lt;/p&gt;\r\n	&lt;p&gt;\r\n	True&lt;/p&gt;\r\n	&lt;p&gt;\r\n	True&lt;/p&gt;\r\n	&lt;p&gt;False&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;/table&gt;\r\n&lt;p&gt;&lt;b&gt;8.\r\nЛогические операции:&lt;/b&gt;\r\nИ (&amp;amp;&amp;amp;), ИЛИ (||).&lt;/p&gt;\r\n&lt;p&gt;Логические\r\nоперации применяются к операндам\r\nлогического типа. Результат логической\r\nоперации И имеет значение истина тогда\r\nи только тогда, когда оба операнда\r\nпринимают значение истина. Результат\r\nлогической операции ИЛИ имеет значение\r\nистина тогда и только тогда, когда хотя\r\nбы один из операндов принимает значение\r\nистина.&lt;/p&gt;\r\n&lt;p&gt;Пример:&lt;/p&gt;\r\n&lt;code&gt;\r\nstatic void Main()\r\n\r\n{\r\n\r\nConsole.WriteLine(&quot;x y x и y x или y&quot;);\r\n\r\nConsole.WriteLine(&quot;{0} {1} {2} {3}&quot;, false, false, false&amp;&amp;false, false||false);\r\n\r\nConsole.WriteLine(&quot;{0} {1} {2} {3}&quot;, false, true, false&amp;&amp;true, false||true);\r\n\r\nConsole.WriteLine(&quot;{0} {1} {2} {3}&quot;, true, false, true&amp;&amp;false, true||false);\r\n\r\nConsole.WriteLine(&quot;{0} {1} {2} {3}&quot;, true, true, true&amp;&amp;true, true||true);\r\n\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Результат\r\nработы программы:&lt;/p&gt;\r\n&lt;p&gt;\r\nx\r\ny x и y x или y&lt;/p&gt;\r\n&lt;p&gt;\r\nFalse\r\nFalse False False&lt;/p&gt;\r\n&lt;p&gt;\r\nFalse\r\nTrue False True&lt;/p&gt;\r\n&lt;p&gt;\r\nTrue\r\nFalse False True&lt;/p&gt;\r\n&lt;p&gt;\r\nTrue\r\nTrue True True&lt;/p&gt;\r\n&lt;p&gt;&lt;b&gt;9.\r\nОперации присваивания:&lt;/b&gt;\r\n=, +=, -= и т.д.&lt;/p&gt;\r\n&lt;p&gt;Формат\r\nоперации простого\r\nприсваивания\r\n(=): &lt;b&gt;операнд_2\r\n= операнд_1;&lt;/b&gt;&lt;/p&gt;\r\n&lt;p&gt;\r\nВ\r\nрезультате выполнения этой операции\r\nвычисляется значение операнда_1, и\r\nрезультат записывается в операнд_2.\r\nВыражение вида a=b=c=100 выполняется справа\r\nналево: результатом выполнения c=100\r\nявляется число 100, которое затем\r\nприсваивается переменной b, результатом\r\nчего опять является 100, которое\r\nприсваивается переменной a.&lt;/p&gt;\r\n&lt;p&gt;\r\nКроме\r\nпростой операции присваивания существуют\r\nсложные\r\nоперации присваивания,\r\nнапример, умножение с присваиванием\r\n(*=), деление с присваиванием (/=), остаток\r\nот деления с присваиванием (%=), сложение\r\nс присваиванием (+=), вычитание с\r\nприсваиванием (-=) и т.д.&lt;/p&gt;\r\n&lt;p&gt;\r\nВ\r\nсложных операциях присваивания, например,\r\nпри сложении\r\nс присваиванием,\r\nк операнду_2 прибавляется операнд_1, и\r\nрезультат записывается в операнд_2. То\r\nесть, выражение с += а является более\r\nкомпактной записью выражения с = с + а.&lt;/p&gt;\r\n&lt;p&gt;\r\nЕсли\r\nв одном выражении соседствуют операции\r\nодного приоритета, то операции присваивания\r\nи условная операции выполняются справа\r\nналево, а остальные наоборот. Если\r\nнеобходимо изменить порядок выполнения\r\nопераций, то в выражении необходимо\r\nпоставить круглые скобки.&lt;/p&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;&lt;b&gt;Выражения\r\n	и преобразование типов&lt;/b&gt;&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;\r\nВыражение\r\n- это синтаксическая единица языка,\r\nопределяющая способ вычисления некоторого\r\nзначения. Выражения состоят из операндов,\r\nопераций и скобок. Каждый операнд\r\nявляется в свою очередь выражением или\r\nодним из его частных случаев - константой,\r\nпеременной или функций.&lt;/p&gt;\r\n&lt;p&gt;\r\nВ языке\r\nС# предусмотрено вычисление различных\r\nматематических функций. Для их\r\nиспользования необходимо обратиться\r\nк классу Math, который содержит стандартные\r\nматематические функции. Этот класс\r\nсодержит два статических поля, задающих\r\nконстанты E и PI, а также 23 статических\r\nметода.&lt;/p&gt;\r\n&lt;p&gt;Методы\r\nзадают:&lt;/p&gt;\r\n&lt;ul&gt;\r\n	&lt;li&gt;&lt;p&gt;тригонометрические\r\n	функции - Sin,\r\n	Cos, Tan;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;обратные\r\n	тригонометрические функции - ASin,\r\n	ACos, ATan, ATan2 (sinx, cosx);&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;гиперболические\r\n	функции - Tanh,\r\n	Sinh, Cosh;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;экспоненту\r\n	и логарифмические функции - Exp,\r\n	Log, Log10;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;модуль,\r\n	корень, знак - Abs,\r\n	Sqrt, Sign;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;функции\r\n	округления - Ceiling,\r\n	Floor, Round;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;минимум,\r\n	максимум, степень, остаток - Min,\r\n	Max, Pow, IEEERemainder.&lt;/p&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Пример:\r\nНаписать\r\nпрограмму для расчета функции \r\n.&lt;/p&gt;\r\n&lt;code&gt;\r\nstatic void Main(string[] args)\r\n\r\n{\r\n\r\ndouble x, y;\r\n\r\nConsole.WriteLine(&quot;Введите значение х:&quot;);\r\n\r\nx = Convert.ToDouble(Console.ReadLine());\r\n\r\ny = Math.Sqrt((x+3)/(x-3));\r\n\r\nConsole.WriteLine(&quot;Результат: {0}&quot;, y);\r\n\r\n}\r\n&lt;/code&gt;\r\n&lt;h1&gt;Вопросы\r\nдля самоконтроля&lt;/h1&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;Какая\r\n	программа называется линейной?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Почему\r\n	необходимо указывать тип используемой\r\n	переменной при ее описании?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Как\r\n	следует выбирать тип переменных?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Какие\r\n	операции определены в С#?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Чем\r\n	характеризуются переменные?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Какие\r\n	функции ввода-вывода существуют в С#?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Каким\r\n	классом необходимо воспользоваться\r\n	для реализации математических выражений?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Каких\r\n	математических функций нет в С#?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Как\r\n	определяется порядок вычислений в С#?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Для\r\n	чего используется оператор присваивания?&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;h1&gt;ПРАКТИЧЕСКАЯ\r\nЧАСТЬ&lt;/h1&gt;\r\n&lt;p&gt;&lt;b&gt;Задание\r\n№1.&lt;/b&gt;\r\nНаписать программу, которая реализует\r\nдиалог с пользователем:&lt;/p&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	запрашивает\r\n	с клавиатуры два целых числа, и выводит\r\n	на экран сумму данных чисел:&lt;/p&gt;&lt;img src=&quot;https://sun9-40.userapi.com/impf/nyH6POmTkHwqXnBtRRNzldz3xqMBffnmbDFF4g/PBACk1UgByU.jpg?size=598x109&amp;quality=96&amp;sign=626c794c79019fdb8096bb76e6a76836&amp;type=album&quot; alt=&quot;image&quot;&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;\r\n&lt;/p&gt;\r\n&lt;ol start=&quot;2&quot;&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	запрашивает\r\n	с клавиатуры три целых числа, и выводит\r\n	на экран сумму данных чисел в прямом и\r\n	обратном порядке:&lt;/p&gt;&lt;img src=&quot;https://sun9-79.userapi.com/impf/5ExTbobB50i9WFG8BX1h8naJJqd8cdu-ywoHyA/ORPyirA1A_g.jpg?size=600x111&amp;quality=96&amp;sign=a3ddacac9feef97afadb5676c410ad1e&amp;type=album&quot; alt=&quot;image&quot;&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;\r\n&lt;/p&gt;\r\n&lt;ol start=&quot;3&quot;&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	запрашивает\r\n	с клавиатуры три целых числа, и выводит\r\n	на экран сумму данных чисел:&lt;/p&gt;&lt;img src=&quot;https://sun2.beltelecom-by-minsk.userapi.com/impf/3EqTKnYIYCmHqJSoUyfRAcKv_9UL4TXrKppMfw/MKNs0lC6bGQ.jpg?size=595x120&amp;quality=96&amp;sign=ca593396d3136e8d4718c0eb7df1c130&amp;type=album&quot; alt=&quot;image&quot;&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;\r\n&lt;/p&gt;\r\n&lt;ol start=&quot;4&quot;&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	запрашивает\r\n	с клавиатуры два вещественных числа,\r\n	и выводит на экран произведение данных\r\n	чисел (вещественные числа выводятся с\r\n	точностью до 1 знака после запятой):&lt;/p&gt;&lt;img src=&quot;https://sun9-33.userapi.com/impf/UfyIoot5MRSjQCXX2rWU7SzcXocMDCE9jrxxzw/jdaPYOShjKs.jpg?size=591x119&amp;quality=96&amp;sign=c7c5833ca843a62d1cfa9e4f1e0fd679&amp;type=album&quot; alt=&quot;image&quot;&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;\r\n&lt;/p&gt;\r\n&lt;ol start=&quot;5&quot;&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	запрашивает\r\n	с клавиатуры два вещественных числа,\r\n	и выводит на экран результат деления\r\n	первого числа на второе (вещественные\r\n	числа выводятся с точностью до 3 знаков\r\n	после запятой):&lt;/p&gt;&lt;img src=&quot;https://sun9-58.userapi.com/impf/zYbmzKNSdL-IsYqCUYLatZAxle8k9Zd6e9aqHQ/3ATCgmWn5ok.jpg?size=619x119&amp;quality=96&amp;sign=69b11e08530e82b77963ae856e0860d1&amp;type=album&quot; alt=&quot;image&quot;&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;\r\n&lt;/p&gt;\r\n&lt;ol start=&quot;6&quot;&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	запрашивает\r\n	с клавиатуры три вещественных числа,\r\n	и выводит на следующее сообщение\r\n	(вещественные числа выводятся с точностью\r\n	до 2 знаков после запятой):&lt;/p&gt;&lt;img src=&quot;https://sun9-40.userapi.com/impf/6jlPEFU6FTv0hjrnx66cFPTl_iGTg4AB2P1T-g/0FuFa8aLyfw.jpg?size=603x141&amp;quality=96&amp;sign=8faf7c0c08317cfa56d3928a19e93866&amp;type=album&quot; alt=&quot;image&quot;&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;\r\n&lt;/p&gt;\r\n&lt;ol start=&quot;7&quot;&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	запрашивает\r\n	с клавиатуры два целых числа, и выводит\r\n	на экран произведение данных чисел:&lt;/p&gt;&lt;img src=&quot;https://sun9-5.userapi.com/impf/Rfc2rjyOfccjuMOclWJ6YdMHe6-3nOzEKKMl0Q/I4gKjKc3ABA.jpg?size=633x117&amp;quality=96&amp;sign=e28fa15d2f3c8617f8a92b9fdd261ee8&amp;type=album&quot; alt=&quot;image&quot;&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;\r\n&lt;/p&gt;\r\n&lt;ol start=&quot;8&quot;&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	запрашивает\r\n	с клавиатуры три целых числа, и выводит\r\n	на экран произведение данных чисел в\r\n	прямом и обратном порядке:&lt;/p&gt;&lt;img src=&quot;https://sun9-61.userapi.com/impf/-GEy8kfCleWY5gS49iLNQrZLqFPa7xcLz2GNcQ/IiMQWqq6skU.jpg?size=628x127&amp;quality=96&amp;sign=afc337815a646b4e82dfce7f4c7e5add&amp;type=album&quot; alt=&quot;image&quot;&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;\r\n&lt;/p&gt;\r\n&lt;ol start=&quot;9&quot;&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	запрашивает\r\n	с клавиатуры два вещественных числа,\r\n	и выводит на экран сумму данных чисел\r\n	(вещественные числа выводятся с точностью\r\n	до 2 знаков после запятой):&lt;/p&gt;&lt;img src=&quot;https://sun9-11.userapi.com/impf/MgOjmHz8ZVFqp0pHhMMCBCEgIsg-NtmtlNJhCg/xM9MDq3q6Fs.jpg?size=591x113&amp;quality=96&amp;sign=20615121a5f7f057c3f6ac4fccd92bf7&amp;type=album&quot; alt=&quot;image&quot;&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;\r\n&lt;/p&gt;\r\n&lt;ol start=&quot;10&quot;&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	запрашивает\r\n	с клавиатуры два вещественных числа,\r\n	и выводит на экран результат деления\r\n	второго числа на первое (вещественные\r\n	числа выводятся с точностью до 2 знаков\r\n	после запятой):&lt;/p&gt;&lt;img src=&quot;https://sun9-42.userapi.com/impf/BfUEZ2_Fo44DcQ8cYRXwvTp1wQOjtGyOfwSuDA/HLtHZbG7sVg.jpg?size=666x119&amp;quality=96&amp;sign=7476625209e04950cf0f8c9f524298a8&amp;type=album&quot; alt=&quot;image&quot;&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;\r\n&lt;/p&gt;\r\n&lt;ol start=&quot;11&quot;&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	запрашивает\r\n	с клавиатуры три вещественных числа и\r\n	выводит следующее сообщение\r\n	(a+(b+c))=(a+c+b)\r\n	(вещественные\r\n	числа выводятся с точностью до 4 знаков\r\n	после запятой):&lt;/p&gt;&lt;img src=&quot;https://sun9-32.userapi.com/impf/7ImsWH3YUKGTcsFO5PNBDbdRMA13i6iZjzIL6A/02tfMj5fuBA.jpg?size=632x148&amp;quality=96&amp;sign=28b8ae86b4a8a8410dfdf0c9b5a6bb9e&amp;type=album&quot; alt=&quot;image&quot;&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;\r\n&lt;/p&gt;\r\n&lt;ol start=&quot;12&quot;&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	запрашивает\r\n	с клавиатуры четыре вещественных числа,\r\n	и выводит на экран результат деления\r\n	первого числа на второе плюс третьего\r\n	на четвертое (вещественные числа\r\n	выводятся с точностью до 2 знаков после\r\n	запятой):&lt;/p&gt;&lt;img src=&quot;https://sun1.beltelecom-by-minsk.userapi.com/impf/1hLG2Nwmd49zf801Hqhv42gAG0whXH4kwrPWOg/MEOuZ94jo-Y.jpg?size=602x148&amp;quality=96&amp;sign=5a0175df4716b8c654f716fac1beeb45&amp;type=album&quot; alt=&quot;image&quot;&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;\r\n&lt;/p&gt;\r\n&lt;ol start=&quot;13&quot;&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	запрашивает\r\n	с клавиатуры два целых числа, и выводит\r\n	на экран результат их суммы, разности\r\n	и произведения:&lt;/p&gt;&lt;img src=&quot;https://sun9-41.userapi.com/impf/1snHmDePQXAUCUezQhmWAl2hOmroVirDOOJgeQ/wBaXH1feFZE.jpg?size=627x125&amp;quality=96&amp;sign=3622a61147c71c2bf5c70278d30aa5fb&amp;type=album&quot; alt=&quot;image&quot;&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;\r\n&lt;/p&gt;\r\n&lt;ol start=&quot;14&quot;&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	переменной\r\n	вещественного типа х\r\n	присваивает значение, равное полусумме\r\n	значений а и b с точностью 3 знака после\r\n	запятой:&lt;/p&gt;&lt;img src=&quot;https://sun2.beltelecom-by-minsk.userapi.com/impf/HcEL7DbxI-XtzOo4I0R9pHVcAPEUdKNuCGDWeg/J6Es5waA8Os.jpg?size=682x130&amp;quality=96&amp;sign=5b200a40511979d916b8b525709dc315&amp;type=album&quot; alt=&quot;image&quot;&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;\r\n&lt;/p&gt;\r\n&lt;ol start=&quot;15&quot;&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	утраивает\r\n	значение вещественной переменной х\r\n	и выполняет деление на целое число y,\r\n	результат округлить до 4 знаков после\r\n	запятой:&lt;/p&gt;&lt;img src=&quot;https://sun9-10.userapi.com/impf/cy2JiWc1qV1xdlglHyv7NbadigMKCldchQnOyQ/13DtGnjmazs.jpg?size=693x93&amp;quality=96&amp;sign=83af69cfbebadfd799b6f2be5ee8eb33&amp;type=album&quot; alt=&quot;image&quot;&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;\r\n&lt;/p&gt;\r\n&lt;p&gt;&lt;b&gt;Задание\r\n№2.&lt;/b&gt;\r\nНаписать программу:&lt;/p&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;Дано\r\n	двузначное число. Найти число десятков\r\n	в нем.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Дано\r\n	двузначное число. Найти число единиц\r\n	в нем.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Дано\r\n	двузначное число. Найти сумму его цифр.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Дано\r\n	двузначное число. Найти произведение\r\n	его цифр.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Дано\r\n	трехзначное число. Найти число десятков\r\n	в нем.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Дано\r\n	трехзначное число. Найти число единиц\r\n	в нем.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Дано\r\n	трехзначное число. Найти сумму его\r\n	цифр.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Дано\r\n	трехзначное число. Найти произведение\r\n	его цифр.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Дано\r\n	четырехзначное число. Найти сумму его\r\n	цифр.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Дано\r\n	четырехзначное число. Найти произведение\r\n	его цифр.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Дано\r\n	трехзначное число. Найти число, полученное\r\n	при прочтении его цифр справа налево.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Дано\r\n	трехзначное число. В нем зачеркнули\r\n	первую слева цифру и приписали ее в\r\n	конце. Найти полученное число.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Дано\r\n	трехзначное число. В нем зачеркнули\r\n	последнюю справа цифру и приписали ее\r\n	в начале. Найти полученное число.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Дано\r\n	трехзначное число. Найти число, полученное\r\n	при перестановке первой и второй цифр\r\n	заданного числа.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Дано\r\n	трехзначное число. Найти число, полученное\r\n	при перестановке второй и третьей цифр\r\n	заданного числа.&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;&lt;b&gt;Задание\r\n№3.&lt;/b&gt;\r\nНаписать программу, которая подсчитывает:&lt;/p&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;периметр\r\n	квадрата, площадь которого равна а;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;площадь\r\n	равностороннего треугольника, периметр\r\n	которого равен p;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;расстояние\r\n	между точками с координатами a, b и с,\r\n	d;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;среднее\r\n	арифметическое кубов двух данных\r\n	чисел;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;среднее\r\n	геометрическое модулей двух данных\r\n	чисел;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;гипотенузу\r\n	прямоугольного треугольника по двум\r\n	данным катетам a, b.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;площадь\r\n	прямоугольного треугольника по двум\r\n	катетам a, b.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;периметр\r\n	прямоугольного треугольника по двум\r\n	катетам a, b.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;ребро\r\n	куба, площадь полной поверхности\r\n	которого равна s;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;ребро\r\n	куба, объем которого равен v;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;периметр\r\n	треугольника, заданного координатами\r\n	вершин x1, y1, x2, y2, x3, y3;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;площадь\r\n	треугольника, заданного координатами\r\n	вершин x1, y1, x2, y2, x3, y3;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;радиус\r\n	окружности, длина которой равна l;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;радиус\r\n	окружности, площадь круга которой\r\n	равна s;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;площадь\r\n	равнобедренной трапеции с основаниями\r\n	a и b и углом ɤ при большем основании;&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;&lt;b&gt;Задание\r\n№4.&lt;/b&gt;\r\nНаписать программу:&lt;/p&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;Даны\r\n	основания и высота равнобедренной\r\n	трапеции. Найти ее периметр.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Дана\r\n	длина ребра куба. Найти объем куба и\r\n	площадь его боковой поверхности.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Даны\r\n	два действительных положительных\r\n	числа. Найти среднее арифметическое и\r\n	среднее геометрическое этих чисел.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Даны\r\n	два действительных числа. Найти среднее\r\n	арифметическое этих чисел и среднее\r\n	геометрическое их модулей.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Даны\r\n	катеты прямоугольного треугольника.\r\n	Найти его гипотенузу и площадь.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Определить\r\n	периметр правильного n-угольника,\r\n	описанного около окружности радиуса\r\n	r.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Три\r\n	сопротивления R&lt;sub&gt;1&lt;/sub&gt;,\r\n	R&lt;sub&gt;2&lt;/sub&gt;,\r\n	R&lt;sub&gt;3&lt;/sub&gt;\r\n	соединены параллельно. Найти сопротивление\r\n	соединения.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Напишите\r\n	программу, запрашивающую высоту дома\r\n	h\r\n	(в\r\n	метрах), ускорение свободного падения\r\n	g\r\n	и\r\n	вычисляющую время падения кирпича t(в\r\n	секундах) с крыши этого дома по формуле:&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;\r\n.&lt;/p&gt;\r\n&lt;ol start=&quot;9&quot;&gt;\r\n	&lt;li&gt;&lt;p&gt;Расстояние\r\n	до ближайшей к Земле звезды Альфа\r\n	Центавра 4,3 световых года. Скорость\r\n	света – 300 000 км/с. Скорость земного\r\n	звездолета 100 км/с. За сколько лет\r\n	звездолет долетит до звезды?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Пушка\r\n	стреляет под углом 30° к линии горизонта.\r\n	Масса снаряда 30 кг, начальная скорость\r\n	500 м/с. Найти дальность полета снаряда?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Определить\r\n	силу притяжения F\r\n	между телами массы т&lt;sub&gt;1&lt;/sub&gt;\r\n	и т&lt;sub&gt;2&lt;/sub&gt;,\r\n	находящимися на расстоянии r\r\n	друг от друга.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Даны\r\n	гипотенуза и катет прямоугольного\r\n	треугольника. Найти второй катет и\r\n	радиус вписанной окружности.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Известна\r\n	длина окружности. Найти площадь круга,\r\n	ограниченного этой окружностью.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Известен\r\n	объем и масса тела. Определить плотность\r\n	материала этого тела.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Треугольник\r\n	задан величинами своих углов и радиусом\r\n	описанной окружности. Найти стороны\r\n	треугольника.&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;h1&gt;Контрольные вопросы&lt;/h1&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;Какова\r\n	общая структура программы на С#.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Существуют\r\n	ли ограничения на множество целых\r\n	чисел, используемых в языке С#?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Какие\r\n	формы записи вещественных чисел\r\n	используются в языке С#?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Из\r\n	каких символов может состоять\r\n	идентификатор?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Чем\r\n	вызвана необходимость использования\r\n	комментариев в программе?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Каково\r\n	назначение методов write\r\n	и writeline?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Перечислите\r\n	способы вывода данных на дисплей?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Перечислите\r\n	основные управляющие последовательности\r\n	языка С#?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Назовите\r\n	основные методы класса Math\r\n	языка С#?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Какой\r\n	метод класса Console\r\n	используется для того, чтобы вводимые\r\n	данные читались с новой строки?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Что\r\n	такое выражения в языке С#?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Понятие\r\n	преобразования типов в языке С#?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Назовите\r\n	формы записи операции&lt;b&gt;\r\n	&lt;/b&gt;инкремента и декремента\r\n	языка С#?&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;h1&gt;ДОМАШНЕЕ ЗАДАНИЕ&lt;/h1&gt;\r\n&lt;p&gt;Павловская Т. А., «С# Программирование на языке высокого уровня», c. 14-21.&lt;/p&gt;\r\n&lt;p&gt;Пахомов Б. И. “С# для начинающих” 2014, С. 44-51&lt;/p&gt;', 2);
INSERT INTO `labs` (`IDLab`, `StartNumber`, `EndNumber`, `Theme`, `Goal`, `Equipment`, `Content`, `IDStatus`) VALUES
(3, 3, 3, 'Разработка программ с использованием операторов выбора, цикла и передачи управления.', 'Формировать практические навыки и умения написания программ, реализующих алгоритмы ветвления и цикла.', 'ПК, среда разработки Microsoft Visual Studio .NET.', '&lt;p&gt;\r\n&lt;b&gt;ТЕОРЕТИЧЕСКИЕ\r\nСВЕДЕНИЯ&lt;/b&gt;&lt;/p&gt;\r\n&lt;p&gt;\r\nКомандой\r\nповторения\r\nили циклом\r\nназывается такая форма организации\r\nдействий, при которой одна и та же\r\nпоследовательность действий повторяется\r\nдо тех пор, пока сохраняется значение\r\nнекоторого логического выражения. При\r\nизменении значения логического выражения\r\nна противоположное повторения прекращаются\r\n(цикл завершается).&lt;/p&gt;\r\n&lt;p&gt;\r\nДля\r\nорганизации цикла необходимо выполнить\r\nследующие действия:&lt;/p&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;перед\r\n	началом цикла задать начальное значение\r\n	параметра;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;внутри\r\n	цикла изменять параметр цикла с помощью\r\n	оператора присваивания;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;проверять\r\n	условие повторения или окончания цикла;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;управлять\r\n	циклом, т.е. переходить к его началу,\r\n	если он не закончен, или выходить из\r\n	цикла в противном случае.&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;\r\nРазличают\r\nциклы с известным числом повторений\r\n(цикл с параметром) и итерационные (с\r\nпред- и постусловием).&lt;/p&gt;\r\n&lt;p&gt;\r\nВ цикле\r\nс известным числом повторений параметр\r\nизменяется в заданном диапазоне.&lt;/p&gt;\r\n&lt;p&gt;\r\nЕсли\r\nв цикле изменяется простая переменная,\r\nто она является параметром цикла; если\r\nв цикле изменяется переменная с индексом,\r\nто индекс этой переменной является\r\nпараметром цикла.&lt;/p&gt;\r\n&lt;p&gt;\r\nК\r\nоператорам цикла относятся: цикл с\r\nпредусловием while,\r\nцикл с постусловием do\r\nwhile,\r\nцикл с параметром for\r\nи цикл перебора foreach.&lt;/p&gt;\r\n&lt;p&gt;&lt;b&gt;Цикл\r\nс предусловием &lt;/b&gt;&lt;b&gt;while&lt;/b&gt;&lt;/p&gt;\r\n&lt;p&gt;\r\nОператор\r\nцикла while\r\nорганизует выполнение одного оператора\r\n(простого или составного) неизвестное\r\nзаранее число раз. Формат цикла while:&lt;/p&gt;\r\n&lt;p&gt;\r\n&lt;b&gt;while\r\n(выражение B) оператор&lt;/b&gt;\r\n&lt;b&gt;S&lt;/b&gt;&lt;/p&gt;\r\n&lt;p&gt;\r\nгде B\r\n- выражение, истинность которого\r\nпроверяется (условие завершения цикла);\r\nS - тело цикла - оператор (простой или\r\nсоставной).&lt;/p&gt;\r\n&lt;p&gt;\r\nПример:\r\nВывести на экран целые числа из интервала\r\nот 1 до n.&lt;/p&gt;\r\n&lt;code&gt;\r\nstatic void Main()\r\n\r\n{\r\n\r\nConsole.Write(&quot;N= &quot;);\r\n\r\nint n=int.Parse(Console.ReadLine());\r\n\r\nint i = 1;\r\n\r\nwhile (i &lt;= n) //пока i меньше или равно n\r\n\r\nConsole.Write(&quot; &quot;+ i++ ); //выводим i на экран, затем увеличиваем его на 1\r\n\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;\r\nРезультаты\r\nработы программы:&lt;/p&gt;\r\n&lt;code&gt;\r\nn ответ\r\n\r\n10 1 2 3 4 5 6 7 8 9 10\r\n&lt;/code&gt;\r\n&lt;p&gt;&lt;b&gt;Цикл\r\nс постусловием &lt;/b&gt;&lt;b&gt;do\r\nwhile&lt;/b&gt;&lt;/p&gt;\r\n&lt;p&gt;\r\nОператор\r\nцикла do\r\nwhile\r\nтакже организует выполнение одного\r\nоператора (простого или составного)\r\nнеизвестное заранее число раз. Однако\r\nв отличие от цикла while\r\nусловие завершения цикла проверяется\r\nпосле выполнения тела цикла. Формат\r\nцикла do\r\nwhile:&lt;/p&gt;\r\n&lt;p&gt;\r\n&lt;b&gt;do\r\nоператор S while выражение&lt;/b&gt;\r\n&lt;b&gt;B;&lt;/b&gt;&lt;/p&gt;\r\n&lt;p&gt;\r\nгде В\r\n- выражение, истинность которого\r\nпроверяется (условие завершения цикла);\r\nоператор S - тело цикла - оператор (простой\r\nили блок).&lt;/p&gt;\r\n&lt;p&gt;\r\nПример:\r\nВывести на экран целые числа из интервала\r\nот 1 до n.&lt;/p&gt;\r\n&lt;code&gt;\r\nstatic void Main()\r\n\r\n{\r\n\r\nConsole.Write(&quot;N= &quot;);\r\n\r\nint n=int.Parse(Console.ReadLine());\r\n\r\nint i = 1;\r\n\r\ndo\r\n\r\nConsole.Write(&quot; &quot; + i++);\r\n\r\n//выводим i на экран, затем увеличиваем его на 1\r\n\r\nwhile (i &lt;= n); //пока i меньше или равно n\r\n\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;&lt;b&gt;Цикл\r\nс параметром &lt;/b&gt;&lt;b&gt;for&lt;/b&gt;&lt;/p&gt;\r\n&lt;p&gt;\r\nЦикл\r\nс параметром имеет следующую структуру:&lt;/p&gt;\r\n&lt;p&gt;\r\n&lt;b&gt;for\r\n(&lt;инициализация&gt;; &lt;выражение&gt;;\r\n&lt;модификация&gt;) &lt;оператор&gt;;&lt;/b&gt;&lt;/p&gt;\r\n&lt;code&gt;\r\nstatic void Main()\r\n\r\n{\r\n\r\nConsole.Write(&quot;N= &quot;);\r\n\r\nint n=int.Parse(Console.ReadLine());\r\n\r\nfor (int i=1; i&lt;=n;) //блок модификации пустой\r\n\r\nConsole.Write(&quot; &quot; + i++);\r\n\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;\r\nОператор\r\ndo while\r\nобычно используют,\r\nкогда цикл требуется выполнить хотя бы\r\nодин раз. Оператором while\r\nудобнее пользоваться в случаях, когда\r\nчисло итераций заранее не известно.\r\nОператор for\r\nпредпочтительнее в большинстве остальных\r\nслучаев.&lt;/p&gt;\r\n&lt;p&gt;\r\n&lt;b&gt;Цикл\r\nперебора &lt;/b&gt;&lt;b&gt;foreach&lt;/b&gt;&lt;/p&gt;\r\n&lt;p&gt;\r\nОператор\r\nforeach\r\nприменяется для перебора элементов в\r\nспециальным образом организованной\r\nгруппе данных, например в массиве.\r\nУдобство этого вида цикла заключается\r\nв том, что нам не требуется определять\r\nколичество элементов в группе и выполнять\r\nперебор по индексу - мы просто указываем\r\nна необходимость перебрать все элементы\r\nгруппы.&lt;/p&gt;\r\n&lt;p&gt;\r\nСинтаксис\r\nоператора:&lt;/p&gt;\r\n&lt;p&gt;\r\n&lt;b&gt;foreach\r\n(&lt;тип&gt; &lt;имя&gt; in &lt;группа&gt;) &lt;тело\r\nцикла&gt;&lt;/b&gt;&lt;/p&gt;\r\n&lt;p&gt;\r\nгде\r\nимя\r\nопределяет локальную по отношению к\r\nциклу переменную, которая будет по\r\nочереди принимать все значения из\r\nуказанной группы,\r\nа тип\r\nсоответствует базовому типу элементов\r\nгруппы.&lt;/p&gt;\r\n&lt;p&gt;\r\nОграничением\r\nоператора foreach\r\nявляется то, что с его помощью можно\r\nтолько просматривать значения элементов\r\nв группе данных, но нельзя их изменять.&lt;/p&gt;\r\n&lt;p&gt;\r\nПример\r\nиспользования оператора foreach\r\nдля работы с одномерными массивами:&lt;/p&gt;\r\n&lt;code&gt;\r\nstatic void PrintArray(string a, int [] mas)\r\n\r\n{\r\n\r\nConsole.WriteLine(a);\r\n\r\nforeach (int x in mas)Console.Write(&quot;{0} &quot;, x);\r\n\r\nConsole.WriteLine();\r\n\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;\r\n&lt;b&gt;Вложенные\r\nциклы&lt;/b&gt;&lt;/p&gt;\r\n&lt;p&gt;\r\nЦиклы\r\nмогут быть простые или вложенные\r\n(кратные, циклы в цикле). Вложенными\r\nмогут быть циклы любых типов: while,\r\ndo while, for. Каждый\r\nвнутренний цикл должен быть полностью\r\nвложен во все внешние циклы. &quot;Пересечения&quot;\r\nциклов не допускаются.&lt;/p&gt;\r\n&lt;p&gt;\r\nПример:\r\nВывести на экран числа следующим образом:&lt;/p&gt;\r\n&lt;p&gt;\r\n2\r\n2 2 2 2&lt;/p&gt;\r\n&lt;p&gt;\r\n2\r\n2 2 2 2&lt;/p&gt;\r\n&lt;p&gt;\r\n2\r\n2 2 2 2&lt;/p&gt;\r\n&lt;p&gt;\r\n2\r\n2 2 2 2&lt;/p&gt;\r\n&lt;code&gt;\r\nstatic void Main()\r\n\r\n{\r\n\r\nfor (int i = 1; i &lt;= 4; ++i, Console.WriteLine()) //1\r\n\r\nfor (int j=1; j&lt;=5; ++j)\r\n\r\nConsole.Write(&quot; &quot; + 2);\r\n\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;\r\nЗамечание.\r\nВ строке 1 в блоке модификации содержится\r\nдва оператора ++i\r\nи Console.WriteLine().\r\nВ данном случае после каждого увеличения\r\nпараметра i\r\nна 1 курсор будет переводиться на новую\r\nстроку.&lt;/p&gt;\r\n&lt;p&gt;&lt;b&gt;Оператор\r\nперехода к следующей итерации цикла\r\n&lt;/b&gt;continu&lt;b&gt;e&lt;/b&gt;&lt;/p&gt;\r\n&lt;p&gt;\r\nОператор\r\nперехода к следующей итерации цикла\r\ncontinue\r\nпропускает все операторы, оставшиеся\r\nдо конца тела цикла, и передает управление\r\nна начало следующей итерации (повторение\r\nтела цикла).&lt;/p&gt;\r\n&lt;p&gt;\r\nПример:&lt;/p&gt;\r\n&lt;code&gt;\r\nstatic void Main()\r\n\r\n{\r\n\r\nConsole.WriteLine(&quot;n=&quot;);\r\n\r\nint n = int.Parse(Console.ReadLine());\r\n\r\nfor (int i = 1; i &lt;= n; i++)\r\n\r\n{\r\n\r\nif (i % 2 == 0) continue;\r\n\r\nConsole.Write(&quot; &quot; + i);\r\n\r\n}\r\n\r\n}\r\n&lt;/code&gt;\r\n&lt;h1&gt;Вопросы\r\nдля самоконтроля&lt;/h1&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;Из\r\n	каких элементов состоят циклические\r\n	операторы?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Что\r\n	необходимо для выполнения в цикле более\r\n	одного оператора?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	чем основное отличие операторов цикла\r\n	с предусловием и постусловием?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Для\r\n	чего используется оператор continue?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Для\r\n	чего используется оператор break? goto?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Когда\r\n	целесообразно использовать оператор\r\n	цикла for?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Как\r\n	привести цикл while к циклу for и наоборот?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Какие\r\n	операторы цикла существуют в языке С#?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Что\r\n	представляет собой «тело цикла»?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Что\r\n	такое «итерация»?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Что\r\n	такое «счетчик цикла»?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Верно\r\n	ли, что истинность выражения в цикле с\r\n	предусловием является условием\r\n	продолжения цикла?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Сколько\r\n	раз выполнится оператор в теле цикла\r\n	while,\r\n	если с самого начала значение выражения\r\n	равно false?&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;\r\n&lt;br/&gt;\r\n&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;h1&gt;ПРАКТИЧЕСКАЯ\r\nЧАСТЬ&lt;/h1&gt;\r\n&lt;p&gt;\r\n&lt;b&gt;Задание\r\n№1.&lt;/b&gt; Вывести на экран\r\n(задачу решите тремя способами - используя\r\nоператоры цикла while,\r\ndo while и for):&lt;/p&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;целые\r\n	числа 1, 3, 5, …, 101 в строчку через пробел;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;целые\r\n	числа 10, 12, 14, …, 80 в обратном порядке в\r\n	столбик;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;таблицу\r\n	соответствия между весом в фунтах и\r\n	весом в килограммах для значений 1, 2,\r\n	3, …, 100 фунтов (1 фунтов = 453г);&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;таблицу\r\n	перевода 5, 10, 15, …, 500 долларов США в\r\n	рубли по текущему курсу (значение курса\r\n	вводится с клавиатуры);&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;таблицу\r\n	стоимости для 10, 20, 30,…, 200 штук товара,\r\n	при условии, что одна штука товара\r\n	стоит х\r\n	руб (значение х\r\n	водится с клавиатуры);&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;таблицу\r\n	перевода расстояний в дюймах в сантиметры\r\n	для значений 2, 4, 6, …, 24 дюймов (1 дюйм =\r\n	25.4 мм);&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;кубы\r\n	всех целых чисел из диапазона от А до\r\n	В (A≤B)\r\n	в обратном порядке;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;все\r\n	целые числа из диапазона от А до В\r\n	(A≤B),\r\n	оканчивающиеся на цифру Х;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;все\r\n	целые числа из диапазона от А до В\r\n	(A≤B),\r\n	оканчивающиеся на цифру Х или У;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;все\r\n	целые числа из диапазона от А до В\r\n	(A≤B),\r\n	оканчивающиеся на любую четную цифру;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;только\r\n	положительные целые числа из диапазона\r\n	от А до В (A≤B);&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;все\r\n	целые четные числа из диапазона от А\r\n	до В (A≤B),\r\n	оканчивающиеся на цифру Х или У в\r\n	обратном порядке;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;все\r\n	целые числа из диапазона от А до В,\r\n	кратные трем (A≤B);&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;все\r\n	трехзначные числа, в записи которых\r\n	две цифры одинаковые;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;все\r\n	четные числа из диапазона от А до В,\r\n	кратные пяти (A≤B);&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;\r\n&lt;b&gt;Задание\r\n№2. &lt;/b&gt;Решите задачу:&lt;/p&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;Найти\r\n	среднее арифметическое всех целых\r\n	чисел от 1 до 1000.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Найти\r\n	среднее арифметическое всех целых\r\n	чисел от 100 до b\r\n	(значение b\r\n	вводится с клавиатуры; b≥100);&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Найти\r\n	среднее арифметическое всех целых\r\n	чисел от а\r\n	до 200 (значение а\r\n	вводится с клавиатуры; a≤200);&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Найти\r\n	среднее арифметическое всех целых\r\n	чисел от а\r\n	до b\r\n	(значения а\r\n	и b\r\n	вводятся с клавиатуры; b≥a);&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Найти\r\n	сумму квадратов всех целых чисел от а\r\n	до 50 (значение а\r\n	вводится с клавиатуры; 0≤a≤100);&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Найти\r\n	сумму квадратов всех целых чисел от 1\r\n	до n\r\n	(значение n\r\n	вводится с клавиатуры; 0≤n≤100);&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Найти\r\n	сумму квадратов всех целых чисел от а\r\n	до b\r\n	(значения а\r\n	и b\r\n	вводятся с клавиатуры; b≥a);&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Дано\r\n	натуральное число n.\r\n	Напечатать разложение этого числа на\r\n	простые множители. Реализовать вариант\r\n	каждый простой множитель должен быть\r\n	напечатан один раз;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Дано\r\n	натуральное число n.\r\n	Напечатать разложение этого числа на\r\n	простые множители. Реализовать вариант\r\n	каждый простой множитель должен быть\r\n	напечатан столько раз сколько раз он\r\n	входит в разложение.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Дано\r\n	натуральное число n.\r\n	Получить все простые делители этого\r\n	числа.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Дано\r\n	натуральное число n.\r\n	Получить все натуральные числа, меньшие\r\n	n и\r\n	взаимно простые с ним (два натуральных\r\n	числа называются взаимно простыми,\r\n	если их наибольший общий делитель равен\r\n	1).&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Даны\r\n	целые числа n\r\n	и m.\r\n	Получить все натуральные числа, меньшие\r\n	n и\r\n	взаимно простые с р.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Даны\r\n	целые числа n\r\n	и m.\r\n	Получить все делители числа m,\r\n	взаимно простые с р.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Составить\r\n	программу для графического отображения\r\n	делимости чисел от 1 до n\r\n	(значение n\r\n	вводится с клавиатуры). В каждой строке\r\n	надо напечатать очередное число и\r\n	столько символов «+», сколько делителей\r\n	у этого числа. Например, если п=4,\r\n	то на экране должно быть напечатано:&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;code&gt;\r\n1+\r\n\r\n2++\r\n\r\n3++\r\n\r\n4+++\r\n&lt;/code&gt;\r\n&lt;b&gt;Задание\r\n№4&lt;/b&gt;. Дано натуральное\r\nчисло. Определить:&lt;/p&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;количество\r\n	цифр в нем;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;среднее\r\n	арифметическое его цифр;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;сколько\r\n	раз в нем встречается последняя цифра;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;количество\r\n	четных цифр в нем. Составное условие и\r\n	более одного неполного условного\r\n	оператора не использовать;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;сумму\r\n	его цифр, больших пяти;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;произведение\r\n	его цифр, больших семи;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;сколько\r\n	раз в нем встречаются цифры 0 и 5 (всего);&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;сколько\r\n	раз в нем встречается цифра а;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;количество\r\n	его цифр кратных z (значение z вводится\r\n	с клавиатуры; z = 2, 3, 4);&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;сумму\r\n	его цифр, больших а\r\n	(значение а\r\n	вводится с клавиатуры; \r\n	\r\n);&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;сколько\r\n	раз в нем встречаются цифры х\r\n	и у;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;его\r\n	минимальную цифру;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;его\r\n	максимальную цифру;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;на\r\n	сколько его максимальная цифра превышает\r\n	минимальную;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;сумму\r\n	его максимальной и минимальной цифр;&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;\r\n&lt;b&gt;Задание\r\n№5&lt;/b&gt;. Решите задачу:&lt;/p&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;Гражданин\r\n	1 марта открыл счет в банке, вложив 1000\r\n	руб. Через каждый месяц размер вклада\r\n	увеличивается на 2% от имеющейся суммы.\r\n	Определить за какой месяц величина\r\n	ежемесячного увеличения вклада превысит\r\n	30 руб.;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Гражданин\r\n	1 марта открыл счет в банке, вложив 1000\r\n	руб. Через каждый месяц размер вклада\r\n	увеличивается на 2% от имеющейся суммы.\r\n	Определить, через сколько месяцев\r\n	размер вклада повысит 1200 руб.;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Начав\r\n	тренировки, лыжник в первый день пробежал\r\n	10 км. Каждый следующий день он увеличивал\r\n	пробeг на 10% от пробега предыдущего дня.\r\n	Определить на какой день он пробежит\r\n	больше 20 км;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Начав\r\n	тренировки, лыжник в первый день пробежал\r\n	10 км. Каждый следующий день он увеличивал\r\n	пробeг на 10% от пробега предыдущего дня.\r\n	Определить в какой день суммарный\r\n	пробег за все дни превысит 100 км.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	некотором году (назовем его условно\r\n	первым) на участке в 100 гектар средняя\r\n	урожайность ячменя состарила 20 центнеров\r\n	с гектара. После этого каждый год площадь\r\n	участка увеличивалась на 5%, а средняя\r\n	урожайность на 2%. Определить в каком\r\n	году урожайность превысит 22 центнера\r\n	с гектара;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	некотором году (назовем его условно\r\n	первым) на участке в 100 гектар средняя\r\n	урожайность ячменя состарила 20 центнеров\r\n	с гектара. После этого каждый год площадь\r\n	участка увеличивалась на 5%, а средняя\r\n	урожайность на 2%. Определить в каком\r\n	году площадь участка стянет больше 120\r\n	гектар;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	некотором году (назовем его условно\r\n	первым) на участке в 100 гектар средняя\r\n	урожайность ячменя состарила 20 центнеров\r\n	с гектара. После этого каждый год площадь\r\n	участка увеличивалась на 5%, а средняя\r\n	урожайность на 2%. Определить в каком\r\n	году общий урожай, собранный за вес\r\n	время, начиная с первого года, превысит\r\n	800 центнеров.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	некоторой стране используются денежные\r\n	купюры достоинством в 1, 2, 4, 8, 16, 32 и 64.\r\n	Дано натуральное число n.\r\n	Как наименьшим\r\n	количеством таких денежных купюр можно\r\n	выплатить сумму n\r\n	(указать количество каждой из используемых\r\n	для выплат купюр)? Предполагается, что\r\n	имеется достаточно большое количество\r\n	купюр всех достоинств.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Известны\r\n	данные о стоимости каждого товара из\r\n	группы. Найти общую стоимость тех\r\n	товаров, которые стоят дороже 1000 рублей\r\n	(количество таких товаров неизвестно).&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Известны\r\n	данные о количестве страниц в каждой\r\n	из нескольких газет и в каждом из\r\n	нескольких журналов. Число страниц в\r\n	газете не более 16. Найти общее число\r\n	страниц во всех журналах (количество\r\n	журналов неизвестно, но известно, что\r\n	объем любого журнала превышает объем\r\n	любой газеты).&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Известны\r\n	данные о количестве осадков, выпавших\r\n	за каждый день месяца. Определить общее\r\n	количество осадков, выпавших второго,\r\n	четвертого и т.д. числа этого месяца.\r\n	Оператор цикла с шагом, отличным от 1 и\r\n	-1, не использовать.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Написать\r\n	программу, ведущую учет очков, набранных\r\n	каждой командой при игре в баскетбол.\r\n	Количество очков, полученных командами\r\n	в ходе игры, может быть равно 1, 2 или 3.\r\n	После окончания игры выдать итоговое\r\n	сообщение и указать номер\r\n	команды-победительницы. Окончание игры\r\n	условно моделировать вводом количества\r\n	очков, равного нулю.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Известен\r\n	год рождения n\r\n	человек из группы. Определить число\r\n	людей, родившихся до 1985 года, и число\r\n	людей родившихся после 1990 года.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Для\r\n	каждой команды-участницы чемпионата\r\n	по футболу известно ее количество\r\n	выигрышей и количество проигрышей.\r\n	Определить, сколько команд имеют больше\r\n	выигрышей, чем проигрышей?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Известны\r\n	максимальные скорости каждой из 20 марок\r\n	легковых автомобилей. Определить, какую\r\n	скорость имеет самый быстрый автомобиль.&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;h1&gt;ДОМАШНЕЕ\r\nЗАДАНИЕ&lt;/h1&gt;\r\n&lt;p&gt;Т.\r\nА. Павловская “ С#. Программирование на\r\nязыке высокого уровня: Учебник для\r\nвузов.” СПб.: Питер, 2014. — 432 с.:, с. 69-99&lt;/p&gt;', 2),
(4, 4, 4, 'Разработка программ с использованием методов.', 'Формировать практические навыки и умения в написания программ с использованием функций и процедур.', 'ПК, ОС Windows, среда разработки Microsoft Visual Studio .NET.', '&lt;h1&gt;МЕТОДИЧЕСКИЕ УКАЗАНИЯ&lt;/h1&gt;\r\n&lt;p&gt;&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;p&gt;Процедуры\r\nи функции связываются с классом, они\r\nобеспечивают функциональность данных\r\nкласса и называются методами класса.\r\nГлавную роль в программной системе\r\nиграют данные, а функции лишь служат\r\nданным. \r\n&lt;/p&gt;\r\n&lt;p&gt;Функция\r\nотличается от процедуры двумя\r\nособенностями:&lt;/p&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;Она\r\n	всегда вычисляет некоторое значение,\r\n	возвращаемое в качестве результата\r\n	функции;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;И\r\n	вызывается в выражениях.&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;Процедура\r\nC# имеет свои особенности:&lt;/p&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;Она\r\n	возвращает формальный результат&lt;b&gt;\r\n	&lt;/b&gt;&lt;b&gt;void,&lt;/b&gt;\r\n	указывающий на отсутствие\r\n	результата;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Вызов\r\n	процедуры является оператором языка;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;И\r\n	она имеет входные и выходные аргументы,\r\n	причем выходных аргументов - ее\r\n	результатов - может быть достаточно\r\n	много.&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;Рассмотрим\r\nсинтаксис заголовка метода:\r\n&lt;/p&gt;\r\n&lt;p&gt;\r\n&lt;b&gt;[атрибуты][модификаторы]{void|\r\nтип_результата_функции} имя_метода\r\n([список_формальных_аргументов])&lt;/b&gt;&lt;/p&gt;\r\n&lt;p&gt;синтаксис\r\nобъявления формального аргумента:&lt;/p&gt;\r\n&lt;p&gt;\r\n&lt;b&gt;[&lt;/b&gt;\r\n&lt;b&gt;ref&lt;/b&gt;\r\n&lt;b&gt;|&lt;/b&gt;\r\n&lt;b&gt;out&lt;/b&gt;\r\n&lt;b&gt;|&lt;/b&gt;\r\n&lt;b&gt;params&lt;/b&gt;\r\n&lt;b&gt;]\r\nтип_аргумента имя_аргумента.&lt;/b&gt;&lt;/p&gt;\r\n&lt;p&gt;Несмотря\r\nна фиксированное число формальных\r\nаргументов, есть возможность при вызове\r\nметода передавать ему произвольное\r\nчисло фактических аргументов. Для\r\nреализации этой возможности в списке\r\nформальных аргументов необходимо задать\r\nключевое слово&lt;b&gt;\r\n&lt;/b&gt;&lt;b&gt;params&lt;/b&gt;&lt;b&gt;.&lt;/b&gt;\r\nОно\r\nзадается один раз и указывается только\r\nдля последнего аргумента списка,\r\nобъявляемого как массив произвольного\r\nтипа. При вызове метода этому формальному\r\nаргументу соответствует произвольное\r\nчисло фактических аргументов.&lt;/p&gt;\r\n&lt;p&gt;Все\r\nаргументы метода разделяются на три\r\nгруппы: входные, выходные и обновляемые.\r\nАргументы первой группы передают\r\nинформацию методу, их значения в теле\r\nметода только читаются. Аргументы второй\r\nгруппы представляют собой результаты\r\nметода, они получают значения в ходе\r\nработы метода. Аргументы третьей группы\r\nвыполняют обе функции. Их значения\r\nиспользуются в ходе вычислений и\r\nобновляются в результате работы метода.\r\nВыходные аргументы всегда должны\r\nсопровождаться ключевым словом&lt;b&gt;\r\n&lt;/b&gt;&lt;b&gt;out&lt;/b&gt;&lt;b&gt;,&lt;/b&gt;\r\nобновляемые\r\n-&lt;b&gt;\r\n&lt;/b&gt;&lt;b&gt;ref&lt;/b&gt;&lt;b&gt;.&lt;/b&gt;\r\nЧто\r\nже касается входных аргументов, то, как\r\nправило, они задаются без ключевого\r\nслова, хотя иногда их полезно объявлять\r\nс параметром&lt;b&gt;\r\n&lt;/b&gt;&lt;b&gt;ref&lt;/b&gt;&lt;b&gt;.&lt;/b&gt;\r\nОтметим,\r\nесли аргумент объявлен как выходной с\r\nключевым словом&lt;b&gt;\r\n&lt;/b&gt;&lt;b&gt;out&lt;/b&gt;&lt;b&gt;,&lt;/b&gt;\r\nто\r\nв теле метода обязательно должен\r\nприсутствовать оператор присваивания,\r\nзадающий значение этому аргументу. В\r\nпротивном случае возникает ошибка еще\r\nна этапе компиляции.&lt;/p&gt;\r\n&lt;p&gt;\r\n&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;h1&gt;УСЛОВИЯ\r\nЗАДАНИЙ&lt;/h1&gt;\r\n&lt;p&gt;&lt;b&gt;Упражнение 1. &lt;/b&gt;Перегрузка\r\nметодов.&lt;/p&gt;\r\n&lt;img src=&quot;https://sun9-84.userapi.com/impf/oZ4v1qTpusOGPW74OE6yWFfILbNGS7RU6JnBpw/lRwU-y0FkjY.jpg?size=1048x352&amp;quality=96&amp;sign=738710173a57fbd8c590ded2887f2f8f&amp;type=album&quot; alt=&quot;image&quot;&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;Протестируйте\r\n	программу, вызывая метод Perim\r\n	с разными параметрами.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Измените\r\n	программу добавив вариант перегрузки\r\n	метода Perim чтобы\r\n	вычислялся периметр квадрата по стороне:\r\n	4*a \r\n	&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Создайте\r\n	метод, который вычисляет площадь\r\n	квадрата, трапеции, прямоугольника.&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;&lt;b&gt;Упражнение\r\n2.&lt;/b&gt; Использование параметров в\r\nметодах, возвращающих значения \r\n&lt;/p&gt;\r\n&lt;p&gt;Создайте метод, который\r\nбудет принимать два целочисленных\r\nпараметра и возвращать один из них.\r\nМетод должен использовать два передаваемых\r\nпо значению параметра a и b типа int (double)\r\nи возвращать значение типа int (double):\r\n \r\n&lt;/p&gt;\r\n&lt;p&gt;Пример функции\r\nвычисления суммы двух чисел.&lt;/p&gt;\r\n&lt;img src=&quot;https://sun9-78.userapi.com/impf/CHg97eyB06xKRw112Q2Wfh8C3FatIhSJEfxxdA/DJxYRAbTjdI.jpg?size=399x382&amp;quality=96&amp;sign=fa468cf8bcf2546051733052beb7cc16&amp;type=album&quot; alt=&quot;image&quot;&gt;\r\n&lt;p&gt;&lt;b&gt;Варианты\r\nзаданий.&lt;/b&gt;&lt;/p&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;Реализовать\r\n	метод возведения в куб суммы двух целых\r\n	чисел.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Реализовать\r\n	метод возведения в куб разности двух\r\n	целых чисел.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Реализовать\r\n	метод возведения в куб произведения\r\n	двух целых чисел.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Реализовать\r\n	метод возведения в куб частного двух\r\n	целых чисел.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Реализовать\r\n	метод возведения в куб суммы двух\r\n	вещественных чисел.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Реализовать\r\n	метод возведения в куб разности двух\r\n	вещественных чисел.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Реализовать\r\n	метод возведения в куб произведения\r\n	двух вещественных чисел.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Реализовать\r\n	метод возведения в куб частного двух\r\n	вещественных чисел.&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;p&gt;&lt;b&gt;Упражнение 3. Передача\r\nзначений по ссылке.&lt;/b&gt;&lt;/p&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;Объявите\r\n	две целочисленные переменные x и y.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Напишите\r\n	код, выводящий на консоль (задание по\r\n	вариантам) при этом используйте при\r\n	инициализации параметров ключевое\r\n	слово ref;\r\n	(пример приведен ниже, рассмотреть два\r\n	варианта с ключевым словом и без).&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;img src=&quot;https://sun9-70.userapi.com/impf/S1QMFxDYoBARxI0mVUWZ83Jjy7b4cejG624tcg/duZ65slVnz8.jpg?size=441x314&amp;quality=96&amp;sign=9240599c37046358cbf9c3a4364e7496&amp;type=album&quot; alt=&quot;image&quot;&gt;\r\n&lt;ol start=&quot;3&quot;&gt;\r\n	&lt;li&gt;&lt;p&gt;Запустите\r\n	и протестируйте программу. \r\n	&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;&lt;b&gt;Задание по вариантам.&lt;/b&gt;&lt;/p&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;Реализовать\r\n	метод возведения в квадрат суммы двух\r\n	целых чисел. \r\n	&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Реализовать\r\n	метод возведения в квадрат разности\r\n	двух целых чисел.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Реализовать\r\n	метод возведения в квадрат произведения\r\n	двух целых чисел.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Реализовать\r\n	метод возведения в квадрат частного\r\n	двух целых чисел.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Реализовать\r\n	метод возведения в квадрат суммы двух\r\n	вещественных чисел.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Реализовать\r\n	метод возведения в квадрат разности\r\n	двух вещественных чисел.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Реализовать\r\n	метод возведения в квадрат произведения\r\n	двух вещественных чисел.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Реализовать\r\n	метод возведения в квадрат частного\r\n	двух вещественных чисел.&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;p&gt;&lt;b&gt;Упражнение 4. Передача\r\nзначений по ссылке. Сопроводите результат\r\nключевым словом o&lt;/b&gt;&lt;b&gt;ut&lt;/b&gt;&lt;b&gt;.&lt;/b&gt;&lt;/p&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;Наберите\r\n	код и проанализируйте результат.&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;img src=&quot;https://sun9-67.userapi.com/impf/fZuFAb-5R5TnZSvvyab2WfmY7rejQhAf4razyA/4kR-SPk54Y8.jpg?size=454x275&amp;quality=96&amp;sign=97823e8aaac689c9d1743ebde07a629e&amp;type=album&quot; alt=&quot;image&quot;&gt;\r\n&lt;p&gt;Если параметр объявлен\r\nкак out\r\nон обязательно в функции должен измениться\r\nвнутри метода, иначе произойдет ошибка.&lt;/p&gt;\r\n&lt;ol start=&quot;2&quot;&gt;\r\n	&lt;li&gt;&lt;p&gt;Реализовать\r\n	метод: сравните два числа, меньшее из\r\n	них возведите в квадрат и найдите сумму\r\n	полученного числа и второго, числа\r\n	вводить с клавиатуры. \r\n	&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Реализовать\r\n	метод: сравните два числа, большее из\r\n	них уменьшите в 3 раза и найдите разность\r\n	полученного числа и второго, числа\r\n	вводить с клавиатуры.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Реализовать\r\n	метод: сравните два числа, большее из\r\n	них увеличьте на меньшее и найдите\r\n	произведение полученного числа и\r\n	второго, числа вводить с клавиатуры.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Реализовать\r\n	метод: сравните два числа, большее из\r\n	них возведите в квадрат и найдите\r\n	частное полученного числа и второго,\r\n	числа вводить с клавиатуры.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Реализовать\r\n	метод: сравните два числа, меньшее из\r\n	них увеличьте на большее и найдите\r\n	сумму полученного числа и второго,\r\n	числа вводить с клавиатуры.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Реализовать\r\n	метод: сравните два числа, большее из\r\n	них увеличьте в 5 раз и найдите\r\n	произведение полученного числа и\r\n	второго, числа вводить с клавиатуры.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Реализовать\r\n	метод: сравните два числа, меньшее из\r\n	них увеличьте на меньшее и найдите\r\n	частное полученного числа и второго,\r\n	числа вводить с клавиатуры.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Реализовать\r\n	метод: вычисления частного двух\r\n	вещественных чисел.&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;h1&gt;КОНТРОЛЬНЫЕ\r\nВОПРОСЫ&lt;/h1&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;Дайте\r\n	определение функции?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Дайте\r\n	определение процедуре?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Назовите\r\n	отличия функции от процедуры?&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;h1&gt;ДОМАЩНЕЕ ЗАДАНИЕ&lt;/h1&gt;\r\n&lt;p&gt;«С#\r\nПрограммирование на языке высокого\r\nуровня» – Павловская Т. А., c.\r\n106-114.&lt;/p&gt;', 2),
(5, 5, 5, 'Разработка классов, создание объектов и использование их в программах.', 'Формировать практические навыки и умения разработки классов на языке C# и использования их в программах.', 'ПК, среда разработки Microsoft Visual Studio .NET. ', '&lt;h1&gt;МЕТОДИЧЕСКИЕ УКАЗАНИЯ&lt;/h1&gt;\r\n&lt;p&gt;&lt;b&gt;Классы&lt;/b&gt;&lt;b&gt;\r\n&lt;/b&gt;являются\r\nрасширением структурного типа. Синтаксис\r\nописания класса:&lt;/p&gt;\r\n&lt;p&gt;[атрибуты][модификаторы]class\r\nимя_класса [:список_родителей] {тело_класса}&lt;/p&gt;\r\n&lt;p&gt;Модификаторы\r\nдоступа к членам классов:&lt;/p&gt;\r\n&lt;p&gt;public\r\n– член доступен вне определения класса\r\nи иерархии производных классов.&lt;/p&gt;\r\n&lt;p&gt;protected\r\n– член не видим за пределами класса, к\r\nнему могут обращаться только производные\r\nклассы.&lt;/p&gt;\r\n&lt;p&gt;private\r\n– член не доступен за пределами области\r\nвидимости определяющего его класса.&lt;/p&gt;\r\n&lt;p&gt;internal\r\n– член видим только в пределах текущей\r\nединицы компиляции.&lt;/p&gt;\r\n&lt;p&gt;Обычно\r\nкласс имеет модификатор доступа public,\r\nявляющийся значением по умолчанию.\r\nМодификаторы private и protected используются\r\nдля вложенных классов.&lt;/p&gt;\r\n&lt;p&gt;В\r\nтеле класса могут быть объявлены:\r\nконстанты, поля, конструкторы и\r\nдеструкторы, методы, события, делегаты,\r\nвложенные классы (структуры, интерфейсы,\r\nперечисления).&lt;/p&gt;\r\n&lt;p&gt;&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;img src=&quot;https://sun9-80.userapi.com/impf/Vg9x-NheHyqf5pHNyyY6Jv8_nNERFloSVjNTxQ/FJYWOweKrcU.jpg?size=974x603&amp;quality=96&amp;sign=2bc11d2de1137626f69923e0ce84480a&amp;type=album&quot; alt=&quot;image&quot;&gt;\r\n&lt;p&gt;&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;p&gt;&lt;b&gt;Упражнение 1.&lt;/b&gt;\r\nРеализация класса Triangle.&lt;/p&gt;\r\n&lt;p&gt;В этом упражнении\r\nтребуется создать класс Triangle, разработав\r\nследующие элементы класса: \r\n&lt;/p&gt;\r\n&lt;ul&gt;\r\n	&lt;li&gt;&lt;p&gt;Поля:\r\n	стороны треугольника.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Конструктор,\r\n	позволяющий создать экземпляр класса\r\n	с заданными длинами сторон. \r\n	&lt;/p&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Методы, позволяющие: \r\n&lt;/p&gt;\r\n&lt;ul&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	вывести длины\r\n	сторон треугольника на экран; \r\n	&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	рассчитать периметр\r\n	треугольника; \r\n	&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	рассчитать площадь\r\n	треугольника. \r\n	&lt;/p&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Реализовать проверку,\r\nпозволяющую установить, существует ли\r\nтреугольник с данными длинами сторон.&lt;/p&gt;\r\n&lt;p&gt;\r\n&lt;b&gt;Задание&lt;/b&gt;&lt;b&gt;\r\nпо вариантам.&lt;/b&gt;&lt;/p&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Реализовать\r\n	класс согласно условия по варианту. \r\n	&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Для\r\n	каждого класса написать конструктор\r\n	(по умолчанию и с параметром), \r\n	&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Добавить\r\n	метод вывода данных на экран (в формате\r\n	поле = значение).&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;\r\nРабота\r\nс классом в методе main():&lt;/p&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Создать\r\n	3 экземпляра класса. \r\n	&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Один\r\n	объект создается с помощью конструктора\r\n	по умолчанию. Все остальные с помощью\r\n	конструктора с параметром. \r\n	&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Вывести\r\n	данные на экран.&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;Варианты:&lt;/p&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	СЛУЖАЩИЙ:\r\n	имя, возраст, рабочий стаж, должности.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	ИЗДЕЛИЕ:\r\n	название, шифр, количество, комплектация.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;ПЕЧАТНОЕ\r\n	ИЗДАНИЕ: название, ФИО автора, стоимость,\r\n	оглавление.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	ЭКЗАМЕН:\r\n	ФИО студента, дата, оценка, перечень\r\n	вопросов.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	ТОВАР:\r\n	название, артикул, стоимость, даты\r\n	(изготовление, срок реализации)&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	АВТОМОБИЛЬ:\r\n	марка, мощность, стоимость, даты ремонта.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	СТРАНА:\r\n	название, форма правления, площадь,\r\n	список областей.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	КНИГА:\r\n	Название, жанр, количество страниц,\r\n	список авторов.&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;h1&gt;КОНТРОЛЬНЫЕ ВОПРОСЫ&lt;/h1&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Дайте\r\n	определение понятию класс. Назовите\r\n	назначение классов.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Перечислите\r\n	основные отличия класса\r\n	от структуры.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Назовите,\r\n	какие есть модификаторы\r\n	доступа к полям и методам класса.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Дайте\r\n	определение экземпляра\r\n	класса. Приведите пример его создания\r\n	в C#.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Назовите,\r\n	для чего в классе\r\n	определяется конструктор? Сколько\r\n	может быть конструкторов в классе?\r\n	Когда вызывается конструктор?&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;h1&gt;ДОМАШНЕЕ ЗАДАНИЕ&lt;/h1&gt;\r\n&lt;p&gt;Т. А.\r\nПавловская. С#. Программирование на\r\nязыке высокого уровня: Учебник для\r\nвузов. СПб.: Питер, 2014. – с. 100-106, с. 114-125&lt;/p&gt;\r\n&lt;p&gt;\r\n&lt;br/&gt;\r\n&lt;br/&gt;\r\n&lt;/p&gt;', 2),
(6, 6, 6, 'Разработка классов, создание объектов и использование их в программах.', 'Формировать практические навыки и умения разработки классов на языке C# и использования их в программах.', 'ПК, среда разработки Microsoft Visual Studio .NET. ', '&lt;p&gt;&lt;img src=&quot;https://sun9-40.userapi.com/impf/W_m7IE5Tp0N29Zg2m2o3LsZLwMinp6uXcwo-AA/408-r3J6fl0.jpg?size=1048x433&amp;quality=96&amp;sign=1e6e5ca9860575130f938c6f0000746d&amp;type=album&quot; alt=&quot;photo&quot;/&gt;\r\n&lt;/p&gt;\r\n&lt;p&gt;&lt;img src=&quot;https://sun9-22.userapi.com/impf/upRVUmkADHyZ9T6PJqa6KdNThDIlVd1Yu0n6Jw/kq9IXaqvv-8.jpg?size=1048x424&amp;quality=96&amp;sign=9dfd29c25284529a04d174360040660f&amp;type=album&quot; alt=&quot;photo&quot;/&gt;\r\n&lt;/p&gt;\r\n&lt;p&gt;&lt;img src=&quot;https://sun9-42.userapi.com/impf/fMGluIddX6XV4dIqI8JtgbsvJQ1TvfgBvxZ5UQ/t2Oim_qyaO0.jpg?size=1048x530&amp;quality=96&amp;sign=c7590d9959334b982940b765ea45433c&amp;type=album&quot; alt=&quot;photo&quot;/&gt;\r\n&lt;/p&gt;\r\n&lt;p&gt;&lt;b&gt;Задание. Построить\r\nиерархию классов в соответствии с\r\nвариантом задания.&lt;/b&gt;&lt;/p&gt;\r\n&lt;p&gt;&lt;b&gt;Определить иерархию\r\nнаследования для индивидуального\r\nзадания, для каждого класса описать не\r\nменее 1 закрытого поля, определить как\r\nминимум 2 конструктора, методы доступа\r\nк полям (свойства), метод вывода информации\r\nоб объекте. В основной функции создать\r\nмассивы объектов каждого класса, ввести\r\nнеобходимую информацию и вывести ее на\r\nэкран.&lt;/b&gt;&lt;/p&gt;\r\n&lt;p&gt;&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;ol&gt;\r\n	&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;Рабочий,\r\n	кадры, инженер, администрация \r\n	&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Деталь,\r\n	механизм, изделие, узел \r\n	&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Методичка,\r\n	книга, печатное издание, учебник \r\n	&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Организация,\r\n	страховая компания, нефтегазовая\r\n	компания, завод&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Студент,\r\n	преподаватель, персона, заведующий\r\n	кафедрой \r\n	&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Служащий,\r\n	персона, рабочий, инженер \r\n	&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Тест,\r\n	экзамен, выпускной экзамен, испытание\r\n	\r\n	&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Место,\r\n	область, город, мегаполис \r\n	&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Игрушка,\r\n	продукт, товар, молочный продукт \r\n	&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Квитанция,\r\n	накладная, документ, счет \r\n	&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Автомобиль,\r\n	поезд, транспортное средство, экспресс\r\n	\r\n	&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Млекопитающее,\r\n	парнокопытное, птица, животное \r\n	&lt;/p&gt;\r\n	&lt;/ol&gt;\r\n&lt;/ol&gt;\r\n&lt;h1&gt;КОНТРОЛЬНЫЕ ВОПРОСЫ&lt;/h1&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Дайте\r\n	определение понятию класс. Назовите\r\n	назначение классов.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Перечислите\r\n	основные отличия класса\r\n	от структуры.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Назовите,\r\n	какие есть модификаторы\r\n	доступа к полям и методам класса.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Дайте\r\n	определение экземпляра\r\n	класса. Приведите пример его создания\r\n	в C#.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Назовите,\r\n	для чего в классе\r\n	определяется конструктор? Сколько\r\n	может быть конструкторов в классе?\r\n	Когда вызывается конструктор?&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;h1&gt;ДОМАШНЕЕ ЗАДАНИЕ&lt;/h1&gt;\r\n&lt;p&gt;Т. А.\r\nПавловская. С#. Программирование на\r\nязыке высокого уровня: Учебник для\r\nвузов. СПб.: Питер, 2014. – с. 100-106, с. 114-125&lt;/p&gt;\r\n&lt;p&gt;&lt;br/&gt;\r\n&lt;/p&gt;', 2);
INSERT INTO `labs` (`IDLab`, `StartNumber`, `EndNumber`, `Theme`, `Goal`, `Equipment`, `Content`, `IDStatus`) VALUES
(7, 7, 7, 'Разработка программ с использованием массивов.', 'Формировать практические навыки и умения в написании программ, реализующих алгоритмы ветвления и цикла.', 'ПК, среда разработки Microsoft Visual Studio .NET. ', '&lt;h1&gt;Теоретическая часть&lt;/h1&gt;\r\n&lt;p&gt;&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;p&gt;\r\nПример1.\r\nФормирование и вывод одномерного\r\nмассива:&lt;/p&gt;\r\n&lt;p&gt;&lt;img src=&quot;https://sun9-80.userapi.com/impf/eB3q1R0ObcEYf2mYNuYI1_0ZbwCao89dSHZ53g/xHDJheJFr74.jpg?size=974x432&amp;quality=96&amp;sign=7f98a21e98a5c60461accdce5ec0ccdd&amp;type=album&quot; alt=&quot;photo&quot;/&gt;\r\n&lt;/p&gt;\r\n&lt;p&gt;&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;p&gt;Массив как параметр&lt;/p&gt;\r\n&lt;p&gt;\r\nТак\r\nкак имя массива фактически является\r\nссылкой, то он передается в метод по\r\nссылке и, следовательно, все изменения\r\nэлементов массива, являющегося формальным\r\nпараметром, отразятся на элементах\r\nсоответствующего массива, являющимся\r\nфактическим параметром. \r\n&lt;/p&gt;\r\n&lt;p&gt;\r\nПример:\r\nпередача массива как параметра:&lt;/p&gt;\r\n&lt;p&gt;&lt;img src=&quot;https://sun9-43.userapi.com/impf/t5kstzk71lz-KSAfVoH0-FCz6xBeoFnel8vu5w/TVoOFzXKXKo.jpg?size=974x534&amp;quality=96&amp;sign=03c343dc100898e9c4fafc732ffffdb4&amp;type=album&quot; alt=&quot;photo&quot;/&gt;\r\n&lt;/p&gt;\r\n&lt;p&gt;Массив как объект&lt;/p&gt;\r\n&lt;p&gt;\r\nТак\r\nкак массивы в С# реализованы как объекты\r\nи они реализованы на основе базового\r\nкласса Array,\r\nопределенного в пространстве имен\r\nSystem.\r\nДанный класс содержит различные свойства\r\nи методы. Например, свойство Length\r\nпозволяет\r\nопределять количество элементов в\r\nмассиве. Преобразуем предыдущий пример:&lt;/p&gt;\r\n&lt;p&gt;\r\n&lt;img src=&quot;https://sun9-32.userapi.com/impf/bOEfc0afWip5oXqa8ihRutu3bH_u_UTcTr58fA/0EiVsqvEB3E.jpg?size=872x605&amp;quality=96&amp;sign=d23cbb8acd34e9ffdf4a9e398a543fe9&amp;type=album&quot; alt=&quot;photo&quot;/&gt;\r\n&lt;/p&gt;\r\n&lt;p&gt;Некоторые\r\nсвойства и методы класса Array:&lt;/p&gt;\r\n&lt;p&gt;&lt;br/&gt;\r\n&lt;/p&gt;\r\n	&lt;table&gt;\r\n	\r\n	\r\n	\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	&lt;b&gt;Элемент&lt;/b&gt;&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	&lt;b&gt;Вид&lt;/b&gt;&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	&lt;b&gt;Описание&lt;/b&gt;&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Length&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Свойство&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Количество\r\n	элементов массива (по всем размерностям)&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	BinarySearch&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Статический\r\n	метод \r\n	&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Двоичный\r\n	поиск в отсортированном массиве&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Clear&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Статический\r\n	метод&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Присваивание\r\n	элементам массива значений по умолчанию&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Copy&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Статический\r\n	метод&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Копирование\r\n	заданного диапазона элементов одного\r\n	массива в другой&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	CopyTo&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	экземплярный\r\n	метод&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Копирование\r\n	всех элементов текущего одномерного\r\n	массива в другой массив&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	GetValue&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	экземплярный\r\n	метод&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Получение\r\n	значения элемента массива&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	IndexOf&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	статический\r\n	метод&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Поиск\r\n	первого вхождения элемента в одномерный\r\n	массив&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	LastIndexOf&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	статический\r\n	метод&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Поиск\r\n	последнего вхождения элемента в\r\n	одномерный массив&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Reverse&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	статический\r\n	метод&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Изменение\r\n	порядка следования элементов на\r\n	обратный&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	SetValue&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	экземплярный\r\n	метод&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Установка\r\n	значения элемента массива&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Sort&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	статический\r\n	метод&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Упорядочивание\r\n	элементов одномерного массива&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;/table&gt;\r\n&lt;p&gt;\r\nВызов\r\nстатических методов происходит через\r\nобращение к имени класса, например,\r\nArray.Sort(myArray).\r\nВ данном случае происходит обращение\r\nк статическому методу Sort\r\nкласса Array\r\nи происходит передача данному методу\r\nв качестве параметра объект myArray\r\n- экземпляр класса Array.&lt;/p&gt;\r\n&lt;p&gt;\r\nОбращение\r\nк свойству или вызов экземплярного\r\nметода производится через обращение к\r\nэкземпляру класса, например, myArray.Length\r\nили myArray.GetValue(i).&lt;/p&gt;\r\n&lt;p&gt;\r\n&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;p&gt;&lt;img src=&quot;https://sun9-65.userapi.com/impf/6gotNM_LOp9g_6ute792OJjYndPSIy73pBQgtQ/0gomK5zH6jQ.jpg?size=974x309&amp;quality=96&amp;sign=4cf8469df625220fb60b4fb49528df95&amp;type=album&quot; alt=&quot;photo&quot;/&gt;\r\n&lt;/p&gt;\r\n&lt;p&gt;&lt;img src=&quot;https://sun9-31.userapi.com/impf/KkDgWh-RjYmK4ypfEXNbrlOTWVNKrviuGjeUqA/Y4lu1FxEUiY.jpg?size=974x184&amp;quality=96&amp;sign=bc4c999914dc618586559ad771c3ea6e&amp;type=album&quot; alt=&quot;photo&quot;/&gt;\r\n&lt;/p&gt;\r\n&lt;p&gt;&lt;b&gt;Вопросы\r\nдля самоконтроля&lt;/b&gt;&lt;/p&gt;\r\n&lt;p&gt;&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Дайте определение массиву.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Почему максимальный номер\r\n	элемента массива на единицу меньше\r\n	размерности массива?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Как задается размерность\r\n	массива?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Что такое «индекс массива»?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Как происходит обращение\r\n	к элементам массива?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Ограниченно\r\n	ли количество измерений массивов в\r\n	языке С#?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Какие\r\n	данные могут выступать в качестве\r\n	индексов и элементов массива?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	чем состоит особенность организации\r\n	цикла при обработке массива?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Какие\r\n	способы задания исходных значений\r\n	элементов массива вам известны?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Как\r\n	осуществляется доступ к каждому элементу\r\n	массива?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Может\r\n	ли индекс быть выражением вещественного\r\n	типа?&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;h1&gt;ПРАКТИЧЕСКАЯ ЧАСТЬ&lt;/h1&gt;\r\n&lt;p&gt;&lt;b&gt;Задание\r\n№1. &lt;/b&gt;Работа с одномерными\r\nмассивами&lt;/p&gt;\r\n&lt;p&gt;\r\nПример:\r\nНайти сумму и количество четных чисел\r\nмассива x&lt;sub&gt;1&lt;/sub&gt;,\r\nx&lt;sub&gt;2&lt;/sub&gt;,\r\n... , x&lt;sub&gt;n&lt;/sub&gt;,\r\nгде n\r\n\r\n30. Проверить правильность работы\r\nпрограммы на тесте при n=3\r\nи элементах массива 2, 5, 4.&lt;/p&gt;\r\n&lt;p&gt;Блок-схема\r\nалгоритма:&lt;/p&gt;\r\n&lt;p&gt;&lt;img src=&quot;https://sun9-14.userapi.com/impf/hZ8VbImlVvEapMfs9vACvfVjLFBPEl6_75DjxQ/EZzkuqQnDh4.jpg?size=308x798&amp;quality=96&amp;sign=43b22b0c83a3a213912576fdd31b52ee&amp;type=album&quot; alt=&quot;photo&quot;/&gt;\r\n&lt;/p&gt;\r\n&lt;p&gt;&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;p&gt;&lt;b&gt;Варианты\r\nзадания №1&lt;/b&gt;&lt;/p&gt;\r\n&lt;p&gt;&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	массиве из 15 целых чисел найти наибольший\r\n	элемент и поменять его местами с первым\r\n	элементом.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Вычислить\r\n	сумму и количество элементов массива\r\n	вещественных чисел.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Вывести\r\n	на экран дисплея порядковые номера\r\n	нечетных элементов массива целых чисел.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Вычислить\r\n	среднее арифметическое массива\r\n	вещественных чисел.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Найти\r\n	минимальный элемент массива и его\r\n	порядковый номер.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	массиве вещественных чисел найти\r\n	количество отрицательных элементов.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Найти\r\n	сумму чисел кратных трем в массиве\r\n	целых чисел.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	массиве вещественных чисел найти\r\n	произведение элементов, стоящих на\r\n	четных позициях.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Найти\r\n	количество отрицательных элементов\r\n	массива А.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Найти\r\n	порядковый номер максимального элемента\r\n	массива вещественных чисел.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Вывести\r\n	на экран дисплея положительные элементы\r\n	массива и найти их количество.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Вывести\r\n	на экран дисплея номера элементов\r\n	массива, удовлетворяющих условию\r\n	0&lt;x&lt;sub&gt;i&lt;/sub&gt;&lt;3,2.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Заменить\r\n	четные элементы в массиве целых чисел\r\n	нулями и вывести новый массив на экран.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Найти\r\n	среднее арифметическое элементов\r\n	массива целых чисел кратных пяти.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	массиве вещественных чисел найти\r\n	минимальный элемент среди отрицательный\r\n	элементов.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Найти\r\n	сумму двузначных элементов в массиве\r\n	целых чисел.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Найти\r\n	количество и сумму положительных\r\n	элементов в массиве вещественных чисел,\r\n	удовлетворяющих условию 0&lt;x&lt;sub&gt;i&lt;/sub&gt;&lt;5,7.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Заменить\r\n	отрицательные элементы массива\r\n	находящиеся на нечетных позициях\r\n	единицей и вывести новый массив на\r\n	экран дисплея.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Вывести\r\n	на экран дисплея первый отрицательный\r\n	элемент и его порядковый номер.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Найти\r\n	сумму максимального и минимального\r\n	элементов массива.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Найти\r\n	произведение элементов находящихся\r\n	на четных позициях в массиве.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Найти\r\n	количество и порядковые номера элементов\r\n	массива вещественных чисел, удовлетворяющих\r\n	условию 2,1 \r\n	x&lt;sub&gt;i&lt;/sub&gt;\r\n	\r\n	7.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Поменять\r\n	местами в массиве вещественных чисел\r\n	максимальный и минимальный элементы\r\n	и вывести массив на экран дисплея.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Найти\r\n	среднее геометрическое элементов\r\n	массива вещественных чисел.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Найти\r\n	порядковый номер максимального элемента\r\n	среди четных значений массива целых\r\n	чисел.&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;p&gt;&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;p&gt;&lt;b&gt;Задание\r\n№2. &lt;/b&gt;В одномерном\r\nмассиве, состоящем из n\r\nвещественных элементов, вычислить:&lt;/p&gt;\r\n&lt;p&gt;&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	сумму отрицательных\r\n	элементов массива;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	произведение элементов\r\n	массива, расположенных между максимальным\r\n	и минимальным элементами;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	сумму положительных\r\n	элементов массива;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	произведение элементов\r\n	массива, расположенных между максимальным\r\n	по модулю и минимальным по модулю\r\n	элементами;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	произведение элементов\r\n	массива с четными номерами;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	сумму элементов массива,\r\n	расположенных между первым и последним\r\n	нулевыми элементами;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	сумму элементов массива с\r\n	нечетными номерами;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	сумму элементов массива,\r\n	расположенных между первым и последним\r\n	отрицательными элементами;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	максимальный элемент\r\n	массива;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	сумму элементов массива,\r\n	расположенных до последнего положительного\r\n	элемента;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	минимальный элемент массива;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	сумму элементов массива,\r\n	расположенных между первым и последним\r\n	положительными элементами;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	произведение элементов\r\n	массива, расположенных между первым и\r\n	вторым нулевыми элементами;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	номер минимального элемента\r\n	массива;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	сумму элементов массива,\r\n	расположенных между первым и вторым\r\n	отрицательными элементами;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	максимальный по модулю\r\n	элемент массива;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	сумму элементов массива,\r\n	расположенных между первым и вторым\r\n	положительными элементами;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	минимальный по модулю\r\n	элемент массива;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	сумму модулей элементов\r\n	массива, расположенных после первого\r\n	элемента, равного нулю;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	номер минимального по\r\n	модулю элемента массива;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	сумму модулей элементов\r\n	массива, расположенных после первого\r\n	отрицательного элемента;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	номер максимального по\r\n	модулю элемента массива;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	сумму элементов массива,\r\n	расположенных после первого положительного\r\n	элемента;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	количество элементов\r\n	массива, лежащих в отрезке от А до В;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	сумму элементов массива,\r\n	расположенных после максимального\r\n	элемента.&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;p&gt;&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;p&gt;&lt;b&gt;Задание\r\n№3.&lt;/b&gt; В массиве содержатся\r\nрезультаты измерений температуры\r\nвоздуха, которые проводились ежедневно\r\nв течение декабря месяца. Определите:&lt;/p&gt;\r\n&lt;p&gt;\r\n&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;ol&gt;\r\n	&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	среднемесячную температуру\r\n	декабря;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	сколько раз температура\r\n	была выше 0°С;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	минимальную температуру\r\n	первой декады декабря;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	сколько раз температура\r\n	была ниже 0°С;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	день, когда температура\r\n	была наибольшей;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	среднемесячную температуру\r\n	первой и второй декады декабря;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	день, когда температура\r\n	была наименьшей;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	день, когда первый раз\r\n	температура поднялась выше нуля, и\r\n	увеличьте эту температуру на 1°С;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	любой из самых холодных\r\n	дней декабря;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	сколько дней в декабре\r\n	температура была выше средней;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	день, когда температура\r\n	была ближе всего к средней температуре\r\n	в декабре;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	сколько дней в декабре\r\n	температура была ниже средней;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	минимальную температуру\r\n	второй декады декабря;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	минимальную температуру\r\n	тех дней декабря, которые следуют после\r\n	последнего из самых теплых дней в этом\r\n	месяце;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	максимальную температуру\r\n	первой декады декабря;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	температуры любого из\r\n	самых холодных и самых теплых дней и\r\n	поменяйте их местами;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	среднюю температуру тех\r\n	дней, которые предшествуют первому из\r\n	самых холодных дней в декабре;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	любые два самых холодных\r\n	дня;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	температуры всех дней выше\r\n	среднемесячной заменить на +1&lt;sup&gt;0&lt;/sup&gt;\r\n	С;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	сколько раз в декабре\r\n	температура меняла знак;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	первую из минимальных\r\n	температур перенесите на последнее\r\n	место, сдвинув все остальные к началу\r\n	массива;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	любые два самых теплых\r\n	дня;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	температуры всех дней ниже\r\n	среднемесячной заменить 0;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	максимальную температуру\r\n	второй декады декабря;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	первую из максимальных\r\n	температур перенесите на первое место,\r\n	сдвинув все остальные к концу массива.&lt;/p&gt;\r\n	&lt;/ol&gt;\r\n&lt;/ol&gt;\r\n\r\n\r\n&lt;h1&gt;КОНТРОЛЬНЫЕ ВОПРОСЫ&lt;/h1&gt;\r\n&lt;p&gt;&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;Каким\r\n	образом описывают массивы?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Укажите\r\n	особенности ввода и вывода одномерных\r\n	массивов?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	чем состоит особенность использования\r\n	приемов программирования при обработке\r\n	одномерных массивов?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Существуют\r\n	ли ограничения на размерность массива?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Где\r\n	и как определяется общее число элементов\r\n	массива?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Когда\r\n	индекс элемента в массиве совпадает с\r\n	порядковым номером этого элемента?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Что\r\n	называется базовым типом?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Верно\r\n	ли, что элементами массива могут быть\r\n	данные любого типа, включая\r\n	структурированные?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Какой\r\n	массив называется одномерным?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Можно\r\n	ли с помощью стандартной процедуры\r\n	write(x)\r\n	вывести весь массив х\r\n	целиком?&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;h1&gt;\r\nДОМАШНЕЕ ЗАДАНИЕ\r\n&lt;/h1&gt;\r\n&lt;p&gt;Т. А. Павловская “ С#.\r\nПрограммирование на языке высокого\r\nуровня: Учебник для вузов.” 2014, с. 126-139&lt;/p&gt;\r\n&lt;p&gt;&lt;br/&gt;\r\n&lt;/p&gt;', 2),
(8, 8, 10, 'Разработка программ с использованием массивов.', 'Формировать практические навыки и умения в написании программ, реализующих алгоритмы ветвления и цикла.', 'ПК, среда разработки Microsoft Visual Studio .NET.', '&lt;h1&gt;ПРАКТИЧЕСКАЯ ЧАСТЬ&lt;/h1&gt;\r\n&lt;p&gt;&lt;b&gt;Задание\r\n№1.&lt;/b&gt; Дан одномерный\r\nмассив из действительных чисел:&lt;/p&gt;\r\n&lt;p&gt;&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;Составить\r\n	программу расчета квадратного корня\r\n	из любого элемента массива;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Составить\r\n	программу расчета среднего арифметического\r\n	двух любых элементов массива;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Выяснить\r\n	является ли j-й\r\n	элемент массива положительным числом;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Выяснить\r\n	является ли k-й\r\n	элемент массива четным числом;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Выяснить\r\n	какой элемент массива больше: k-й\r\n	или s-й;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Все его\r\n	элементы увеличить в 2 раза;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Все его\r\n	элементы уменьшить на число А;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Все его\r\n	элементы разделить на первый элемент;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Все его\r\n	элементы умножить на последний элемент;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Определить\r\n	сумму квадратов всех элементов массива;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Определить\r\n	сумму шести первых элементов массива;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Определить\r\n	сумму элементов массива с k1-го\r\n	по k2-й\r\n	(значения k1\r\n	и k2\r\n	вводятся с клавиатуры; k2&gt;k1);&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Определить\r\n	среднее арифметическое элементов\r\n	массива с sl-гo\r\n	по s2-й\r\n	(значения sl\r\n	и s2\r\n	вводятся с клавиатуры; s2&gt;s1);&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Напечатать\r\n	все элементы, оканчивающиеся нулем;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Все\r\n	элементы с нечетными номерами заменить\r\n	на их квадратный корень;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Из всех\r\n	положительных элементов вычесть элемент\r\n	с номером k1,\r\n	из остальных — элемент с номером k2;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Все\r\n	элементы с нечетными номерами увеличить\r\n	на 1, с четными – уменьшить на 1;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Ко\r\n	всем отрицательным элементам прибавить\r\n	элемент с номером k1,\r\n	к остальным – элемент с номером k2;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Ко\r\n	всем нулевым элементам прибавить n,\r\n	из всех положительных элементов вычесть\r\n	а,\r\n	ко всем отрицательным прибавить b;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Ко\r\n	всем отрицательным элементам прибавить\r\n	элемент с номером аl,\r\n	из всех нулевых вычесть число b.\r\n	Положительные элементы оставить без\r\n	изменения;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Из\r\n	всех положительных элементов вычесть\r\n	а,\r\n	из всех отрицательных вычесть b,\r\n	ко всем нулевым элементам прибавить\r\n	с;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Все\r\n	элементы, оканчивающиеся цифрой 4,\r\n	уменьшить вдвое;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Все\r\n	четные элементы заменить на их квадраты,\r\n	а нечетные удвоить;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Четные\r\n	элементы увеличить на а,\r\n	а из элементов с четными номерами\r\n	вычесть b;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Определить\r\n	частное от деления суммы положительных\r\n	элементов массива на модуль суммы\r\n	отрицательных элементов.&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;p&gt;&lt;b&gt;Задание\r\n№2. &lt;/b&gt;Решите задачу:&lt;/p&gt;\r\n&lt;p&gt;&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	массиве хранится информация о массе\r\n	каждого из 30 предметов, загружаемых в\r\n	грузовой автомобиль, грузоподъемность\r\n	которого известна. Определить, не\r\n	превышает ли общая масса всех предметов\r\n	грузоподъемность автомобиля.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	массиве хранится информация о численности\r\n	книг в каждом из 35 разделов библиотеки.\r\n	Выяснить, верно ли, что общее число книг\r\n	и библиотеке есть шестизначное число.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Оценки,\r\n	полученные спортсменом в соревнованиях\r\n	по фигурному катанию (в баллах), хранятся\r\n	в массиве из 18 элементов. В первых шести\r\n	элементах записаны оценки по обязательной\r\n	программе, седьмой – двенадцатом – по\r\n	короткой программе, в остальных – по\r\n	произвольной программе. Выяснить, по\r\n	какому виду программы спортсмен показал\r\n	лучший результат.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Известно\r\n	число жителей, проживающих в каждом\r\n	доме улицы. Нумерация домов проведена\r\n	подряд. Дома с нечетными номерами\r\n	расположены на одной стороне улицы, с\r\n	четными – на другой. На какой стороне\r\n	улицы прожинает больше жителей?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	массиве хранятся сведения об общей\r\n	стоимости товаров, проданных фирмой\r\n	за каждый день марта. Определить\r\n	количество дней, в которые стоимость\r\n	проданных товаров превысила значение\r\n	s.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Известны\r\n	стоимости нескольких марок легковых\r\n	автомобилей и мотоциклов. Верно ли что\r\n	средняя стоимость автомобилей превышает\r\n	среднюю стоимость мотоциклов более\r\n	чем в 3 раза? Стоимость одного автомобиля\r\n	превышает 5000, что больше стоимости\r\n	любой марки мотоцикла.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	массиве записаны оценки по информатике\r\n	22 учащихся группы. Определить количество\r\n	учащихся группы, оценка которых меньше\r\n	средней оценки по группе, и вывести\r\n	номера элементов массива, соответствующих\r\n	таким учащимся.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	массиве хранится информация о стоимости\r\n	1 килограмма n\r\n	видов конфет. Определить, порядковый\r\n	номер самого дорогого вида конфет. Если\r\n	таких видов несколько, то должен быть\r\n	найден номер последнего из них.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Известно\r\n	количество осадков (в миллиметрах),\r\n	выпавших в Москве за каждый год в течение\r\n	первых 50 лет нашего столетии. Выяснить\r\n	среднее количество осадков и отклонение\r\n	от среднего для каждого года.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	массиве хранится информация о количестве\r\n	страниц в каждой из 100 книг. Все страницы\r\n	имеют одинаковую толщину. Определить\r\n	количество страниц в самой толстой\r\n	книге.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	массиве хранится информация о максимальной\r\n	скорости каждой из 40 марок легковых\r\n	автомобилей. Определить порядковый\r\n	номер самого быстрого автомобиля. Если\r\n	таких автомобилей несколько, то должен\r\n	быть найден номер последнего из них.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	массиве хранится информация о годе\r\n	рождения каждого из 30 человек. Определить,\r\n	на сколько лет возраст самого старого\r\n	человека превышает возраст самого\r\n	молодого. При определении возраста\r\n	учитывать только год рождения (месяц\r\n	и день не учитывать).&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	массиве хранится информация о максимальной\r\n	скорости каждой из 40 марок легковых\r\n	автомобилей. Определить порядковый\r\n	номер самого быстрого автомобиля. Если\r\n	таких автомобилей несколько, то должен\r\n	быть найден номер первого из них.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	массиве хранится информация о стоимости\r\n	1 килограмма n\r\n	видов конфет. Определить, порядковый\r\n	номер самого дорогого вида конфет. Если\r\n	таких видов несколько, то должен быть\r\n	найден номер первого из них.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Известна\r\n	численность каждой из 40 групп ВУЗа.\r\n	Верно ли, что в самой многочисленной\r\n	группе учится на 10 учащихся больше, чем\r\n	в самой малочисленной.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	массиве записано количество очков,\r\n	набранных 20 командами-участницами\r\n	чемпионата по футболу. Определить\r\n	команды, занявшие первое и второе место.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;При\r\n	выборе места строительства жилого\r\n	комплекса при металлургическом комбинате\r\n	необходимо учитывать «розу ветров»\r\n	(следует расположить жилой комплекс\r\n	так, чтобы частота ветра со стороны\r\n	металлургического комбината была бы\r\n	минимальной). Для этого в течение года\r\n	проводилась регистрация направления\r\n	ветра в районе строительства. Данные\r\n	представлены в виде массива, в котором\r\n	направление ветра за каждый день\r\n	кодируется следующим образом: 1 –\r\n	северный, 2 – южный, 3 – восточный, 4 –\r\n	западный, 5 – ceверо-западный, 6 –\r\n	северо-восточный, 7 – юго-западный, 8 –\r\n	юго-восточный. Определить, как должен\r\n	быть расположен жилой комплекс по\r\n	отношению к комбинату.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	массиве хранится информация о результатах\r\n	22 спортсменов, участвовавших в\r\n	соревнованиях по бегу на 100 м. Определить\r\n	результаты спортсменов, занявших первое\r\n	и второе места.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	массиве хранится информация о количестве\r\n	людей, живущих на каждом из 15 этажей\r\n	дома (на первое этаже – в первом элементе\r\n	массива, на второй – во втором и т. д.).\r\n	Определить два этажа, на которых\r\n	проживает меньше всего людей.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	массиве записана информация о росте\r\n	каждого из 25 учащихся группы (в порядке\r\n	уменьшении роста) Один из учащихся\r\n	выбыл. Получить новый массив с\r\n	упорядоченными в том же порядке данными\r\n	о росте оставшихся учащихся. Рассмотреть\r\n	случай, когда известен рост выбывшего\r\n	учащегося.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	массиве записана информация о стоимости\r\n	каждого из 20 видов товара, продаваемые\r\n	фирмой. С 1 января очередного года фирма\r\n	прекращает продавать товар, стоимость\r\n	которого записана в n-м\r\n	элементе массива. Получить массив со\r\n	стоимостью всех оставшихся видов\r\n	товара.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	массиве записана информация о росте\r\n	каждого из 25 учащихся группы (в порядке\r\n	уменьшении роста) Один из учащихся\r\n	выбыл. Получить новый массив с\r\n	упорядоченными в том же порядке данными\r\n	о росте оставшихся учащихся. Рассмотреть\r\n	случай, когда известен порядковый номер\r\n	выбывшего учащегося.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	массив записали информацию о высоте\r\n	над уровнем моря двадцати горных вершин\r\n	мира. Данные записаны в порядке,\r\n	соответствующем алфавитному порядку\r\n	названия вершин. После этого решили\r\n	ввести в массив сведения еще по одной\r\n	вершине. Получить новый массив, имея в\r\n	виду, что место в массиве для записи\r\n	дополнительной информации известно.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	массиве должна быть записана информация\r\n	о результатах соревнований по плаванию,\r\n	в котором приняли участие 25 спортсменов.\r\n	Данные должны быть записаны в порядке\r\n	ухудшения результата. После заполнения\r\n	массива выяснилось, что значение первого\r\n	элемента не соответствует требованию\r\n	упорядоченности. Изменить массив так,\r\n	чтобы данные были упорядочены.	&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;&lt;b&gt;Задание\r\n№3. &lt;/b&gt;Обработка матриц&lt;/p&gt;\r\n&lt;p&gt;&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;p&gt;Пример:\r\nВычислить сумму элементов каждой строки\r\nматрицы А(6х5).&lt;/p&gt;\r\n&lt;p&gt;Блок-схема\r\nалгоритма:&lt;/p&gt;\r\n&lt;p&gt;&lt;img src=&quot;https://sun9-57.userapi.com/impf/uzQxCOoHCzKOBmwO3Of3h-RDP7HQEzWjE1ZFAg/eoN5MDHcjJE.jpg?size=366x418&amp;quality=96&amp;sign=9c014a8973ddb9d7eb13ab04c7dd8cab&amp;type=album&quot; width=&quot;234&quot; height=&quot;267&quot; border=&quot;0&quot; alt=&quot;photo&quot;/&gt;\r\n&lt;/p&gt;\r\n&lt;p&gt;&lt;img src=&quot;https://sun9-39.userapi.com/impf/uEgt1OmqG2VqCqQ5DIa1ASvPXix7LVJtfu4qkQ/3pQBzpRJN00.jpg?size=366x584&amp;quality=96&amp;sign=c6b422a3843a3a8f8942115942d236fd&amp;type=album&quot; width=&quot;234&quot; height=&quot;374&quot; border=&quot;0&quot; alt=&quot;photo&quot;/&gt;\r\n&lt;/p&gt;\r\n&lt;p&gt;&lt;b&gt;Варианты\r\nзадания №1&lt;/b&gt;&lt;/p&gt;\r\n&lt;p&gt;&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;Вычислить\r\n	и запомнить сумму и число положительных\r\n	элементов каждого столбца матрицы\r\n	А(8х7).&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Вычислить\r\n	сумму и число элементов матрицы А(10х10),\r\n	находящихся под главной диагональю и\r\n	над ней.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Вычислить\r\n	сумму и число положительных элементов\r\n	матрицы В(9х9), находящихся над главной\r\n	диагональю.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Записать\r\n	на место отрицательных элементов\r\n	матрицы В(7х7) нули и вывести ее на печать.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Записать\r\n	на место отрицательных элементов\r\n	матрицы нули, а на место положительных\r\n	– единицы. Вывести на печать нижнюю\r\n	треугольную матрицу.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Найти\r\n	в каждой строке матрицы А(8х10) максимальный\r\n	и минимальный элементы. Матрицу вывести\r\n	в виде таблицы.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Транспонировать\r\n	матрицу В(8х8) и вывести ее таблицей.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Для\r\n	каждой строки матрицы А(5х7) найти число\r\n	элементов кратных пяти.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Найти\r\n	максимальный элемент матрицы А(6х10) и\r\n	его порядковый номер.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Найти\r\n	в каждой строке матрицы В(8х8) наибольший\r\n	элемент и поменять его местами с\r\n	элементом главной диагонали. Вывести\r\n	матрицу на экран дисплея.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Найти\r\n	наибольший и наименьший  элементы\r\n	матрицы и поменять их местами.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Вычислить\r\n	среднее арифметическое значений\r\n	элементов каждой строки матрицы А(8х6).&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Найти\r\n	строку с наибольшей и наименьшей суммой\r\n	элементов. Вывести на печать найденные\r\n	строки и суммы их элементов для матрицы\r\n	В(6х6).&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Найти\r\n	количество отрицательных элементов\r\n	матрицы А(7х8).&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Найти\r\n	порядковый номер  минимального элемента\r\n	матрицы А(8х8).&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Найти\r\n	разность сумм первой и последней строк\r\n	матрицы А(9х6).&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Определить\r\n	число четных элементов матрицы А(10х6).&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Найти\r\n	сумму элементов матрицы А(9х9) кратных\r\n	четырем.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Поменять\r\n	местами вторую и предпоследнюю строки\r\n	матрицы В(8х8). Вывести ее на экран.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Найти\r\n	количество элементов матрицы В(7х8)\r\n	кратных пяти в третьем столбце.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Поменять\r\n	местами первый и последний столбцы\r\n	матрицы А(9х6) и вывести ее на экран.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Найти\r\n	количество отрицательных элементов\r\n	матрицы А(9х9).&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Определить\r\n	порядковый номер максимального элемента\r\n	главной диагонали матрицы А(8х8).&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Найти\r\n	среднее арифметическое элементов\r\n	матрицы А(7х9) больших девяти.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Определить\r\n	минимальный элемент верхней треугольной\r\n	матрицы для А(8х10).&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;\r\n&lt;b&gt;Задание №4. &lt;/b&gt;Нахождение\r\nмаксимума и минимума:&lt;/p&gt;\r\n&lt;p&gt;&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;Дан\r\n	двумерный массив. Определить минимальное\r\n	значение среди элементов четвертого\r\n	столбца массива.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Составить\r\n	программу нахождения минимального\r\n	значения среди элементов любой строки\r\n	двумерного массива.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Дан\r\n	двумерный массив. Определить номер\r\n	столбца, в котором расположен минимальный\r\n	элемент четвертой строки массива. Если\r\n	элементов с минимальным значением в\r\n	этой строке несколько, то должен быть\r\n	найден номер столбца самого левого из\r\n	них.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Дан\r\n	двумерный массив. Определить номер\r\n	строки, в котором расположен максимальный\r\n	элемент третьего столбца массива. Если\r\n	элементов с максимальным значением в\r\n	этой столбце несколько, то должен быть\r\n	найден номер строки самого нижнего из\r\n	них.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Составить\r\n	программу нахождения номера строки, в\r\n	которой расположен максимальный элемент\r\n	любого столбца двумерного массива.\r\n	Если элементов с максимальным значением\r\n	в этом столбце несколько, то должен\r\n	быть найден номер строки самого нижнего\r\n	из них.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Составить\r\n	программу нахождения номера столбца,\r\n	в котором расположен минимальный\r\n	элемент любой строки двумерного массива.\r\n	Если элементов с минимальным значением\r\n	в этой строке несколько, то должен быть\r\n	найден номер столбца самого левого из\r\n	них.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Составить\r\n	программу нахождения номера столбца,\r\n	в котором расположен максимальный\r\n	элемент любой строки двумерного массива.\r\n	Если элементов с максимальным значением\r\n	в этой строке несколько, то должен быть\r\n	найден номер столбца самого правого\r\n	из них.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Дан\r\n	двумерный массив. Определить координаты\r\n	минимального элемента массива. Если\r\n	элементов с минимальным значением\r\n	несколько, то должны быть найдены\r\n	координаты самого нижнего и самого\r\n	правого из них.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Дан\r\n	двумерный массив. В каждой его строке\r\n	найти минимальный элемент.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Дан\r\n	двумерный массив. В каждой его строке\r\n	найти координаты максимального элемента.\r\n	Если элементов с максимальным значением\r\n	в строке несколько, то должны быть\r\n	найдены координаты самого левого из\r\n	них.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Дан\r\n	двумерный массив. В каждой его строке\r\n	найти координаты минимального элемента.\r\n	Если элементов с минимальным значением\r\n	в строке несколько, то должны быть\r\n	найдены координаты самого правого из\r\n	них.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	двумерном массиве хранится информация\r\n	о количестве учеников в каждом из\r\n	четырех классов каждой параллели школы\r\n	с первой по одиннадцатую (в первой\r\n	строке – информация о первых классах,\r\n	во второй – вторых и т.д.). Найти\r\n	численность самой маленькой (по числу\r\n	учащихся) параллели.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	двумерном массиве хранится информация\r\n	о баллах, полученных спортсменами-пятиборцами\r\n	в каждом из пяти видов спорта (в первой\r\n	строке – информация о баллах первого\r\n	спортсмена, во второй – второго и т.д.).\r\n	Общее число спортсменов равно 20.\r\n	Определить сколько баллов набрал\r\n	спортсмен-победитель соревнований.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	двумерном массиве хранится информация\r\n	о баллах, полученных спортсменами-пятиборцами\r\n	в каждом из пяти видов спорта (в первой\r\n	строке – информация о баллах первого\r\n	спортсмена, во второй – второго и т.д.).\r\n	Общее число спортсменов равно 20.\r\n	Определить сколько баллов набрал\r\n	спортсмен, занявший последнее место.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Дан\r\n	двумерный массив. Найти строку с\r\n	максимальной суммой элементов. Если\r\n	таких  строк несколько, должен быть\r\n	найден номер самой нижней из них.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Дан\r\n	двумерный массив. Найти строку с\r\n	минимальной суммой элементов. Если\r\n	таких строк несколько, должен быть\r\n	найден номер самой верхней из них.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Информация\r\n	о количестве жильцов и каждой из четырех\r\n	квартир каждого этажа 12-этажного дома\r\n	хранится в двумерном массиве (в первой\r\n	строке – информация о квартирах первого\r\n	этажа, во второй – второго и т.д.).\r\n	Определить на каком этаже проживает\r\n	меньше всего людей.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	зрительном зале 28 рядов, в каждом из\r\n	которых по 36 мест (кресел). Информация\r\n	о проданных билетах хранится в двумерном\r\n	массиве, номера строк которого\r\n	соответствуют номерам рядов, а номера\r\n	столбцов – номерам мест. Если билет на\r\n	то или иное место продан, то соответствующий\r\n	элемент массива имеет значение 1, в\r\n	противном случае – 0. Определить на\r\n	какой ряд придано больше всего билетов.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	двумерном массиве размером 17x17 записано\r\n	количество очков, набранные той или\r\n	иной командой во всех встречах с другими\r\n	командами (3 – если данная команда\r\n	выиграла игру, 0 – если проиграла, 1 –\r\n	если игра закончились вничью). Определить\r\n	сколько очков набрала команда, ставшая\r\n	чемпионом.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	двумерном массиве размером 17x17 записано\r\n	количество очков, набранные той или\r\n	иной командой во всех встречах с другими\r\n	командами (3 – если данная команда\r\n	выиграла игру, 0 – если проиграла, 1 –\r\n	если игра закончились вничью). Определить\r\n	номер команды, занявшей последнее\r\n	место.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	двумерном массиве размером 17x17 записано\r\n	количество очков, набранные той или\r\n	иной командой во всех встречах с другими\r\n	командами (3 – если данная команда\r\n	выиграла игру, 0 – если проиграла, 1 –\r\n	если игра закончились вничью). Определить\r\n	сколько очков набрала команда, занявшая\r\n	последнее место.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	двумерном массиве размером 17x17 записано\r\n	количество очков, набранные той или\r\n	иной командой во всех встречах с другими\r\n	командами (3 – если данная команда\r\n	выиграла игру, 0 – если проиграла, 1 –\r\n	если игра закончились вничью). Определить\r\n	номер команды, ставшей чемпионом.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Дан\r\n	двумерный массив из двух строк и\r\n	пятнадцати столбцов. Найти номера двух\r\n	соседних столбцов, сумма элементов в\r\n	которых минимальна.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Дан\r\n	двумерный массив из двадцати двух строк\r\n	и двух столбцов. Найти номера двух\r\n	соседних строк, сумма элементов в\r\n	которых максимальна.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	Москве самыми теплыми являются дни с\r\n	15 июля по 15 августа. Для проведения\r\n	музыкального фестиваля необходимо\r\n	выбрать 7 следующих подряд дней этого\r\n	периода, которые были наиболее теплыми\r\n	за последние 10 лет (данные каждого года\r\n	о температуре воздуха в указанный\r\n	период имеются).&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;p&gt;Дополнительные\r\nзадания:&lt;/p&gt;\r\n&lt;p&gt;&lt;img src=&quot;https://sun9-7.userapi.com/impf/saWmMsUKSSESA6V0iZUCc-XqAYd1oGLRt-wn8A/CHgkk0sWo6w.jpg?size=974x316&amp;quality=96&amp;sign=ac3abcba986341bb3c8c8c3bdb742031&amp;type=album&quot; alt=&quot;photo&quot;/&gt;\r\n&lt;/p&gt;\r\n&lt;p&gt;&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;h1&gt;КОНТРОЛЬНЫЕ ВОПРОСЫ&lt;/h1&gt;\r\n&lt;p&gt;&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;Каким\r\n	образом описывают массивы?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Укажите\r\n	особенности ввода и вывода одномерных\r\n	массивов?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	чем состоит особенность использования\r\n	приемов программирования при обработке\r\n	одномерных массивов?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Существуют\r\n	ли ограничения на размерность массива?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Где\r\n	и как определяется общее число элементов\r\n	массива?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Когда\r\n	индекс элемента в массиве совпадает с\r\n	порядковым номером этого элемента?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Что\r\n	называется базовым типом?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Верно\r\n	ли, что элементами массива могут быть\r\n	данные любого типа, включая\r\n	структурированные?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Какой\r\n	массив называется одномерным?&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Можно\r\n	ли с помощью стандартной процедуры\r\n	write(x)\r\n	вывести весь массив х\r\n	целиком?&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;h1&gt;\r\nДОМАШНЕЕ ЗАДАНИЕ\r\n&lt;/h1&gt;\r\n&lt;p&gt;Т. А. Павловская “ С#.\r\nПрограммирование на языке высокого\r\nуровня: Учебник для вузов.” 2014, с. 126-139&lt;/p&gt;', 2),
(9, 42, 42, 'Создание инсталляционных программ Windows-приложений для развертывания созданного приложения.', 'Сформировать умение создавать инсталляционные программы Windows-приложений для развертывания созданного приложения.', 'ПК, среда разработки Microsoft Visual Studio .NET. ', '<h1>МЕТОДИЧЕСКИЕ УКАЗАНИЯ</h1>', 3);
INSERT INTO `labs` (`IDLab`, `StartNumber`, `EndNumber`, `Theme`, `Goal`, `Equipment`, `Content`, `IDStatus`) VALUES
(10, 11, 11, 'Создание и применение регулярных выражений при разработке программ.', 'Сформировать умения создавать регулярные выражения и применять их при разработке программ.', 'ПК, среда разработки Microsoft Visual Studio .NET.', '&lt;h1&gt;МЕТОДИЧЕСКИЕ УКАЗАНИЯ&lt;/h1&gt;\r\n&lt;p&gt;Регулярные\r\nвыражения &lt;b&gt;–&lt;/b&gt;&lt;b&gt; &lt;/b&gt;это один из способов\r\nпоиска подстрок (соответствий) в строках.\r\nОсуществляется с помощью просмотра\r\nстроки в поисках некоторого шаблон.\r\nОчень эффективны библиотеки,\r\nинтерпретирующие регулярные выражения,\r\nобычно пишутся на низкоуровневых\r\nвысокопроизводительных языках (С, C++,\r\nAssembler).&lt;/p&gt;\r\n&lt;p&gt;\r\n&lt;b&gt;Синтаксис\r\nрегулярных выражений.&lt;/b&gt;&lt;b&gt; &lt;/b&gt;Регулярное\r\nвыражение на C# задается строковой\r\nконстантой. Обычно используется\r\n@-константа. В С# работа с регулярными\r\nвыражениями выглядит следующим образом:&lt;/p&gt;\r\n&lt;code&gt;\r\nRegex re = new Regex(«образец», «опции»); \r\nMatchCollection me = re.Matches(―строка для поиска‖); \r\niCountMatchs = me.Count, где re – это объект типа Regex. В конструкторе ему передается образец поиска и опции.\r\n&lt;/code&gt;\r\n&lt;table&gt;\r\n	\r\n	\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	 \r\n	&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	&lt;b&gt;Символы\r\n	описания шаблона&lt;/b&gt;&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Символ&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Интерпретация&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	 \r\n	&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	&lt;b&gt;Категория:\r\n	подмножества (классы) символов&lt;/b&gt;&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	&lt;b&gt;.&lt;/b&gt;&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Соответствует\r\n	любому символу, за исключением символа\r\n	конца строки&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	&lt;b&gt;[aeiou]&lt;/b&gt;&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Соответствует\r\n	любому символу из множества, заданного\r\n	в квадратных скобках&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	&lt;b&gt;[^aeiou]&lt;/b&gt;&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Отрицание.\r\n	Соответствует любому символу, за\r\n	исключением символов, заданных в\r\n	квадратных скобках&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	&lt;b&gt;[0-9a-fA-F]&lt;/b&gt;&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Задание\r\n	диапазона символов, упорядоченных по\r\n	коду. Так, 0-9задает любую цифру&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	 \r\n	&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	&lt;br/&gt;\r\n	&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	&lt;b&gt;\\w&lt;/b&gt;&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Множество\r\n	символов, используемых при задании\r\n	идентификаторов – большие и малые\r\n	символы латиницы, цифры и знак\r\n	подчеркивания&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	&lt;b&gt;s&lt;/b&gt;&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Соответствует\r\n	символам белого пробела&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	&lt;b&gt;d&lt;/b&gt;&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Соответствует\r\n	любому символу из множества цифр&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	 \r\n	&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	&lt;b&gt;Категория:\r\n	Операции (модификаторы)&lt;/b&gt;&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	&lt;b&gt;*&lt;/b&gt;&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Итерация.\r\n	Задает ноль или более соответствий;\r\n	например, w* или (abc)*. Аналогично {0,}&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	&lt;b&gt;+&lt;/b&gt;&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Положительная\r\n	итерация. Задает одно или более\r\n	соответствий; например, w+ или (abc)+.\r\n	Аналогично {1,}&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	&lt;b&gt;?&lt;/b&gt;&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Задает\r\n	ноль или одно соответствие; например,\r\n	w? Или (abc)? Аналогично {0,1}&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	&lt;b&gt;{n}&lt;/b&gt;&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Задает\r\n	в точности n соответствий;\r\n	например, w{2}&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	&lt;b&gt;{n,}&lt;/b&gt;&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Задает,\r\n	по меньшей мере n соответствий;\r\n	например, (abc){2,}&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	 \r\n	&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	&lt;b&gt;Категория:\r\n	Группирование&lt;/b&gt;&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	&lt;b&gt;(?&lt;Name&gt;)&lt;/b&gt;&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	При\r\n	обнаружении соответствия выражению,\r\n	заданному в круглых скобках, создается\r\n	именованная группа, которой дается\r\n	имя Name&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	&lt;b&gt;()&lt;/b&gt;&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Круглые\r\n	скобки разбивают регулярное выражение\r\n	на группы. Для каждого подвыражения,\r\n	заключенного в круглые скобки, создается\r\n	группа, автоматически получающая\r\n	номер&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n&lt;/table&gt;\r\n&lt;p&gt;\r\n&lt;b&gt;Класс\r\n&lt;/b&gt;Regex&lt;b&gt;.&lt;/b&gt;&lt;b&gt;\r\n&lt;/b&gt;Это основной класс, объекты которого\r\nопределяют регулярные выражения. В\r\nконструктор класса передается в качестве\r\nпараметра строка, задающая регулярное\r\nвыражение. Основные методы\r\nкласса Regex:&lt;/p&gt;\r\n&lt;ul&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	метод\r\n	Match&lt;b&gt;\r\n	&lt;/b&gt;запускает поиск первого соответствия.\r\n	Параметром передается строка поиска.\r\n	Метод возвращает объект класса Match,\r\n	описывающий результат поиска.&lt;/p&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;\r\nПрограмма.\r\nПоиск первого соответствия шаблону&lt;/p&gt;\r\n&lt;code&gt;\r\nstring FindMatch(string str, string strpat){\r\n\r\nRegex pat = new Regex(strpat); Match match =pat.Match(str); string found = &quot;&quot;;\r\n\r\nif (match.Success) { found =match.Value;\r\n\r\nConsole.WriteLine(&quot;Строка ={0} Образец={1} Найдено={2}&quot;, str,strpat,found);\r\n\r\n}\r\n\r\nreturn(found);\r\n\r\n}\r\n\r\npublic void TestSinglePat(){ string str, strpat, found;\r\n\r\nConsole.WriteLine(&quot;Поиск по образцу&quot;);\r\n\r\n//образец задает подстроку, начинающуюся с символа a, //далее идут буквы или цифры.\r\n\r\nstr =&quot;start&quot;; strpat =@&quot;aw+&quot;;\r\n\r\nfound = FindMatch(str,strpat); //art str =&quot;fab77cd efg&quot;;\r\n\r\nfound = FindMatch(str,strpat); //ab77cd\r\n\r\n//образец задает подстроку, начинающуюся с символа a, //заканчивающуюся f с возможными символами b и d в середине strpat = &quot;a(b|d)*f&quot;; str = &quot;fabadddbdf&quot;;\r\n\r\nfound = FindMatch(str,strpat); //adddbdf\r\n\r\n}\r\n&lt;/code&gt;\r\n&lt;ul&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	метод\r\n	&lt;b&gt;Matches&lt;/b&gt;&lt;b&gt; &lt;/b&gt;позволяет разыскать все\r\n	непересекающиеся вхождения подстрок,\r\n	удовлетворяющие образцу. В качестве\r\n	результата возвращается объект\r\n	MatchCollection, представляющий\r\n	коллекцию объектов Match.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Метод\r\n	&lt;b&gt;NextMatch&lt;/b&gt;&lt;b&gt; &lt;/b&gt;запускает новый поиск.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	метод\r\n	&lt;b&gt;Split&lt;/b&gt;&lt;b&gt; &lt;/b&gt;является обобщением метода\r\n	Split\r\n	класса String.\r\n	Он позволяет, используя образец,\r\n	разделить искомую строку на элементы.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Метод\r\n	&lt;b&gt;Replace –&lt;/b&gt;&lt;b&gt; &lt;/b&gt;позволяет делать замену\r\n	найденного образца. Метод перегружен.\r\n	При вызове метода передаются две строки:\r\n	первая задает строку, в которой необходимо\r\n	произвести замену, а вторая – на что\r\n	нужно заменить найденную подстроку.&lt;/p&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;&lt;b&gt;Классы\r\n&lt;/b&gt;&lt;b&gt;Match&lt;/b&gt;&lt;b&gt; и\r\n&lt;/b&gt;&lt;b&gt;MatchCollection&lt;/b&gt;&lt;b&gt;.&lt;/b&gt;&lt;b&gt;\r\n&lt;/b&gt;Коллекция MatchCollection,\r\nпозволяет получить доступ к каждому ее\r\nэлементу – объекту Match. Для этого можно\r\nиспользовать цикл foreach.&lt;/p&gt;\r\n&lt;p&gt;\r\nПри\r\nработе с объектами класса Match наибольший\r\nинтерес представляют свойства класса.\r\nРассмотрим основные свойства:&lt;/p&gt;\r\n&lt;ul&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	свойства\r\n	Index, Length и Value наследованы от прародителя\r\n	Capture. Они описывают найденную подстроку\r\n	– индекс начала подстроки в искомой\r\n	строке, длину подстроки и ее значение;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	свойство\r\n	Groups класса Match возвращает коллекцию\r\n	групп – объект GroupCollection, который\r\n	позволяет работать с группами, созданными\r\n	в процессе поиска соответствия;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	свойство\r\n	Captures, наследованное от объекта Group,\r\n	возвращает коллекцию CaptureCollection.&lt;/p&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;\r\n&lt;b&gt;Программа.&lt;/b&gt;&lt;b&gt;\r\n&lt;/b&gt;Поиск всех образцов, соответствующих\r\nрегулярному выражению&lt;/p&gt;\r\n&lt;code&gt;\r\npublic static void Main( ) {\r\n\r\nstring si = &quot;Это строка для поиска&quot;;\r\n\r\n// найти любой пробельный символ следующий за непробельным\r\n\r\nRegex theReg = new Regex(@&quot;(S+)s&quot;);\r\n\r\n// получить коллекцию результата поиска\r\n\r\nMatchCollection theMatches = theReg.Matches (si); // перебор всей коллекции\r\n\r\nforeach (Match theMatch in theMatches) { Console.WriteLine( &quot;theMatch.Length: {0}&quot;,\r\n\r\ntheMatch.Length);\r\n\r\nif (theMatch.Length != 0)\r\n\r\nConsole.WriteLine(&quot;theMatch: {0}&quot;, theMatch.ToString( ));\r\n\r\n} }\r\n&lt;/code&gt;\r\n&lt;p&gt;\r\n&lt;b&gt;Порядок\r\nвыполнения работы:&lt;/b&gt;&lt;/p&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Выполнить\r\n	задания по вариантам.&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;table&gt;\r\n	\r\n	\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	№ варианта&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Описание\r\n	действий программы&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;\r\n	&lt;ol&gt;&lt;li&gt;&lt;p&gt;&lt;/p&gt;\r\n	&lt;/ol&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;\r\n	&lt;ol&gt;&lt;li&gt;&lt;p&gt;\r\n	Задан\r\n	текст. Определить, входит ли в него\r\n	заданное слово и сколько раз.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Дан\r\n	текст из 60 символов. Напечатать этот\r\n	текст, удалив все входящие в него\r\n	гласные.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Дан\r\n	текст из 60 символов. Напечатать этот\r\n	текст, подчёркивая (ставя минусы в\r\n	соответствующих позициях следующей\r\n	строки) все входящие в него гласные.&lt;/p&gt;\r\n	&lt;/ol&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;\r\n	&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;/p&gt;\r\n	&lt;/ol&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;\r\n	&lt;ol&gt;&lt;li&gt;&lt;p&gt;\r\n	Задан\r\n	текст. Определить, является ли он\r\n	текстом на английском языке.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Дана\r\n	строка содержащая русские и латинские\r\n	буквы. Определить каких (русских или\r\n	латинских) больше\r\n	и если больше латинских удалить\r\n	русские, если больше русских удалить\r\n	латинские.&lt;/p&gt;\r\n	&lt;/ol&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;\r\n	&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;/p&gt;\r\n	&lt;/ol&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;\r\n	&lt;ol&gt;&lt;li&gt;&lt;p&gt;\r\n	Задан\r\n	текст. После каждой буквы «о» вставить\r\n	сочетание «Oк».&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Удалить\r\n	из текста введенного пользователем\r\n	все русские слова.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Дано\r\n	предложение, состоящее не менее чем\r\n	из 5 слов. Напечатать текст, состоящий\r\n	из первых букв всех слов предложения.&lt;/p&gt;\r\n	&lt;/ol&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;\r\n	&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;/p&gt;\r\n	&lt;/ol&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;\r\n	&lt;ol&gt;&lt;li&gt;&lt;p&gt;\r\n	Задан\r\n	текст. Определить, является ли он\r\n	текстом на русском языке.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Дано\r\n	предложение. Удалить из него пробелы\r\n	и буквы &quot;э&quot;, &quot;ю&quot;, &quot;я&quot;.\r\n	Выдать результат.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Дана\r\n	строка содержащая русские и латинские\r\n	буквы. Определить каких (русских или\r\n	латинских) больше и насколько.&lt;/p&gt;\r\n	&lt;/ol&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;\r\n	&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;/p&gt;\r\n	&lt;/ol&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;\r\n	&lt;ol&gt;&lt;li&gt;&lt;p&gt;\r\n	Дана\r\n	последовательность из 10 слов. Удалить\r\n	из неё слова, которые\r\n	содержат и русские, и латинские буквы.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	В\r\n	строке S находится не более 70 латинских\r\n	букв. Удалить из неё строчные буквы.\r\n	Вывести результат.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Дано\r\n	предложение. Удалить из него те буквы,\r\n	которые являются вторыми по счёту\r\n	хотя бы одном слове предложения&lt;/p&gt;\r\n	&lt;/ol&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;\r\n	&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;/p&gt;\r\n	&lt;/ol&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;\r\n	&lt;ol&gt;&lt;li&gt;&lt;p&gt;\r\n	Задан\r\n	текст. Определить, содержит ли он\r\n	цифры.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Дано\r\n	предложение, содержащее русские и\r\n	латинские буквы. Удалить из него\r\n	латинские буквы.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;В\r\n	строке S находится не более 80 латинских\r\n	букв. Напечатать эту строку, добавляя\r\n	перед каждой буквой &quot;x&quot; букву &quot;z&quot;&lt;/p&gt;\r\n	&lt;/ol&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;\r\n	&lt;ol start=&quot;7&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;/p&gt;\r\n	&lt;/ol&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;\r\n	&lt;ol&gt;&lt;li&gt;&lt;p&gt;\r\n	Задан\r\n	текст. Определить, сколько предложений\r\n	начинается со слова ―Информатика&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Заданное\r\n	целое число от 1 до 1999 напечатать\r\n	римскими цифрами (L=50, C=100, D=500, M=1000)&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;Дано\r\n	предложение, состоящее не менее чем\r\n	из 5 слов. Напечатать все слова из\r\n	предложения, содержащие ровно одну\r\n	букву &quot;s&quot;.&lt;/p&gt;\r\n	&lt;/ol&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n&lt;/table&gt;\r\n&lt;h1&gt;КОНТРОЛЬНЫЕ\r\nВОПРОСЫ&lt;/h1&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Дайте\r\n	определение понятию регулярные\r\n	выражения.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Дайте\r\n	описание класса регулярных выражений,\r\n	как создать регулярное выражение.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Приведите\r\n	пример использования регулярных\r\n	выражений в программах.&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;h1&gt;ДОМАШНЕЕ\r\nЗАДАНИЕ&lt;/h1&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Пахомов\r\n	Б. И. С# для начинающих. БХВ-Петербург,\r\n	2014. – с. 51-57&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Павловская\r\n	Т.А. С#. Регулярные выражения 355 – 365\r\n	стр.;&lt;/p&gt;\r\n&lt;/ol&gt;', 2),
(13, 12, 12, '', '', '', '', 3),
(14, 12, 12, '', '', '', '', 3),
(15, 12, 12, 'Разработка программ с использованием структур и перечислений.', 'Сформировать умения разрабатывать алгоритмы и реализовать программы с применением переменных структур и перечислений.', ': ПК, среда разработки Microsoft Visual Studio .NET.', '&lt;h1&gt;МЕТОДИЧЕСКИЕ УКАЗАНИЯ&lt;/h1&gt;\r\n&lt;p&gt;\r\nПеречисление –\r\nэто частный случай класса. Перечисление\r\nзадает конечное множество возможных\r\nзначений, которые могут получать объекты\r\nкласса перечисление. Синтаксис объявления\r\nэтого класса: включает заголовок и тело\r\nкласса, содержащее список возможных\r\nзначений:&lt;/p&gt;\r\n&lt;p&gt;\r\n[атрибуты][модификаторы]enum\r\nимя_перечисления [: базовый класс]\r\n{список_возможных_значений}&lt;/p&gt;\r\n&lt;p&gt;\r\nОсобенности\r\nобъявления перечислений:&lt;/p&gt;\r\n&lt;ul&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	перечисления\r\n	могут быть объявлены непосредственно\r\n	в пространстве имен проекта или могут\r\n	быть вложены в описание класса;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	константы\r\n	разных перечислений могут совпадать.\r\n	Имя константы всегда уточняется именем\r\n	перечисления;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	константы\r\n	могут задаваться словами русского\r\n	языка;&lt;/p&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;\r\nразрешается\r\nзадавать базовый класс перечисления\r\n(любой целочисленный тип кроме long).&lt;/p&gt;\r\n&lt;h1&gt;УСЛОВИЕ\r\nЗАДАНИЙ&lt;/h1&gt;\r\n&lt;p&gt;&lt;b&gt;Задание&lt;/b&gt;:\r\nнаписать программу согласно заданию с\r\nиспользованием структуры.&lt;/p&gt;\r\n&lt;table&gt;\r\n	\r\n	\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	№&lt;/p&gt;\r\n	&lt;p&gt;вар.&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Задача&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	1&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Описать\r\n	структуру с именем GROUP, содержащую\r\n	поля: Name –&lt;/p&gt;\r\n	&lt;p&gt;фамилия\r\n	и инициалы, DAT – дата рождения (год,\r\n	месяц, число), SES&lt;/p&gt;\r\n	&lt;p&gt;–\r\n	успеваемость\r\n	(массив из трех элементов).&lt;/p&gt;\r\n	&lt;p&gt;Написать\r\n	программу, выполняющую:&lt;/p&gt;\r\n	&lt;ul&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	ввод\r\n	с клавиатуры данных в массив\r\n	GR5,состоящий из 10 структур типа GROUP;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	вывод\r\n	на экран записей, упорядоченных по\r\n	возрастанию поля SES;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	вывод\r\n	списка студентов, возраст которых на\r\n	01.12.2010 года не превышает 20 лет;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;если\r\n	таких студентов нет – выдать сообщение.&lt;/p&gt;\r\n	&lt;/ul&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	2&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Описать\r\n	структуру с именем STUDENT, содержащую\r\n	поля: Name – фамилия и инициалы, Kurs −\r\n	курс, SES – успеваемость (массив из пяти\r\n	элементов).&lt;/p&gt;\r\n	&lt;p&gt;Написать\r\n	программу, выполняющую:&lt;/p&gt;\r\n	&lt;ul&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	ввод\r\n	с клавиатуры данных в массив\r\n	STUD,состоящий из 10 структур&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	типа\r\n	STUDENT, записи должны быть упорядочены\r\n	по алфавиту;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	вывод\r\n	на экран записей, упорядоченного\r\n	списка студентов, средний&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	бал\r\n	которых превышает общий средний бал;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;если\r\n	таких студентов нет – выдать сообщение.&lt;/p&gt;\r\n	&lt;/ul&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	3&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Описать\r\n	структуру с именем STUD, содержащую\r\n	поля: Name – фамилия и инициалы, GROUP –\r\n	название группы (факультет, курс, номер\r\n	группы), SES – успеваемость (массив из\r\n	четырёх элементов).&lt;/p&gt;\r\n	&lt;p&gt;Написать\r\n	программу, выполняющую:&lt;/p&gt;\r\n	&lt;ul&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	ввод\r\n	с клавиатуры данных в массив STUD1,\r\n	состоящий из 10 структур типа STUD, записи\r\n	должны быть упорядочены по алфавиту;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	вывод\r\n	на экран данных о студентах, включенных\r\n	в массив, средний бал которых превышает\r\n	4,2. Список упорядочить по возрастанию\r\n	среднего бала. \r\n	&lt;/p&gt;\r\n	&lt;/ul&gt;\r\n	&lt;p&gt;Сохранить\r\n	информацию о положении студента в\r\n	исходном списке; если таких студентов\r\n	нет – выдать сообщение.&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	4&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Описать\r\n	структуру с именем NOTE, содержащую\r\n	поля: Name – фамилия и инициалы, TELE –\r\n	номер телефона, DATE – дата рождения\r\n	(год, месяц, число.&lt;/p&gt;\r\n	&lt;p&gt;Написать\r\n	программу, выполняющую:&lt;/p&gt;\r\n	&lt;ul&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	ввод\r\n	с клавиатуры данных в массив BLOCKNOTE,\r\n	состоящий из 10&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	структур\r\n	типа NOTE, записи должны быть упорядочены\r\n	по возрастанию даты рождения;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	вывод\r\n	на экран сведений о человеке, номер\r\n	телефона которого введен с клавиатуры;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;если\r\n	такого человека нет – выдать сообщение.&lt;/p&gt;\r\n	&lt;/ul&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	5&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Описать\r\n	структуру с именем NOTE1, содержащую\r\n	поля: Name – фамилия и инициалы, TELE –\r\n	номер телефона, DATE – дата рождения\r\n	(год, месяц, число.&lt;/p&gt;\r\n	&lt;p&gt;Написать\r\n	программу, выполняющую:&lt;/p&gt;\r\n	&lt;ul&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	ввод\r\n	с клавиатуры данных в массив BLOCK,\r\n	состоящий из 9 элементов типа NOTE1,\r\n	записи должны быть упорядочены по\r\n	инициалам;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	вывод\r\n	на экран информации о людях, чьи дни\r\n	рождения приходятся на месяц, значение\r\n	которого введено с клавиатуры;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;если\r\n	такого человека нет – выдать сообщение.&lt;/p&gt;\r\n	&lt;/ul&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	6&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Описать\r\n	структуру с именем NOTE2, содержащую\r\n	поля: Name – фамилия и инициалы, TELE –\r\n	номер телефона, DATE – дата рождения\r\n	(год, месяц, число).&lt;/p&gt;\r\n	&lt;p&gt;Написать\r\n	программу, выполняющую:&lt;/p&gt;\r\n	&lt;ul&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	ввод\r\n	с клавиатуры данных в массив BLOCK2,\r\n	состоящий из 7 элементов типа NOTE1,\r\n	записи должны быть упорядочены по\r\n	первым трем цифрам номера телефона;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	вывод\r\n	на экран информации о человеке, чья\r\n	фамилия введена с клавиатуры;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;если\r\n	такого нет – выдать сообщение.&lt;/p&gt;\r\n	&lt;/ul&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	7&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Описать\r\n	структуру с именем PERSON, содержащую\r\n	поля: Name – фамилия и инициалы, FAC –\r\n	факультет, GROUP – группа, DATE – дата\r\n	поступления в ВУЗ (год, месяц, число).&lt;/p&gt;\r\n	&lt;p&gt;Написать\r\n	программу, выполняющую:&lt;/p&gt;\r\n	&lt;ul&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	ввод\r\n	с клавиатуры данных в массив VUZ,\r\n	состоящий из 10 элементов типа PERSON,\r\n	записи должны быть упорядочены по\r\n	дате поступления в ВУЗ;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;вывод\r\n	на экран информации о студентах,\r\n	упорядоченной по факультетам, группам,\r\n	дате поступления. В каждой группе\r\n	фамилии должны быть расположены в\r\n	алфавитном порядке.&lt;/p&gt;\r\n	&lt;/ul&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	8&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Описать\r\n	структуру с именем ZNAK, содержащую\r\n	поля: Name – фамилия и имя, ZOD – знак\r\n	зодиака, DATE – дата рождения (массив\r\n	из трех чисел: год, месяц, число).&lt;/p&gt;\r\n	&lt;p&gt;Написать\r\n	программу, выполняющую:&lt;/p&gt;\r\n	&lt;ul&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	ввод\r\n	с клавиатуры данных в массив MASS,\r\n	состоящий из 10 элементов типа ZNAK,\r\n	записи должны быть упорядочены по\r\n	дате дня рождения;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	вывод\r\n	на экран информации о людях, родившихся\r\n	под знаком зодиака, наименование\r\n	которых вводится с клавиатуры;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;если\r\n	такого нет – выдать сообщение.&lt;/p&gt;\r\n	&lt;/ul&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	9&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Структура\r\n	содержит информацию о дате и времени\r\n	некоторого события:&lt;/p&gt;\r\n	&lt;code&gt;\r\nstruct datetime\r\n\r\n{ unsigned short Year; // год\r\n\r\nunsigned short Month; // месяц\r\n\r\nunsigned short Day; // день\r\n\r\nunsigned short Hour; // часы\r\n\r\nunsigned short Minute; // минуты\r\n\r\nunsigned short Second; // секунды\r\n\r\n};\r\n&lt;/code&gt;\r\n	&lt;p&gt;\r\n	};&lt;/p&gt;\r\n	&lt;p&gt;Написать\r\n	программу, выполняющую:&lt;/p&gt;\r\n	&lt;ul&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	определение\r\n	размера структурированного объекта\r\n	в батах.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	записывает\r\n	предложенную структуру в виде битовой\r\n	структуры и определяет размеры.&lt;/p&gt;\r\n	&lt;/ul&gt;\r\n	&lt;p&gt;Сравните\r\n	результаты, сделайте вывод.&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	10&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Для\r\n	хранения данных о цветных дисплеях\r\n	описать структуру вида:&lt;/p&gt;\r\n	&lt;code&gt;\r\nstruct display\r\n\r\n{char mode[25]; // наименование модели\r\n\r\nint price; // цена\r\n\r\ndouble x_size; // размер по горизонтали\r\n\r\ndouble y_size; // размер по вертикали\r\n\r\nint optr;}; // оптическое разрешение\r\n&lt;/code&gt;\r\n	&lt;p&gt;Написать\r\n	функцию, создающую файл с данными о\r\n	дисплеях (данные вводить с клавиатуры)\r\n	из не менее восьми записей, осуществляющую\r\n	его сортировку по заданному параметру\r\n	(обязательный параметр – признак,\r\n	задающий критерий сортировки). Все\r\n	необходимые данные для функции должны\r\n	передаваться ей в качестве параметров.&lt;/p&gt;\r\n	&lt;p&gt;Использование\r\n	глобальных параметров не допускается.&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	11&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Описать\r\n	структуру с именем STUDENT, содержащую\r\n	поля:&lt;/p&gt;\r\n	&lt;ul&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	фамилия\r\n	и инициалы студента; номер группы;\r\n	успеваемость (массив из четырех оценок\r\n	на экзаменах в 5-бальной системе).&lt;/p&gt;\r\n	&lt;/ul&gt;\r\n	&lt;p&gt;Написать\r\n	функции:&lt;/p&gt;\r\n	&lt;ul&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	создания\r\n	массива 7 записей (структур) данных о\r\n	студентах (ввод данных с клавиатуры);&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	вычисления\r\n	среднего бала каждого студента;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	расположения\r\n	записей по убыванию среднего бала;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	вывода\r\n	сведений о студентах, имеющих оценки\r\n	только 4 и 5;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	удаления\r\n	из списка студента с минимальным\r\n	средним балом.&lt;/p&gt;\r\n	&lt;/ul&gt;\r\n	&lt;p&gt;Все\r\n	необходимые данные для функций должны\r\n	передаваться в качестве их параметров.\r\n	Использование глобальных параметров\r\n	не допускается. Создать проект, который\r\n	демонстрирует работу всех функций.&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	12&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Описать\r\n	структуру с именем TOVAR, содержащую\r\n	поля:&lt;/p&gt;\r\n	&lt;ul&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	название\r\n	товара; количество единиц товара;\r\n	стоимость товара; дата поступления\r\n	товара в виде структуры (год, месяц,\r\n	день).&lt;/p&gt;\r\n	&lt;/ul&gt;\r\n	&lt;p&gt;\r\n	Написать\r\n	функции:&lt;/p&gt;\r\n	&lt;ul&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	создания\r\n	массива SPISOK не более чем из 10 записей\r\n	(структур) данных о товарах (ввод\r\n	данных с клавиатуры);&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	вычисления\r\n	средней стоимости товара;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	расположения\r\n	записей по возрастанию стоимости\r\n	товаров;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	вывода\r\n	сведений о товарах, поступивших более\r\n	10 месяцев назад.&lt;/p&gt;\r\n	&lt;/ul&gt;\r\n	&lt;p&gt;Все\r\n	необходимые данные для функций должны\r\n	передаваться в качестве их параметров.\r\n	Использование глобальных параметров\r\n	не допускается. Создать проект, который\r\n	демонстрирует работу всех функций.&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	13&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Описать\r\n	структуру с именем MARSHRUT, содержащую\r\n	поля:&lt;/p&gt;\r\n	&lt;ul&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	номер\r\n	маршрута; начальный пункт маршрута;\r\n	конечный пункт маршрута; длина\r\n	маршрута.&lt;/p&gt;\r\n	&lt;/ul&gt;\r\n	&lt;p&gt;Написать\r\n	функции:&lt;/p&gt;\r\n	&lt;ul&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	создания\r\n	массива не более чем из 10 записей\r\n	(структур) сведений о маршрутах (ввод\r\n	данных с клавиатуры);&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	определения\r\n	маршрута с максимальной длиной;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	расположения\r\n	записей по возрастанию номеров\r\n	маршрутов;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	вывода\r\n	сведений о маршрутах, которые начинаются\r\n	или заканчиваются в пункте, название\r\n	которого вводится с клавиатуры.&lt;/p&gt;\r\n	&lt;/ul&gt;\r\n	&lt;p&gt;Все\r\n	необходимые данные для функций должны\r\n	передаваться в качестве их параметров.\r\n	Использование глобальных параметров\r\n	не допускается. Создать проект, который\r\n	демонстрирует работу всех функций.&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	14&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Описать\r\n	структуру с именем ABON, содержащую\r\n	поля:&lt;/p&gt;\r\n	&lt;p&gt;фамилия\r\n	и инициалы абонента;&lt;/p&gt;\r\n	&lt;ul&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	номер\r\n	телефона;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	дата\r\n	подключения телефона в виде структуры\r\n	(год, месяц, день);&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	начисленная\r\n	сумма оплаты;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	сумма\r\n	на счету абонента.&lt;/p&gt;\r\n	&lt;/ul&gt;\r\n	&lt;p&gt;Написать\r\n	функции:&lt;/p&gt;\r\n	&lt;ul&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	создания\r\n	массива не более чем из 12 записей\r\n	(структур) данных об абонентах (ввод\r\n	данных с клавиатуры);&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	расположения\r\n	записей по алфавиту (с учетом инициалов\r\n	для абонентов с одинаковыми фамилиями;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	добавить\r\n	20 гр. на счета абонентов, которых\r\n	подключили более 10 лет назад;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	вывода\r\n	сведений об абонентах, у которых сумма\r\n	на счету отрицательная после вычета\r\n	начислений;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	вывода\r\n	сведений об абоненте, номер телефона\r\n	которого вводится с клавиатуры.&lt;/p&gt;\r\n	&lt;/ul&gt;\r\n	&lt;p&gt;Все\r\n	необходимые данные для функций должны\r\n	передаваться в качестве&lt;/p&gt;\r\n	&lt;p&gt;их\r\n	параметров. Использование глобальных\r\n	параметров не допускается. Создать\r\n	проект, который демонстрирует работу\r\n	всех функций.&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n&lt;/table&gt;\r\n&lt;p&gt;&lt;br/&gt;\r\n&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;p&gt;&lt;b&gt;Задание\r\n2.&lt;/b&gt;\r\nИспользуя встроенное перечисление\r\nConsoleKey\r\nв\r\nсвою программу возможность выводить\r\nданные после нажатия комбинации клавиш\r\nCtrl+(номер варианта).&lt;/p&gt;\r\n&lt;h1&gt;Домашнее\r\nзадание&lt;/h1&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;Metanit\r\n	C#,\r\n	работа со структурами и перечисления.&lt;/p&gt;\r\n&lt;/ol&gt;', 2);
INSERT INTO `labs` (`IDLab`, `StartNumber`, `EndNumber`, `Theme`, `Goal`, `Equipment`, `Content`, `IDStatus`) VALUES
(16, 13, 14, 'Разработка программ, реализующих механизм наследования', 'Обучить разработке программ, реализующих механизм наследования классов.', 'ПК, среда разработки Microsoft Visual Studio .NET. ', '&lt;h1&gt;МЕТОДИЧЕСКИЕ\r\nУКАЗАНИЯ&lt;/h1&gt;\r\n&lt;p&gt;\r\n&lt;b&gt;Классы&lt;/b&gt;&lt;b&gt;\r\n&lt;/b&gt;являются расширением\r\nструктурного типа. Синтаксис описания\r\nкласса:&lt;/p&gt;\r\n&lt;p&gt;\r\n[атрибуты][модификаторы]class\r\nимя_класса [:список_родителей] {тело_класса}&lt;/p&gt;\r\n&lt;p&gt;Модификаторы\r\nдоступа к членам классов:&lt;/p&gt;\r\n&lt;p&gt;\r\n&lt;b&gt;public&lt;/b&gt;\r\n– член доступен вне определения класса\r\nи иерархии производных классов.&lt;/p&gt;\r\n&lt;p&gt;\r\n&lt;b&gt;protected&lt;/b&gt;\r\n– член не видим за пределами класса, к\r\nнему могут обращаться только производные\r\nклассы.&lt;/p&gt;\r\n&lt;p&gt;\r\n&lt;b&gt;private&lt;/b&gt;\r\n– член не доступен за пределами области\r\nвидимости определяющего его класса.&lt;/p&gt;\r\n&lt;p&gt;\r\n&lt;b&gt;internal&lt;/b&gt;\r\n– член видим только в пределах текущей\r\nединицы компиляции.&lt;/p&gt;\r\n&lt;p&gt;\r\nОбычно\r\nкласс имеет модификатор доступа &lt;b&gt;public&lt;/b&gt;,\r\nявляющийся значением по умолчанию.\r\nМодификаторы &lt;b&gt;private&lt;/b&gt;\r\nи &lt;b&gt;protected &lt;/b&gt;используются\r\nдля вложенных классов.&lt;/p&gt;\r\n&lt;p&gt;\r\nВ\r\nтеле класса могут быть объявлены:\r\nконстанты, поля, конструкторы и\r\nдеструкторы, методы, события, делегаты,\r\nвложенные классы (структуры, интерфейсы,\r\nперечисления).&lt;/p&gt;\r\n&lt;p&gt;&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;p&gt;\r\n&lt;b&gt;Наследование\r\n&lt;/b&gt;\r\n&lt;/p&gt;\r\n&lt;p&gt;\r\nНаследование\r\n— это свойство, с помощью которого один\r\nобъект может приобретать свойства\r\nдругого. При этом поддерживается\r\nконцепция иерархической классификации,\r\nимеющей направление сверху вниз. \r\n&lt;/p&gt;\r\n&lt;p&gt;\r\nИспользуя\r\nнаследование, объект должен определить\r\nтолько те качества, которые делают его\r\nуникальным в пределах своего класса.\r\nОн может наследовать общие атрибуты от\r\nсвоих родительских классов. &lt;br/&gt;\r\nСинтаксис:\r\n&lt;/p&gt;\r\n&lt;code&gt;\r\nclass имя_класса : имя_родительского_класса\r\n\r\n{тело_класса}\r\n\r\nПример:\r\n\r\nclass Predator:Animal{\r\n\r\nprivate int Speed;\r\n\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;\r\nС\r\nпомощью наследования создается иерархия\r\nклассов (отношение ‘являться’). Кроме\r\nтого, можно построить еще одну структуру\r\n– иерархию объектов (тогда, когда один\r\nобъект является частью другого –\r\nотношение ‘часть-целое’).&lt;/p&gt;\r\n&lt;p&gt;\r\nЦель\r\nработы Изучение наследования как важного\r\nэлемента объектноориентированного\r\nпрограммирования и приобретение навыков\r\nреализации иерархии классов. \r\n&lt;/p&gt;\r\n&lt;p&gt;\r\n&lt;b&gt;Упражнение\r\n1.&lt;/b&gt; Реализация\r\nнаследования классов \r\n&lt;/p&gt;\r\n&lt;p&gt;Cоздать\r\nкласс с полями, указанными в индивидуальном\r\nзадании (табл. 2, столб 2).&lt;/p&gt;\r\n&lt;p&gt;Реализовать\r\nв классе методы:&lt;/p&gt;\r\n&lt;ul&gt;\r\n	&lt;li&gt;&lt;p&gt;конструктор\r\n	по умолчанию;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;конструктор\r\n	перезагрузки с параметрами;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;функции\r\n	обработки данных (1 и 2), указанные в\r\n	индивидуальном задании (табл. 2, столбцы\r\n	3 и 4);&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;функцию\r\n	формирования строки информации об\r\n	объекте.&lt;/p&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;\r\nСоздать\r\nпроект для демонстрации работы:\r\nсформировать объекты со значениями-константами\r\nи с введенными значениями полей. Выводить\r\nрезультаты в консоль.&lt;/p&gt;\r\n&lt;p&gt;Таблица\r\n1 – Варианты индивидуальных заданий.&lt;/p&gt;\r\n&lt;table&gt;\r\n	\r\n	\r\n	\r\n	\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	№&lt;/p&gt;\r\n	&lt;p&gt;вар.&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Класс-родитель\r\n	и&lt;/p&gt;\r\n	&lt;p&gt;его\r\n	поля&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Функция-метод\r\n	1&lt;/p&gt;\r\n	&lt;p&gt;обработки\r\n	данных&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Функция-метод\r\n	2 обработки данных&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	1&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Дата\r\n	(три числа):&lt;/p&gt;\r\n	&lt;p&gt;день,\r\n	месяц, год&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Определить,\r\n	является ли год високосным (кратным\r\n	4)&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Увеличить\r\n	дату на 5 дней&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	2&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Дата\r\n	(три числа):&lt;/p&gt;\r\n	&lt;p&gt;день,\r\n	месяц, год&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Увеличить\r\n	год на 1&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Уменьшить\r\n	дату на 2 дня&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	3&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Дата\r\n	(три числа):&lt;/p&gt;\r\n	&lt;p&gt;день,\r\n	месяц, год&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Определить,\r\n	совпадают ли номер месяца и число дня&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Увеличить\r\n	дату на один месяц&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	4&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Время\r\n	(три числа): часы, минуты, секунды&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Вычислить\r\n	количество секунд в указанном времени&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Увеличить\r\n	время на 5 секунд&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	5&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Время\r\n	(три числа): часы, минуты, секунды&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Вычислить\r\n	количество полных минут в указанном\r\n	времени&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Уменьшить\r\n	время на 10 минут&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	6&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Время\r\n	(три числа): часы, минуты, секунды&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Определить\r\n	количество минут до полуночи (24:00:00)&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Увеличить\r\n	время 100&lt;/p&gt;\r\n	&lt;p&gt;минут&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	7&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Координаты\r\n	изображения прямоугольника: x1, y1, x2,\r\n	y2&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Вычислить\r\n	длину диагонали прямоугольника в\r\n	пикселях&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Вычислить\r\n	площадь прямоугольника&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	8&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Координаты\r\n	изображения прямоугольника: x1, y1, x2,\r\n	y2&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Определить,\r\n	является ли прямоугольник квадратом?&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Вычислите\r\n	диагональ прямоугольника.&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	9&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Правильная\r\n	дробь: числитель, знаменатель&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Выразить\r\n	значение дроби в процентах&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Найти\r\n	сумму цифр значения знаменателя&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	10&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Книга:\r\n	название, количество страниц, цена&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Вычислить\r\n	среднюю стоимость одной страницы&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Увеличить\r\n	цену книги в два раза, если название\r\n	начинается со слова «Программирование»&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	11&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Книга:\r\n	название, автор, год издания&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Вычислить,\r\n	сколько лет книге&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Количество\r\n	дней, прошедших после года издания\r\n	книги&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	12&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Работник:\r\n	фамилия, оклад, год поступления на\r\n	работу&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Вычислить\r\n	стаж работы работника на данном\r\n	предприятии&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Сколько\r\n	дней прошло после года поступления\r\n	на работу&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	13&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Работник:\r\n	фамилия, оклад, год рождения&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Вычислить\r\n	возраст работника&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Сколько\r\n	календарных дней до исполнения\r\n	работнику 50 лет&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	14&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Вектор\r\n	на плоскости: координаты&lt;/p&gt;\r\n	&lt;p&gt;вектора\r\n	на плоскости (x1, y1, x2, y2)&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Вычислить\r\n	длину&lt;/p&gt;\r\n	&lt;p&gt;вектора&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Найдите\r\n	площадь квадрата со стороной равной\r\n	длине вектора.&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	15&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Вектор\r\n	на плоскости: координаты&lt;/p&gt;\r\n	&lt;p&gt;вектора\r\n	на плоскости (x1, y1, x2, y2)&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Вычислить\r\n	координаты середины вектора&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Равен\r\n	ли угол наклона вектора 45 градусов?&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n&lt;/table&gt;\r\n&lt;p&gt;&lt;strong&gt;Задание:&lt;/strong&gt;&lt;/p&gt;\r\n&lt;p&gt;Для\r\nкласса, созданного в предыдущем задании\r\n(по вариантам табл. 11.2)&lt;/p&gt;\r\n&lt;p&gt;создать\r\nкласс-потомок с полями, указанными в\r\nиндивидуальном задании (табл. 2,\r\nстолб 2).&lt;/p&gt;\r\n&lt;p&gt;Реализовать\r\nв классе-потомке методы:&lt;/p&gt;\r\n&lt;ul&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	конструктор;&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	функцию\r\n	обработки данных, указанную в\r\n	индивидуальном задании (табл.2, столб 3);&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	функцию\r\n	формирования строки информации об\r\n	объекте.&lt;/p&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Создать\r\nпроект для демонстрации работы: ввод и\r\nвывод информации об объектах:\r\nклассе-родителе и классе-потомке.&lt;/p&gt;\r\n&lt;p&gt;Таблица\r\n3\r\n– Варианты индивидуальных заданий&lt;/p&gt;\r\n&lt;table&gt;\r\n	\r\n	\r\n	\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Класс-родитель\r\n	и его поля&lt;/p&gt;\r\n	&lt;p&gt;(из\r\n	табл. 2)&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Класс-потомок\r\n	и его поля (поля класса родителя\r\n	выделены курсивом)&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Функция-метод\r\n	обработки данных объекта класса-потомка&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	1\r\n	Дата (три числа):&lt;/p&gt;\r\n	&lt;p&gt;день,\r\n	месяц, год&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Список\r\n	друзей: ФИО,&lt;/p&gt;\r\n	&lt;p&gt;телефон,\r\n	дата рождения.&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Количество\r\n	дней до дня&lt;/p&gt;\r\n	&lt;p&gt;очередного\r\n	рождения&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	2\r\n	Дата (три числа):&lt;/p&gt;\r\n	&lt;p&gt;день,\r\n	месяц, год&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Работник:\r\n	ФИО, дата поступления на предприятие&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Количество\r\n	лет работы на&lt;/p&gt;\r\n	&lt;p&gt;предприятии&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	3\r\n	Дата (три числа):&lt;/p&gt;\r\n	&lt;p&gt;день,\r\n	месяц, год&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Лекарство:\r\n	наименование, дата выпуска, фирма&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Сколько\r\n	прошло дней от&lt;/p&gt;\r\n	&lt;p&gt;изготовления\r\n	лекарства&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	4\r\n	Время (три числа):&lt;/p&gt;\r\n	&lt;p&gt;часы,\r\n	минуты,&lt;/p&gt;\r\n	&lt;p&gt;секунды&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Расписание\r\n	движения&lt;/p&gt;\r\n	&lt;p&gt;поездов:\r\n	номер поезда, направление, время\r\n	отправления&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Количество\r\n	минут до&lt;/p&gt;\r\n	&lt;p&gt;отправления\r\n	поезда с&lt;/p&gt;\r\n	&lt;p&gt;указанным\r\n	номером и введенное время&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	5\r\n	Время (три числа):&lt;/p&gt;\r\n	&lt;p&gt;часы,\r\n	минуты, секунды оператор, текущее\r\n	время&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Абонент\r\n	мобильной&lt;/p&gt;\r\n	&lt;p&gt;связи:\r\n	фамилия&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Определить,\r\n	является ли&lt;/p&gt;\r\n	&lt;p&gt;время\r\n	льготным для абонента (время от 0 до 8&lt;/p&gt;\r\n	&lt;p&gt;часов)&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	6\r\n	Координаты&lt;/p&gt;\r\n	&lt;p&gt;изображения&lt;/p&gt;\r\n	&lt;p&gt;прямоугольника:&lt;/p&gt;\r\n	&lt;p&gt;x1,\r\n	y1, x2, y2&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Изображение\r\n	конверта (прямоугольник с&lt;/p&gt;\r\n	&lt;p&gt;линиями\r\n	диагоналей):&lt;/p&gt;\r\n	&lt;p&gt;координаты\r\n	прямоугольника, цвет линий&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Площадь\r\n	верхнего (наддиагонального) треугольника\r\n	в пикселях&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	7\r\n	Время (три числа):&lt;/p&gt;\r\n	&lt;p&gt;часы,\r\n	минуты,&lt;/p&gt;\r\n	&lt;p&gt;секунды&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Расписание\r\n	занятий:&lt;/p&gt;\r\n	&lt;p&gt;дисциплина,\r\n	время&lt;/p&gt;\r\n	&lt;p&gt;начала,\r\n	аудитория&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Какая\r\n	дисциплина по&lt;/p&gt;\r\n	&lt;p&gt;расписанию\r\n	начинается в&lt;/p&gt;\r\n	&lt;p&gt;указанное\r\n	время&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	8\r\n	Координаты&lt;/p&gt;\r\n	&lt;p&gt;изображения&lt;/p&gt;\r\n	&lt;p&gt;прямоугольника:&lt;/p&gt;\r\n	&lt;p&gt;x1,\r\n	y1, x2, y2&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Изображение\r\n	прямоугольника с вписанным в его центр&lt;/p&gt;\r\n	&lt;p&gt;кругом:\r\n	координаты&lt;/p&gt;\r\n	&lt;p&gt;прямоугольника,&lt;/p&gt;\r\n	&lt;p&gt;радиус\r\n	круга R (R&lt; x2&lt;/p&gt;\r\n	&lt;p&gt;– x1,\r\n	R&lt; y2 – y1)&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Площадь\r\n	фигуры между&lt;/p&gt;\r\n	&lt;p&gt;прямоугольником\r\n	и&lt;/p&gt;\r\n	&lt;p&gt;кругом&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	9\r\n	Координаты&lt;/p&gt;\r\n	&lt;p&gt;изображения&lt;/p&gt;\r\n	&lt;p&gt;прямоугольника:&lt;/p&gt;\r\n	&lt;p&gt;x1,\r\n	y1, x2, y2&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Изображение\r\n	закрашенного прямоугольника с текстом:\r\n	координаты прямоугольника, заданный\r\n	текст,&lt;/p&gt;\r\n	&lt;p&gt;цвет\r\n	закрашивания&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Произведение\r\n	периметра&lt;/p&gt;\r\n	&lt;p&gt;и\r\n	длины диагонали&lt;/p&gt;\r\n	&lt;p&gt;прямоугольника\r\n	в пикселях&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	10\r\n	Правильная дробь:&lt;/p&gt;\r\n	&lt;p&gt;числитель,\r\n	знаменатель&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Смешанная\r\n	дробь:&lt;/p&gt;\r\n	&lt;p&gt;целая\r\n	часть, числитель и знаменатель&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Представить\r\n	смешанную&lt;/p&gt;\r\n	&lt;p&gt;дробь\r\n	в виде десятичного&lt;/p&gt;\r\n	&lt;p&gt;вещественного\r\n	числа.&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	13\r\n	Книга: название,&lt;/p&gt;\r\n	&lt;p&gt;количество\r\n	страниц, цена&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Библиотека:\r\n	название,&lt;/p&gt;\r\n	&lt;p&gt;количество\r\n	страниц,&lt;/p&gt;\r\n	&lt;p&gt;цена,\r\n	скидка в процентах&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Стоимость\r\n	книги с&lt;/p&gt;\r\n	&lt;p&gt;учетом\r\n	скидки.&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	14\r\n	Книга: название,&lt;/p&gt;\r\n	&lt;p&gt;автор,\r\n	год издания&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Книжный\r\n	магазин:&lt;/p&gt;\r\n	&lt;p&gt;название,\r\n	автор, год&lt;/p&gt;\r\n	&lt;p&gt;издания,\r\n	цена&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Уменьшить\r\n	стоимость&lt;/p&gt;\r\n	&lt;p&gt;книги\r\n	на 20%, если книге&lt;/p&gt;\r\n	&lt;p&gt;больше\r\n	5 лет.&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	15\r\n	Работник: фамилия,&lt;/p&gt;\r\n	&lt;p&gt;оклад,\r\n	год поступления на работу&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Работники\r\n	предприятия: фамилия, оклад,&lt;/p&gt;\r\n	&lt;p&gt;год\r\n	поступления на&lt;/p&gt;\r\n	&lt;p&gt;работу,\r\n	год рождения&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Определить,\r\n	сколько лет&lt;/p&gt;\r\n	&lt;p&gt;нужно\r\n	работать работнику до 60 лет, а если\r\n	ему&lt;/p&gt;\r\n	&lt;p&gt;больше\r\n	60, то сколько лет&lt;/p&gt;\r\n	&lt;p&gt;он\r\n	работает после 60 лет.&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n	&lt;tr&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	16\r\n	Работник: фамилия, оклад, год&lt;/p&gt;\r\n	&lt;p&gt;рождения&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Работники\r\n	фирмы:&lt;/p&gt;\r\n	&lt;p&gt;фамилия,\r\n	оклад, год&lt;/p&gt;\r\n	&lt;p&gt;рождения,\r\n	должность&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;td&gt;&lt;p&gt;\r\n	Увеличить\r\n	оклад работникам с должностью&lt;/p&gt;\r\n	&lt;p&gt;программист\r\n	на 20%.&lt;/p&gt;\r\n	&lt;/td&gt;\r\n	&lt;/tr&gt;\r\n&lt;/table&gt;\r\n&lt;p&gt;\r\n&lt;br/&gt;\r\n&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;p&gt;\r\n&lt;br/&gt;\r\n&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;p&gt;\r\n&lt;br/&gt;\r\n&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;p&gt;\r\n&lt;br/&gt;\r\n&lt;br/&gt;\r\n&lt;/p&gt;\r\n', 2),
(17, 15, 16, 'Разработка программ с использованием интерфейсов.', 'Сформировать умения разрабатывать интерфейсы, и использовать их в программах, применять механизм множественного наследования интерфейсов.', 'ПК, среда разработки Microsoft Visual Studio .NET. ', '&lt;p&gt;&lt;b&gt;Упражнение\r\n1.&lt;/b&gt;\r\nИспользование стандартных интерфейсов\r\nВ библиотеке классов .Net определено\r\nмножество стандартных интерфейсов,\r\nзадающих желаемую функциональность\r\nобъектов. В этом упражнении вы примените\r\nинтерфейс IComparable, который задает метод\r\nсравнения объектов по принципу больше\r\nи меньше, что позволяет переопределить\r\nсоответствующие операции в рамках\r\nкласса, наследующего интерфейс\r\nIComparable. \r\n&lt;/p&gt;\r\n&lt;p&gt;Требуется\r\nописать абстрактный базовый класс и\r\nпроизводные от него и создать массив\r\nобъектов производных классов. Обеспечить\r\nчитабельный вывод полей классов на\r\nэкран. Унаследовать интерфейсы для\r\nсоздания сортировки массива объектов\r\nпо всем полям и для создания копии\r\nмассива объектов.&lt;/p&gt;\r\n&lt;p&gt;\r\nИспользуя\r\nмеханизм виртуальных методов,\r\nпродемонстрировать единообразную\r\nработу с элементами массива. \r\n&lt;/p&gt;\r\n&lt;p&gt;&lt;strong&gt;Вариант 1&lt;/strong&gt;&lt;/p&gt;\r\n&lt;p&gt;\r\nСоздать\r\nабстрактный класс Figure. На его основе\r\nреализовать классы Rectangle (прямоугольник),\r\nCircle (круг) и Trapezium (трапеция) с возможностью\r\nвычисления площади, центра тяжести и\r\nпериметра.&lt;/p&gt;\r\n&lt;p&gt;\r\nСоздать\r\nкласс Picture, содержащий массив объектов\r\nэтих классов в динамической памяти.\r\nПредусмотреть возможность вывода\r\nхарактеристик объектов списка. Написать\r\nдемонстрационную программу, в которой\r\nбудут использоваться все методы классов.\r\n&lt;/p&gt;\r\n&lt;p&gt;&lt;strong&gt;Вариант 2&lt;/strong&gt;&lt;/p&gt;\r\n&lt;p&gt;\r\nСоздать\r\nабстрактный класс Number c виртуальными\r\nметодами, реализующими арифметические\r\nоперации. На его основе реализовать\r\nклассы Integer и Real.&lt;/p&gt;\r\n&lt;p&gt;\r\nСоздать\r\nкласс Series (набор), содержащий массив\r\nобъектов этих классов в динамической\r\nпамяти. Предусмотреть возможность\r\nвывода характеристик объектов списка.\r\nНаписать демонстрационную программу,\r\nв которой будут использоваться все\r\nметоды классов. \r\n&lt;/p&gt;\r\n&lt;p&gt;&lt;strong&gt;Вариант 3&lt;/strong&gt;&lt;/p&gt;\r\n&lt;p&gt;\r\nСоздать\r\nабстрактный класс Body. На его основе\r\nреализовать классы Parallelepiped (прямоугольный\r\nпараллелепипед), Cone (конус) и Ball (шар) с\r\nвозможностью вычисления площади\r\nповерхности и объема.&lt;/p&gt;\r\n&lt;p&gt;\r\nСоздать\r\nкласс Series (набор), содержащий массив\r\nобъектов этих классов в динамической\r\nпамяти. Предусмотреть возможность\r\nвывода характеристик объектов списка.\r\nНаписать демонстрационную программу,\r\nв которой будут использоваться все\r\nметоды классов. \r\n&lt;/p&gt;\r\n&lt;p&gt;&lt;strong&gt;Вариант 4&lt;/strong&gt;&lt;/p&gt;\r\n&lt;p&gt;\r\nСоздать\r\nабстрактный класс Currency для работы с\r\nденежными суммами. Определить в нем\r\nметоды перевода в рубли и вывода на\r\nэкран. На его основе реализовать классы\r\nDollar, Euro и Pound (фунт стерлингов) с возможностью\r\nпересчета в центы и пенсы соответственно.&lt;/p&gt;\r\n&lt;p&gt;\r\nСоздать\r\nкласс Purse (кошелек), содержащий массив\r\nобъектов этих классов в динамической\r\nпамяти. Предусмотреть возможность\r\nвывода  общей суммы, переведенной в\r\nрубли, и суммы по каждой из валют. Написать\r\nдемонстрационную программу, в которой\r\nбудут использоваться все методы классов.\r\n&lt;/p&gt;\r\n&lt;p&gt;&lt;strong&gt;Вариант 5&lt;/strong&gt;&lt;/p&gt;\r\n&lt;p&gt;\r\nСоздать\r\nабстрактный класс Solution (решение) с\r\nвиртуальными методами вычисления корней\r\nуравнения и вывода на экран. На его\r\nоснове реализовать классы Linear (линейное\r\nуравнение) и Square (квадратное уравнение).&lt;/p&gt;\r\n&lt;p&gt;\r\nСоздать\r\nкласс Series (набор), содержащий массив\r\nобъектов этих классов в динамической\r\nпамяти. Предусмотреть возможность\r\nвывода  характеристик объектов списка.\r\nНаписать демонстрационную программу,\r\nв которой будут использоваться все\r\nметоды классов. \r\n&lt;/p&gt;\r\n&lt;p&gt;&lt;strong&gt;Вариант 6&lt;/strong&gt;&lt;/p&gt;\r\n&lt;p&gt;\r\nСоздать\r\nабстрактный класс Function (функция) с\r\nвиртуальными методами вычисления\r\nзначения функции y =\r\nf(x)\r\nв заданной точке х\r\nи вывода результата на экран. На его\r\nоснове реализовать классы Ellipse, Hiperbola и\r\nParabola.&lt;/p&gt;\r\n&lt;p&gt;\r\nСоздать\r\nкласс Series (набор), содержащий массив\r\nобъектов этих классов в динамической\r\nпамяти. Предусмотреть возможность\r\nвывода характеристик объектов списка.\r\nНаписать демонстрационную программу,\r\nв которой будут использоваться все\r\nметоды классов. \r\n&lt;/p&gt;\r\n&lt;p&gt;&lt;strong&gt;Вариант 7&lt;/strong&gt;&lt;/p&gt;\r\n&lt;p&gt;\r\nСоздать\r\nабстрактный класс Worker с полями, задающими\r\nфамилию работника, фамилии руководителя\r\nи подчиненных и виртуальными методами\r\nвывода списка обязанностей и списка\r\nподчиненных на экран. На его основе\r\nреализовать классы Manager (руководитель\r\nпроекта), Developer (разработчик) и Coder (младший\r\nпрограммист).&lt;/p&gt;\r\n&lt;p&gt;\r\nСоздать\r\nкласс Group (группа), содержащий массив\r\nобъектов этих классов в динамической\r\nпамяти. Предусмотреть возможность\r\nвывода всех объектов списка и выборки\r\nпо фамилии с выводом всего дерева\r\nподчиненных. Написать демонстрационную\r\nпрограмму, в которой будут использоваться\r\nвсе методы классов. \r\n&lt;/p&gt;\r\n&lt;p&gt;&lt;strong&gt;Вариант 8&lt;/strong&gt;&lt;/p&gt;\r\n&lt;p&gt;\r\nСоздать\r\nабстрактный класс Progression (прогрессия)\r\nс виртуальными методами вычисления\r\nзаданного элемента и суммы прогрессии.\r\nНа его основе реализовать классы Linear\r\n(арифметическая) и Exponential (геометрическая).&lt;/p&gt;\r\n&lt;p&gt;Создать\r\nкласс Series (набор), содержащий массив\r\nобъектов этих классов в динамической\r\nпамяти. Предусмотреть возможность\r\nвывода характеристик объектов списка\r\nи вывода общей суммы всех прогрессий.\r\nНаписать демонстрационную программу,\r\nв которой будут использоваться все\r\nметоды классов.&lt;/p&gt;\r\n&lt;h1&gt;КОНТРОЛЬНЫЕ ВОПРОСЫ&lt;/h1&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Дайте\r\n	определение понятию «интерфейс».&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Назовите\r\n	основные отличия интерфейса от\r\n	абстрактного класса.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Скажите,\r\n	какой модификатор доступа соответствует\r\n	интерфейсу? \r\n	&lt;/p&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;&lt;br/&gt;\r\n&lt;/p&gt;\r\n&lt;h1&gt;ДОМАШНЕЕ ЗАДАНИЕ&lt;/h1&gt;\r\n&lt;ol&gt;\r\n	&lt;li&gt;&lt;p&gt;Павловская\r\n	Т.А. С#. Программирование на языке\r\n	высокого уровня .NET. – с. 138-164.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	Том\r\n	Арчер. Основы С#. –с. 178-200.&lt;/p&gt;\r\n	&lt;li&gt;&lt;p&gt;\r\n	ВИДЕОУРОКИ\r\n	metanit.com\r\n	видео С#. Урок 40-43.&lt;/p&gt;\r\n&lt;/ol&gt;', 2);

-- --------------------------------------------------------

--
-- Структура таблицы `lectures`
--

CREATE TABLE `lectures` (
  `IDLecture` int NOT NULL,
  `Name` varchar(200) COLLATE utf8mb4_general_ci NOT NULL,
  `IDChapter` int DEFAULT NULL,
  `SerialNumber` int NOT NULL,
  `IDStatus` int NOT NULL,
  `Content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;

--
-- Дамп данных таблицы `lectures`
--

INSERT INTO `lectures` (`IDLecture`, `Name`, `IDChapter`, `SerialNumber`, `IDStatus`, `Content`) VALUES
(1, 'Язык C# и платформа .NET&quot;', 1, 1, 2, '&lt;p&gt;На сегодняшний момент язык программирования C# один из самых мощных, быстро развивающихся и востребованных языков в ИТ-отрасли. В настоящий момент на нем пишутся самые различные приложения: от небольших десктопных программок до крупных веб-порталов и веб-сервисов, обслуживающих ежедневно миллионы пользователей.&lt;/p&gt;\r\n&lt;p&gt;C# уже не молодой язык и как и вся платформа .NET уже прошел большой путь. Первая версия языка вышла вместе с релизом Microsoft Visual Studio .NET в феврале 2002 года. Текущей версией языка является версия C# 10.0, которая вышла 8 ноября 2021 года вместе с релизом .NET 6.&lt;/p&gt;\r\n&lt;p&gt;C# является языком с Си-подобным синтаксисом и близок в этом отношении к C++ и Java. Поэтому, если вы знакомы с одним из этих языков, то овладеть C# будет легче.&lt;/p&gt;\r\n&lt;p&gt;C# является объектно-ориентированным и в этом плане много перенял у Java и С++. Например, C# поддерживает полиморфизм, наследование, перегрузку операторов, статическую типизацию. Объектно-ориентированный подход позволяет решить задачи по построению крупных, но в тоже время гибких, масштабируемых и расширяемых приложений. И C# продолжает активно развиваться, и с каждой новой версией появляется все больше интересных функциональностей.&lt;/p&gt;\r\n&lt;h3&gt;Роль платформы .NET&lt;/h3&gt;\r\n&lt;p&gt;Когда говорят C#, нередко имеют в виду технологии платформы .NET (Windows Forms, WPF, ASP.NET, Xamarin). И, наоборот, когда говорят .NET, нередко имеют в виду C#. Однако, хотя эти понятия связаны, отождествлять их неверно. Язык C# был создан специально для работы с фреймворком .NET, однако само понятие .NET несколько шире.&lt;/p&gt;\r\n&lt;p&gt;Как-то Билл Гейтс сказал, что платформа .NET - это лучшее, что создала компания Microsoft. Возможно, он был прав. Фреймворк .NET представляет мощную платформу для создания приложений. Можно выделить следующие ее основные черты:&lt;/p&gt;\r\n&lt;ul&gt;\r\n	&lt;li&gt;&lt;strong&gt;Поддержка нескольких языков.&lt;/strong&gt; Основой платформы является общеязыковая среда исполнения Common Language Runtime (CLR), благодаря чему .NET поддерживает несколько языков: наряду с C# это также VB.NET, C++, F#, а также различные диалекты других языков, привязанные к .NET, например, Delphi.NET. При компиляции код на любом из этих языков компилируется в сборку на общем языке CIL (Common Intermediate Language) - своего рода ассемблер платформы .NET. Поэтому при определенных условиях мы можем сделать отдельные модули одного приложения на отдельных языках.&lt;/li&gt;\r\n	&lt;li&gt;&lt;strong&gt;Кроссплатформенность.&lt;/strong&gt;.NET является переносимой платформой (с некоторыми ограничениями). Например, последняя версия платформы на данный момент - .NET 6 поддерживается на большинстве современных ОС Windows, MacOS, Linux. Используя различные технологии на платформе .NET, можно разрабатывать приложения на языке C# для самых разных платформ - Windows, MacOS, Linux, Android, iOS, Tizen.&lt;/li&gt;\r\n	&lt;li&gt;&lt;strong&gt;Мощная библиотека классов.&lt;/strong&gt; .NET представляет единую для всех поддерживаемых языков библиотеку классов. И какое бы приложение мы не собирались писать на C# - текстовый редактор, чат или сложный веб-сайт - так или иначе мы задействуем библиотеку классов .NET.&lt;/li&gt;\r\n	&lt;li&gt;&lt;strong&gt;Разнообразие технологий.&lt;/strong&gt; Общеязыковая среда исполнения CLR и базовая библиотека классов являются основой для целого стека технологий, которые разработчики могут задействовать при построении тех или иных приложений. Например, для работы с базами данных в этом стеке технологий предназначена технология ADO.NET и Entity Framework Core. Для построения графических приложений с богатым насыщенным интерфейсом - технология WPF и WinUI, для создания более простых графических приложений - Windows Forms. Для разработки кроссплатформенных мобильных и десктопных приложений - Xamarin/MAUI. Для создания веб-сайтов и веб-приложений - ASP.NET и т.д.\r\n&lt;p&gt;К этому стоит добавить активной развивающийся и набирающий популяность Blazor - фреймворк, который работает поверх .NET и который позволяет создавать веб-приложения как на стороне сервера, так и на стороне клиента. А в будущем будет поддерживать создание мобильных приложений и, возможно, десктоп-приложений.&lt;/p&gt;\r\n&lt;/li&gt;\r\n	&lt;li&gt;&lt;strong&gt;Производительность. &lt;/strong&gt;Согласно ряду тестов веб-приложения на .NET 6 в ряде категорий сильно опережают веб-приложения, построенные с помощью других технологий. Приложения на .NET 6 в принципе отличаются высокой производительностью.&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Также еще следует отметить такую особенность языка C# и фреймворка .NET, как автоматическая сборка мусора. А это значит, что нам в большинстве случаев не придется, \r\nв отличие от С++, заботиться об освобождении памяти. Вышеупомянутая общеязыковая среда CLR сама вызовет сборщик мусора и очистит память.&lt;/p&gt;\r\n&lt;h3&gt;.NET Framework и .NET 6&lt;/h3&gt;\r\n&lt;p&gt;Стоит отметить, что .NET долгое время развивался премущественно как платформа для Windows под названием .NET Framework. В 2019 вышла последняя версия этой платформы - \r\n.NET Framework 4.8. Она больше не развивается&lt;/p&gt;\r\n&lt;p&gt;С 2014 Microsoft стал развивать альтернативную платформу - .NET Core, которая уже предназначалась для разных платформ и должна была вобрать в себя все возможности устаревшего .NET \r\nFramework и добавить новую функциональность. Затем Microsoft последовательно выпустил ряд версий этой платформы: .NET Core 1, .NET Core 2, .NET Core 3, .NET 5. \r\nИ текущей версией является расматриваемая в этом руководстве платформа .NET 6.\r\nПоэтому следует различать .NET Framework, который предназначен преимущественно для Windows, и кросплатформенный .NET 6. \r\nВ данном руководстве речь будет идти о C# 10 в связке с .NET 6, поскольку это актуальная платформа.&lt;/p&gt;\r\n\r\n&lt;h3&gt;Управляемый и неуправляемый код&lt;/h3&gt;\r\n&lt;p&gt;Нередко приложение, созданное на C#, называют &lt;strong&gt;управляемым кодом&lt;/strong&gt; (managed code). Что это значит? А это значит, что данное приложение \r\nсоздано на основе платформы .NET и поэтому управляется общеязыковой средой CLR, которая загружает приложение и при необходимости очищает память. \r\nНо есть также приложения, например, созданные на языке С++, которые компилируются не в общий язык CIL, как C#, VB.NET или F#, а в обычный машинный код. В этом случае .NET не управляет приложением.&lt;/p&gt;\r\n&lt;p&gt;В то же время платформа .NET предоставляет возможности для взаимодействия с неуправляемым кодом..&lt;/p&gt;\r\n&lt;h3&gt;JIT-компиляция&lt;/h3&gt;\r\n&lt;p&gt;Как выше писалось, код на C# компилируется в приложения или сборки с расширениями exe или dll на языке CIL. Далее при запуске на выполнение подобного приложения \r\nпроисходит JIT-компиляция (Just-In-Time) в машинный код, который затем выполняется. При этом, поскольку наше приложение может быть большим и \r\nсодержать кучу инструкций, в текущий момент времени будет компилироваться лишь та часть приложения, к которой непосредственно идет обращение. Если \r\nмы обратимся к другой части кода, то она будет скомпилирована из CIL в машинный код. При том уже скомпилированная часть приложения сохраняется до завершения \r\nработы программы. В итоге это повышает производительность.&lt;/p&gt;\r\n&lt;p&gt;По сути это все, что вкратце надо знать о платформе .NET и языке C#. А теперь создадим первое приложение.&lt;/p&gt;\r\n\r\n'),
(2, 'Начало работы с Visual Studio. Первая программа', 1, 2, 2, '&lt;p&gt;Итак, создадим первое приложение на языке C#. Что для этого потребуется? Во-первых, нам нужен текстовый редактор, в котором мы могли бы напечатать код программы. Во-вторых, нам нужен компилятор, который бы скомпилировал набранный в текстовом редакторе код в приложение exe. В-третьих, нам нужен фреймворк .NET, который требуется для компиляции и выполнения программы.&lt;/p&gt;\r\n&lt;p&gt;Чтобы облегчить написание, а также тестирование и отладку программного кода обычно используют специальные среды разработки, в частности, Visual Studio.&lt;/p&gt;\r\n&lt;p&gt;Для создания приложений на C# будем использовать бесплатную и полнофункциональную среду разработки - Visual Studio Community 2022, которую можно загрузить по следующему адресу: &lt;a href=&quot;https://www.visualstudio.com/en-us/downloads&quot;&gt;Microsoft Visual Studio 2022&lt;/a&gt;.&lt;/p&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/1.7.png&quot; alt=&quot;image&quot;&gt;\r\n&lt;p&gt;Стоит отметить, что Visual Studio 2019 и все предыдущие версии Visual Studio не поддерживают .NET 6 и C# 10, необходима именно версия Visual Studio 2022.&lt;/p&gt;\r\n&lt;p&gt;После загрузки запустим программу установщика. В открывшемся окне нам будет предложено выбрать те компоненты, которые мы хотим установить вместе Visual Studio. Стоит отметить, что Visual Studio - очень функциональная среда разработки и позволяет разрабатывать приложения с помощью множества языков и платформ. В нашем случае нам будет интересовать прежде всего C# и .NET.&lt;/p&gt;\r\n&lt;p&gt;Чтобы добавить в Visual Studio поддержку проектов для C# и .NET 6, в программе установки среди рабочих нагрузок можно выбрать только пункт &lt;strong&gt;ASP.NET и разработка веб-приложений&lt;/strong&gt;. Можно выбрать и больше опций или вообще все опции, однако стоит учитывать свободный размер на жестком диске - чем больше опций будет выбрано, соответственно тем больше места на диске будет занято.&lt;/p&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/1.8.png&quot; alt=&quot;image&quot;&gt;\r\n&lt;p&gt;И при инсталляции Visual Studio на ваш компьютер будут установлены все необходимые инструменты для разработки программ, в том \r\nчисле фреймворк .NET 6.&lt;/p&gt;\r\n&lt;p&gt;После завершения установки создадим первую программу. Она будет простенькой. Вначале откроем Visual Studio. На стартовом экране выберем \r\n&lt;strong&gt;Create a new project&lt;/strong&gt; (Создать новый проект)&lt;/p&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/1.9.png&quot; alt=&quot;Создание первого проекта в Visual Studio 2022&quot;&gt;\r\n&lt;p&gt;На следующем окне в качестве типа проекта выберем &lt;strong&gt;Console App&lt;/strong&gt;, то есть мы будем создавать консольное приложение на языке \r\nC#&lt;/p&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/1.10.png&quot; alt=&quot;Проект консольного приложения на C# и .NET 6 в Visual Studio 2022&quot;&gt;\r\n&lt;p&gt;Далее на следующем этапе нам будет предложено указать имя проекта и каталог, где будет располагаться проект.&lt;/p&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/1.1.png&quot; alt=&quot;Создание первого приложения на C#&quot;&gt;\r\n&lt;p&gt;В поле &lt;strong&gt;Project Name&lt;/strong&gt; дадим проекту какое-либо название. В моем случае это &lt;strong&gt;HelloApp&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;p&gt;На следующем окне Visual Studio предложит нам выбрать версию .NET, которая будет использоваться для проекта. По умолчанию здесь выбрана последняя на данный момент версия - .NET 6.0. \r\nОставим и нажмен на кнопку Create (Создать) для создания проекта.&lt;/p&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/1.13.png&quot; alt=&quot;Установка C# 10 и .NET 6 в Visual Studio&quot;&gt;\r\n&lt;p&gt;После этого Visual Studio создаст и откроет нам проект:&lt;/p&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/1.2.png&quot; alt=&quot;Первый проект на C#&quot;&gt;\r\n&lt;p&gt;В большом поле в центре, которое по сути представляет текстовый редактор, находится сгенерированный по умолчанию код C#. Впоследствии \r\nмы изменим его на свой.&lt;/p&gt;\r\n&lt;p&gt;Справа находится окно Solution Explorer, в котором можно увидеть структуру нашего проекта. В данном случае у нас сгенерированная по умолчанию \r\nструктура: узел &lt;strong&gt;Dependencies&lt;/strong&gt; - это узел содержит сборки dll, которые добавлены в проект по умолчанию. \r\nЭти сборки как раз содержат классы библиотеки .NET, которые будет использовать C#. Однако не всегда все сборки нужны. Ненужные потом можно удалить, в то же время если понадобится добавить какую-нибудь нужную библиотеку, \r\nто именно в этот узел она будет добавляться.&lt;/p&gt;\r\n&lt;p&gt;Далее идет непосредственно сам файл кода программы &lt;strong&gt;Program.cs&lt;/strong&gt;, который по умолчанию открыт в центральном окне и \r\nкоторый имеет всего две строки:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\n// See https://aka.ms/new-console-template for more information\r\nConsole.WriteLine(&quot;Hello, World!&quot;);\r\n&lt;/code&gt;\r\n&lt;p&gt;Первая строка предваряется символами &lt;strong&gt;//&lt;/strong&gt; и представляет комментарии - пояснения к коду.&lt;/p&gt;\r\n&lt;p&gt;Вторая строка собственно представляет собой код программы: &lt;strong&gt;Console.WriteLine(&quot;Hello World!&quot;);&lt;/strong&gt;. Эта строка выводит на консоль строку &quot;Hello World!&quot;.&lt;/p&gt;\r\n&lt;p&gt;Несмотря на то, что программа содержит только одну строку кода, это уже некоторая программа, которую мы можем запустить. \r\nЗапустить проект мы можем с помощью клавиши F5 или с панели инструментов, нажав на зеленую стрелку. И если вы все сделали правильно, \r\nто при запуске приложения на консоль будет выведена строка &quot;Hello World!&quot;.&lt;/p&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/1.15.png&quot; alt=&quot;Первое приложение на C# и .NET 6&quot;&gt;\r\n&lt;p&gt;Теперь изменим весь этот код на следующий:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nConsole.Write(&quot;Введите свое имя: &quot;);\r\nstring? name = Console.ReadLine();      // вводим имя\r\nConsole.WriteLine($&quot;Привет {name}&quot;);    // выводим имя на консоль\r\n&lt;/code&gt;\r\n&lt;p&gt;По сравнению с автоматически сгенерированным кодом я внес несколько изменений. Теперь первой строкой выводится приглашение к вводу.&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nConsole.Write(&quot;Введите свое имя: &quot;);\r\n&lt;/code&gt;\r\n&lt;p&gt;Метод &lt;strong&gt;Console.Write()&lt;/strong&gt; выводит на консоль некоторую строка. В данном случае это строка &quot;Введите свое имя: &quot;.&lt;/p&gt;\r\n&lt;p&gt;На второй строке определяется строковая переменная name, в которую пользователь вводит информацию с консоли:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nstring? name = Console.ReadLine();\r\n&lt;/code&gt;\r\n&lt;p&gt;Переменной &lt;strong&gt;name&lt;/strong&gt; присваивается результат метода &lt;strong&gt;Console.ReadLine()&lt;/strong&gt;, который\r\nпозволяет считать с консоли введенную строку. То есть мы введем в консоли строку (точнее имя), и эта строка окажется в переменой &lt;strong&gt;name&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;p&gt;Выражение &lt;strong&gt;string? name&lt;/strong&gt; указывает, что определяется переменная &lt;strong&gt;name&lt;/strong&gt; типа &lt;strong&gt;string?&lt;/strong&gt;, то есть переменная, которая может хранить строки. \r\nЗдесь &lt;strong&gt;string&lt;/strong&gt; указывает, что переменная может хранить значения типа &lt;strong&gt;string&lt;/strong&gt;, то есть строки. \r\nА знак вопроса &lt;strong&gt;?&lt;/strong&gt; указывает, что переменная также может хранить значение &lt;strong&gt;null&lt;/strong&gt;, то есть \r\nпо сути не иметь никакого значения.&lt;/p&gt;\r\n&lt;p&gt;Затем введенное имя выводится на консоль:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nConsole.WriteLine($&quot;Привет {name}&quot;);\r\n&lt;/code&gt;\r\n&lt;p&gt;Чтобы ввести значение переменной name внутрь выводимой на консоль строки, применяются фигурные скобки {}. То есть при выводе строки на консоль \r\nвыражение &lt;strong&gt;{name}&lt;/strong&gt; будет заменяться на значение переменной name - введенное имя.&lt;/p&gt;\r\n&lt;p&gt;Однако чтобы можно было вводить таким образом значения переменных внутрь строки, перед строкой указывается знак доллара $.&lt;/p&gt;\r\n&lt;p&gt;Теперь протестируем проект, запустив его на выполнение, также нажав на F5 или зеленую стрелочку.&lt;/p&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/1.6.png&quot; alt=&quot;Первая программа на C#&quot;&gt;\r\n&lt;p&gt;Итак, мы создали первое приложение. Вы его можете найти на жестком диске в папке проекта. Оно будет называться по имени проекта и иметь расширение exe. \r\nИ затем этот файл можно будет запускать без Visual Studio, а также переносить его на другие компьютеры, где установлен .NET 6.&lt;/p&gt;'),
(3, 'Компиляция в командной строке', 1, 3, 2, '&lt;p&gt;Как правило, для создания программ на C# разработчики используют Visual Studio или какие-то другие IDE типа Rider от компании JetBrains. Но все подобные IDE, хотя и облегчают разработку, в то же время скрывают множество мельчайших подробностей по созданию программ. И в реальности мы даже можем обойтись без той же Visual Studio, используя только инфраструктуру .NET CLI. Рассмотрим, как использовать .NET CLI и компилировать приложение из командной строки.&lt;/p&gt;\r\n&lt;p&gt;Поэтому создадим на диске C какую-нибудь новую папку для проекта. Например, пусть мы создали для проекта папку C:dotnethelloapp. Откроем командную строку и с помощью команды cd перейдем к этой папке.&lt;/p&gt;\r\n&lt;img src=&quot;https://sun9-45.userapi.com/impg/jqQK5RGR_Gam6BrIPzYvGMD7Yd6nd1cFUd-4Ew/54XsKG4IS1s.jpg?size=318x28&amp;quality=96&amp;sign=6caf5e87f44774a6e732fa7608610d2b&amp;type=album&quot; alt=&quot;image&quot;&gt;\r\n&lt;p&gt;Для создания проекта в .NET CLI применяется команда &lt;strong&gt;dotnet new&lt;/strong&gt;, которой передается название проекта. Итак, в введем в командной строке следующую команду:&lt;/p&gt;\r\n&lt;img src=&quot;https://sun9-8.userapi.com/impg/j9DlS1W5F_Q1oLaFDSuOUFA_rCs_EnbTc7KJvQ/1G1IFCFPL18.jpg?size=259x26&amp;quality=96&amp;sign=c14748e98144cc3a2cddc6ff8eb2e232&amp;type=album&quot; alt=&quot;image&quot;&gt;\r\n&lt;p&gt;В данном случае мы указываем, что создаваемый проект будет представлять консольное приложение.&lt;/p&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/1.14.png&quot; alt=&quot;image&quot;&gt;\r\n&lt;p&gt;После выполнения этой команды в папке helloapp будет создан проект с минимальным набором стандартных файлов и папок.&lt;/p&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/1.5.png&quot; alt=&quot;image&quot;&gt;\r\n&lt;p&gt;В частности, мы можем найти в папке проекта файл &lt;strong&gt;helloapp.csproj&lt;/strong&gt;. Это главный файл проекта, который определяет его \r\nконфигурацию. Мы можем открыть его в любом текстовом редакторе, просмотреть и  при необходимости изменить.&lt;/p&gt;\r\n&lt;p&gt;И, кроме того, по умолчанию создается главный файл программы &lt;strong&gt;Program.cs&lt;/strong&gt; со следующим содержимым:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\n// See https://aka.ms/new-console-template for more information\r\nConsole.WriteLine(&quot;Hello, World!&quot;);\r\n&lt;/code&gt;\r\n&lt;p&gt;Соответственно, если нам надо внести изменения в исходный код программы, то мы будем изменять содержимое именно этого файла.&lt;/p&gt;\r\n&lt;p&gt;В принципе этот минимальный проект уже можно запускать. Для запуска проекта введем в командной строке следующую команду:&lt;/p&gt;\r\n&lt;img src=&quot;https://sun9-44.userapi.com/impf/IpzK8lL7w1oMNevi2QMyVhOUCFI_F1MKMLcxIg/J36hrTjiV7Q.jpg?size=146x36&amp;quality=96&amp;sign=4478d53c80c5f37fb1483100ca7a557e&amp;type=album&quot; alt=&quot;image&quot;&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/1.11.png&quot; alt=&quot;Компиляция программы на C# из командной строки&quot;&gt;\r\n&lt;p&gt;После выполнения команды в проекте в папке binMCDDebug\r\net6.0 появится файл программы helloapp.exe, который можно вручную запустить на компьютере, где установлен .NET 6.&lt;/p&gt;'),
(4, 'Структура программы', 2, 1, 2, '&lt;p&gt;Весь код программы на языке C# помещается в файлы с расширением &lt;strong&gt;.cs&lt;/strong&gt;. По умолчанию в проекте, который создается в \r\nVisual Studio (а также при использовании .NET CLI) уже есть один файл с кодом C# - файл &lt;strong&gt;Program.cs&lt;/strong&gt; со следующим содержимым:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\n// See https://aka.ms/new-console-template for more information\r\nConsole.WriteLine(&quot;Hello, World!&quot;);\r\n&lt;/code&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/2.14.png&quot; alt=&quot;Выполнение программы на языке программирования C#&quot;&gt;\r\n&lt;p&gt;Именно код файла &lt;strong&gt;Program.cs&lt;/strong&gt; выполняется по умолчанию, если мы запустим проект на выполнение. Но при \r\nнеобходимости мы также можем добавлять другие файлы с кодом C#.&lt;/p&gt;\r\n&lt;h3&gt;Инструкции&lt;/h3&gt;\r\n&lt;p&gt;Базовым строительным блоком программы являются &lt;strong&gt;инструкции&lt;/strong&gt; (statement). Инструкция представляет некоторое \r\nдействие, например, арифметическую операцию, вызов метода, объявление переменной и присвоение ей значения. В конце каждой инструкции \r\nв C# ставится точка с запятой (;). Данный знак указывает компилятору на конец инструкции. Например, в проекте консольного приложения, который создается по умолчанию, есть такая строка:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nConsole.WriteLine(&quot;Hello, World!&quot;);\r\n&lt;/code&gt;\r\n&lt;p&gt;Данная строка представляет вызов метода &lt;strong&gt;Console.WriteLine&lt;/strong&gt;, который выводит на консоль строку. В данном случае вызов метода является \r\nинструкцией и поэтому завершается точкой с запятой.&lt;/p&gt;\r\n&lt;p&gt;Набор инструкций может объединяться в блок кода. Блок кода заключается в фигурные скобки, а инструкции помещаются между открывающей и \r\nзакрывающей фигурными скобками. Например, изменим код файла &lt;strong&gt;Program.cs&lt;/strong&gt; на следующий:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\n{\r\n    Console.WriteLine(&quot;Привет&quot;);\r\n    Console.WriteLine(&quot;Добро пожаловать в C#&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/2.15.png&quot; alt=&quot;Блок кода на языке программирования C#&quot;&gt;\r\n&lt;p&gt;Здесь блок кода содержит две инструкции. И при выполении этого кода, консоль выведет две строки&lt;/p&gt;\r\n&lt;img src=&quot;https://sun9-71.userapi.com/impf/gt0YrmqiW1oLH1RwOKwDeTBYHvi08HD022ZkgA/cShBH51Bi6w.jpg?size=202x59&amp;quality=96&amp;sign=426d5cea3ffaa317170f77f710db4c74&amp;type=album&quot; alt=&quot;image&quot;&gt;\r\n&lt;p&gt;В данном блоке кода две инструкции, которые выводят на консоль определенную строку.&lt;/p&gt;\r\n&lt;p&gt;Одни блоки кода могут содержать другие блоки:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\n{\r\n    Console.WriteLine(&quot;Первый блок&quot;);\r\n    {\r\n        Console.WriteLine(&quot;Второй блок&quot;);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;h3&gt;Регистрозависимость&lt;/h3&gt;\r\n&lt;p&gt;C# является регистрозависимым языком. Это значит, в зависимости от регистра символов какое-то определенные названия может представлять разные классы, методы, \r\nпеременные и т.д. Например, для вывода на консоль используется метод &lt;strong&gt;WriteLine&lt;/strong&gt; - его имя начинается именно с \r\nбольшой буквы: &quot;WriteLine&quot;. Если мы вместо &quot;Console.WriteLine&quot; напишем &quot;Console.writeline&quot;, то программа \r\nне скомпилируется, так как данный метод обязательно должен называться &quot;WriteLine&quot;, а не &quot;writeline&quot; или &quot;WRITELINE&quot; или как-то иначе.&lt;/p&gt;\r\n&lt;h3&gt;Комментарии&lt;/h3&gt;\r\n&lt;p&gt;Важной частью программного кода являются комментарии. Они не являются собственно частью программы, при компиляции они игнорируются. \r\nТем не менее комментарии делают код программы более понятным, помогая понять те или иные его части.&lt;/p&gt;\r\n&lt;p&gt; есть два типа комментариев: однострочный и многострочный. Однострочный комментарий размещается на одной строке после двойного слеша \r\n//. А многострочный комментарий заключается между символами /* текст комментария */. Он может размещаться на нескольких строках. \r\nНапример:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\n/*\r\n       первая программа на C#,\r\n       которая выводит приветствие на консоль\r\n*/\r\nConsole.WriteLine(&quot;Привет&quot;);                // Выводим строку &quot;Привет&quot;\r\nConsole.WriteLine(&quot;Добро пожаловать в C#&quot;); // Выводим строку &quot;Добро пожаловать в C#&quot;\r\n&lt;/code&gt;\r\n&lt;h3&gt;Файл проекта&lt;/h3&gt;\r\n&lt;p&gt;В каждом проекте проекте C# есть файл, который отвечает за общую конфгурацию проекта. По умолчанию этот файл называется &lt;strong&gt;Название_проекта.csproj&lt;/strong&gt;. \r\nИтак, откроем данный файл. Для этого либо двойным кликом левой кнопкой мыши нажмем на название проекта, либо нажмем на название проекта правой кнопкой мыши и в появившемся меню выберем пункт \r\n&lt;strong&gt;Edit Project File&lt;/strong&gt;&lt;/p&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/2.18.png&quot; alt=&quot;Файл проекта в C# в Visual Studio&quot;&gt;\r\n&lt;p&gt;После этого Visual Studio откроет нам файл проекта, который будет выглядеть следующим образом:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\n&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;\r\n \r\n  &lt;PropertyGroup&gt;\r\n    &lt;OutputType&gt;Exe&lt;/OutputType&gt;\r\n    &lt;TargetFramework&gt;net6.0&lt;/TargetFramework&gt;\r\n    &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;\r\n    &lt;Nullable&gt;enable&lt;/Nullable&gt;\r\n  &lt;/PropertyGroup&gt;\r\n \r\n&lt;/Project&gt;\r\n&lt;/code&gt;\r\n&lt;p&gt;Этот файл в виде кода xml определяет конфгурацию проекта и он может содержать множество элементов. Остановлюсь только на двух основных:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;OutputType&lt;/strong&gt;: определяет выходной тип проекта. Это может быть выполняемое приложение в виде файла с расширением \r\n&lt;strong&gt;exe&lt;/strong&gt;, которое запускается по нажатию. И также это может быть файл с расширением &lt;strong&gt;.dll&lt;/strong&gt; - некоторый набор функциональностей, \r\nкоторый используется другими проектами. По умолчанию здесь установлено значение &quot;Exe&quot;, что значит, что мы создаем исполняемое приложение.&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;TargetFramework&lt;/strong&gt;: определяет применяемую для компиляции версию фреймворка .NET. \r\nВ данном случае это значение &quot;net6.0&quot;, то есть применяется .NET 6.0.&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;На самых ранних этапах этот файл может не понадобиться, однако впоследствии может потребоваться внести некоторые изменения в конфигурацию, и \r\nтогда может возникнуть потребность в обращении к этому файлу.&lt;/p&gt;\r\n'),
(5, 'Переменные и константы', 2, 2, 2, '&lt;p&gt;Для хранения данных в программе применяются &lt;strong&gt;переменные&lt;/strong&gt;. Переменная представляет именнованную область памяти, \r\nв которой хранится значение определенного типа. Переменная имеет тип, имя и значение. Тип определяет, какого рода информацию может хранить переменная.&lt;/p&gt;\r\n&lt;p&gt;Перед использованием любую переменную надо определить. Синтаксис определения переменной выглядит следующим образом:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nтип имя_переменной;\r\n&lt;/code&gt;\r\n&lt;p&gt;Вначале идет тип переменной, потом ее имя. В качестве имени переменной может выступать любое произвольное название, которое удовлетворяет следующим требованиям:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;имя может содержать любые цифры, буквы и символ подчеркивания, при этом первый символ в имени должен быть буквой или символом подчеркивания&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;в имени не должно быть знаков пунктуации и пробелов&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;имя не может быть ключевым словом языка C#. Таких слов не так много, и при работе в Visual Studio среда разработки подсвечивает ключевые слова синим цветом.&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Хотя имя переменой может быть любым, но следует давать переменным описательные имена, которые будут говорить об их предназначении.&lt;/p&gt;\r\n&lt;p&gt;Например, определим простейшую переменную:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nstring name;\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае определена переменная name, которая имеет тип &lt;strong&gt;string&lt;/strong&gt;. то есть переменная представляет строку. Поскольку определение переменной представляет \r\nсобой инструкцию, то после него ставится точка с запятой.&lt;/p&gt;\r\n&lt;p&gt;При этом следует учитывать, что C# является регистрозависимым языком, поэтому следующие два определения переменных будут представлять две разные переменные:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nstring name;\r\nstring Name;\r\n&lt;/code&gt;\r\n&lt;p&gt;После определения переменной можно присвоить некоторое значение:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nstring name;\r\nname = &quot;Tom&quot;;\r\n&lt;/code&gt;\r\n&lt;p&gt;Так как переменная name представляет тип string, то есть строку, то мы можем присвоить ей строку в двойных кавычках. Причем переменной можно присвоить только то значение, \r\nкоторое соответствует ее типу.&lt;/p&gt;\r\n&lt;p&gt;В дальнейшем с помощью имени переменной мы сможем обращаться к той области памяти, в которой хранится ее значение.&lt;/p&gt;\r\n&lt;p&gt;Также мы можем сразу при определении присвоить переменной значение. Данный прием называется инициализацией:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nstring name = &quot;Tom&quot;;\r\n&lt;/code&gt;\r\n&lt;p&gt;Отличительной чертой переменных является то, что в программе можно многократно менять их значение. Например, создадим небольшую программу, \r\nв которой определим переменную, поменяем ее значение и выведем его на консоль:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nstring name = &quot;Tom&quot;;  // определяем переменную и инициализируем ее\r\n  \r\nConsole.WriteLine(name);    // Tom\r\n  \r\nname = &quot;Bob&quot;;       // меняем значение переменной\r\nConsole.WriteLine(name);    // Bob\r\n&lt;/code&gt;\r\n&lt;p&gt;Консольный вывод программы:&lt;/p&gt;\r\n\r\n&lt;pre class=&quot;consoletext&quot; style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Tom\r\nBob\r\n&lt;/pre&gt;\r\n\r\n&lt;h3&gt;Константы&lt;/h3&gt;\r\n&lt;p&gt;Отличительной особенностью переменных является то, что мы можем изменить их значение в процессе работы программы. Но, кроме того, в \r\nC# есть константы. &lt;strong&gt;Константа&lt;/strong&gt; должна быть обязательно инициализирована при определении, и после определения значение константы не может быть изменено&lt;/p&gt;\r\n&lt;p&gt;Константы предназначены для описания таких значений, которые не должны изменяться в программе. Для определения констант используется \r\nключевое слово &lt;strong&gt;const&lt;/strong&gt;, которое указывается перед типом константы:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nconst string NAME = &quot;Tom&quot;;  // определяем константу\r\n&lt;/code&gt;\r\n&lt;p&gt;Так, в данном случае определена константа &lt;strong&gt;NAME&lt;/strong&gt;, которая хранит строку &quot;Tom&quot;. Нередко для название констант используется верхний регистр, но это не более чем условность.&lt;/p&gt;\r\n&lt;p&gt;При использовании констант надо помнить, что объявить мы их можем только один раз и что к моменту компиляции они должны быть определены. Так, в следующем случае мы получим ошибку, так как \r\nконстанте не присвоено начальное значение:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nconst string NAME;  // ! Ошибка - константа NAME не инициализирована\r\n&lt;/code&gt;\r\n&lt;p&gt;Кроме того, мы ее не сможем изменим в процессе работы программы:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nconst string NAME = &quot;Tom&quot;;  // определяем константу\r\nNAME = &quot;Bob&quot;;   // !Ошибка - у констаты нельзя изменить значение\r\n&lt;/code&gt;\r\n&lt;p&gt;Таким образом, если нам надо хранить в программе некоторые данные, но их не следует изменить, они определяются в виде констант. Если же их можно изменять, то они определяются в виде переменных.&lt;/p&gt;'),
(6, 'Литералы', 2, 3, 2, '&lt;p&gt;Литералы представляют неизменяемые значения (иногда их еще называют константами). Литералы можно передавать переменным в качестве значения. \r\nЛитералы бывают логическими, целочисленными, вещественными, символьными и строчными. И отдельный литерал представляет ключевое слово &lt;strong&gt;null&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;h3&gt;Логические литералы&lt;/h3&gt;\r\n&lt;p&gt;Есть две логических константы - &lt;strong&gt;true&lt;/strong&gt; (истина) и &lt;strong&gt;false&lt;/strong&gt; (ложь):&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nConsole.WriteLine(true);\r\nConsole.WriteLine(false);\r\n&lt;/code&gt;\r\n&lt;h3&gt;Целочисленные литералы&lt;/h3&gt;\r\n&lt;p&gt;Целочисленные литералы представляют положительные и отрицательные целые числа, например, 1, 2, 3, 4, -7, -109. \r\nЦелочисленные литералы могут быть выражены в десятичной, шестнадцатеричной и двоичной форме.&lt;/p&gt;\r\n&lt;p&gt;С целыми числами в десятичной форме все должно быть понятно, так как они используются в повседневной жизни:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nConsole.WriteLine(-11);\r\nConsole.WriteLine(5);\r\nConsole.WriteLine(505);\r\n&lt;/code&gt;\r\n&lt;p&gt;Числа в двоичной форме предваряются символами 0b, после которых идет набор из нулей и единиц:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nConsole.WriteLine(0b11);        // 3\r\nConsole.WriteLine(0b1011);      // 11\r\nConsole.WriteLine(0b100001);    // 33\r\n&lt;/code&gt;\r\n&lt;p&gt;Для записи числа в шестнадцатеричной форме применяются символы 0x, после которых идет набор символов от 0 до 9 и от A до F, которые собственно представляют число:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nConsole.WriteLine(0x0A);    // 10\r\nConsole.WriteLine(0xFF);    // 255\r\nConsole.WriteLine(0xA1);    // 161\r\n&lt;/code&gt;\r\n&lt;h3&gt;Вещественные литералы&lt;/h3&gt;\r\n&lt;p&gt;Вещественные литералы представляют дробные числа. Этот тип литералов имеет две формы. Первая форма - вещественные числа с \r\nфиксированной запятой, при которой дробную часть отделяется от целой части точкой. Например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\n3.14\r\n100.001\r\n-0.38\r\n&lt;/code&gt;\r\n&lt;p&gt;Также вещественные литералы могут определяться в экспоненциальной форме MEp, где M — мантисса, E - экспонента, которая фактически означает &quot;*10^&quot; (умножить на десять в степени), \r\nа p — порядок. Например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nConsole.WriteLine(3.2e3);   // по сути равно 3.2 * 10&lt;sup&gt;3&lt;/sup&gt; = 3200\r\nConsole.WriteLine(1.2E-1);  // равно 1.2 * 10&lt;sup&gt;-1&lt;/sup&gt; = 0.12\r\n&lt;/code&gt;\r\n&lt;h3&gt;Символьные литералы&lt;/h3&gt;\r\n&lt;p&gt;Символьные литералы представляют одиночные символы. Символы заключаются в одинарные кавычки.&lt;/p&gt;&lt;p&gt;\r\n&lt;/p&gt;&lt;p&gt;Символьные литералы бывают нескольких видов. Прежде всего это обычные символы:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\n&#039;2&#039;\r\n&#039;A&#039;\r\n&#039;T&#039;\r\n&lt;/code&gt;\r\n&lt;p&gt;Также мы можем передать их вывести на консоль с помощью &lt;strong&gt;Console.WriteLine&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nConsole.WriteLine(&#039;2&#039;);\r\nConsole.WriteLine(&#039;A&#039;);\r\nConsole.WriteLine(&#039;T&#039;);\r\n&lt;/code&gt;\r\n&lt;p&gt;Специальную группу представляют &lt;strong&gt;управляющие последовательности&lt;/strong&gt; Управляющая последовательность представляет символ, перед которым ставится слеш. И данная последовательность интерпретируется определенным образом. Наиболее часто используемые последовательности:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;&#039;\\n&#039;&lt;/strong&gt; - перевод строки&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;&#039;	&#039;&lt;/strong&gt; - табуляция&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;&#039;&#039;&lt;/strong&gt; - слеш&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;И если компилятор встретит в тексте последовательность 	, то он будет воспринимать эту последовательность не как слеш и букву t, а как табуляцию - то есть длинный отступ.&lt;/p&gt;\r\n&lt;p&gt;Также символы могут определяться в виде шестнадцатеричных кодов, также заключенный в одинарные кавычки.&lt;/p&gt;\r\n&lt;p&gt;Еще один способ определения символов представляет использования шестнадцатеричных кодов ASCII. Для этого в одинарных кавычках указываются символы &#039;x&#039;, после которых \r\nидет шестнадцатеричный код символа из таблицы ASCII. Коды символов из таблицы ASCII можно посмотреть &lt;a href=&quot;http://www.asciitable.com/&quot; rel=&quot;nofollow&quot;&gt;здесь&lt;/a&gt;.&lt;/p&gt;\r\n&lt;p&gt;Например, литерал &#039;x78&#039; представляет символ &quot;x&quot;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nConsole.WriteLine(&#039;x78&#039;);    // x\r\nConsole.WriteLine(&#039;x5A&#039;);    // Z\r\n&lt;/code&gt;\r\n&lt;p&gt;И последний способ определения символьных литералов представляет применение кодов из таблицы символов &lt;a href=&quot;https://unicode-table.com/ru/&quot; rel=&quot;nofollow&quot;&gt;Unicode&lt;/a&gt;. \r\nДля этого в одинарных кавычках указываются символы &#039;u&#039;, после которых идет шестнадцатеричный код Unicode. Например, код \r\n&#039;u0411&#039; представляет кириллический символ &#039;Б&#039;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nConsole.WriteLine(&#039;u0420&#039;);    // Р\r\nConsole.WriteLine(&#039;u0421&#039;);    // С\r\n&lt;/code&gt;\r\n&lt;h3&gt;Строковые литералы&lt;/h3&gt;\r\n&lt;p&gt;Строковые литералы представляют строки. Строки заключаются в двойные кавычки:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nConsole.WriteLine(&quot;hello&quot;);\r\nConsole.WriteLine(&quot;фыва&quot;);\r\nConsole.WriteLine(&quot;hello word&quot;);\r\n&lt;/code&gt;\r\n&lt;p&gt;Если внутри строки необходимо вывести двойную кавычку, то такая внутренняя кавычка предваряется обратным слешем:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nConsole.WriteLine(&quot;Компания &quot;Рога и копыта&quot;&quot;);\r\n&lt;/code&gt;\r\n&lt;p&gt;Также в строках можно использовать управляющие последовательности. Например, последовательность &#039;\n&#039; осуществляет перевод на новую строку:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nConsole.WriteLine(&quot;Привет \nмир&quot;);\r\n&lt;/code&gt;\r\n&lt;p&gt;При выводе на консоль слово &quot;мир&quot; будет перенесено на новую строку:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Привет\r\nмир\r\n&lt;/pre&gt;\r\n\r\n&lt;h3&gt;null&lt;/h3&gt;\r\n&lt;p&gt;&lt;strong&gt;null&lt;/strong&gt; представляет ссылку, которая не указывает ни на какой объект. То есть по сути отсутствие значения.&lt;/p&gt;'),
(7, 'Типы данных', 2, 4, 2, '&lt;p&gt;Как и во многих языках программирования, в C# есть своя система типов данных, которая используется для создания переменных. \r\nТип данных определяет внутреннее представление данных, множество значений, которые может принимать объект, а также допустимые действия, которые можно применять над объектом.&lt;/p&gt;\r\n&lt;p&gt;В языке C# есть следующие базовые типы данных:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;\r\n&lt;p&gt;&lt;strong&gt;bool&lt;/strong&gt;: хранит значение &lt;strong&gt;true&lt;/strong&gt; или &lt;strong&gt;false&lt;/strong&gt; (логические литералы). Представлен системным типом &lt;strong&gt;System.Boolean&lt;/strong&gt;&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nbool alive = true;\r\nbool isDead = false;\r\n&lt;/code&gt;\r\n&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;byte&lt;/strong&gt;: хранит целое число от &lt;strong&gt;0&lt;/strong&gt; до &lt;strong&gt;255&lt;/strong&gt; и занимает 1 байт. Представлен системным типом \r\n&lt;strong&gt;System.Byte&lt;/strong&gt;&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nbyte bit1 = 1;\r\nbyte bit2 = 102;\r\n&lt;/code&gt;\r\n&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;sbyte&lt;/strong&gt;: хранит целое число от &lt;strong&gt;-128&lt;/strong&gt; до &lt;strong&gt;127&lt;/strong&gt; и занимает 1 байт. Представлен системным типом \r\n&lt;strong&gt;System.SByte&lt;/strong&gt;&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nsbyte bit1 = -101;\r\nsbyte bit2 = 102;\r\n&lt;/code&gt;\r\n&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;short&lt;/strong&gt;: хранит целое число от &lt;strong&gt;-32768&lt;/strong&gt; до &lt;strong&gt;32767&lt;/strong&gt; и занимает 2 байта. Представлен системным типом \r\n&lt;strong&gt;System.Int16&lt;/strong&gt;&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nshort n1 = 1;\r\nshort n2 = 102;\r\n&lt;/code&gt;\r\n&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;ushort&lt;/strong&gt;: хранит целое число от &lt;strong&gt;0&lt;/strong&gt; до &lt;strong&gt;65535&lt;/strong&gt; и занимает 2 байта. Представлен системным типом \r\n&lt;strong&gt;System.UInt16&lt;/strong&gt;&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nushort n1 = 1;\r\nushort n2 = 102;\r\n&lt;/code&gt;\r\n&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt;: хранит целое число от &lt;strong&gt;-2147483648&lt;/strong&gt; до &lt;strong&gt;2147483647&lt;/strong&gt; и занимает 4 байта. Представлен системным типом \r\n&lt;strong&gt;System.Int32&lt;/strong&gt;. Все целочисленные литералы по умолчанию представляют значения типа int:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint a = 10;\r\nint b = 0b101;  // бинарная форма b =5\r\nint c = 0xFF;   // шестнадцатеричная форма c = 255\r\n&lt;/code&gt;\r\n&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;uint&lt;/strong&gt;: хранит целое число от &lt;strong&gt;0&lt;/strong&gt; до &lt;strong&gt;4294967295&lt;/strong&gt; и занимает 4 байта. Представлен системным типом \r\n&lt;strong&gt;System.UInt32&lt;/strong&gt;&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nuint a = 10;\r\nuint b = 0b101;\r\nuint c = 0xFF;\r\n&lt;/code&gt;\r\n&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;long&lt;/strong&gt;: хранит целое число от &lt;strong&gt;–9 223 372 036 854 775 808&lt;/strong&gt; до &lt;strong&gt;9 223 372 036 854 775 807&lt;/strong&gt; и занимает 8 байт. Представлен системным типом \r\n&lt;strong&gt;System.Int64&lt;/strong&gt;&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nlong a = -10;\r\nlong b = 0b101;\r\nlong c = 0xFF;\r\n&lt;/code&gt;\r\n&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;ulong&lt;/strong&gt;: хранит целое число от &lt;strong&gt;0&lt;/strong&gt; до &lt;strong&gt;18 446 744 073 709 551 615&lt;/strong&gt; и занимает 8 байт. Представлен системным типом \r\n&lt;strong&gt;System.UInt64&lt;/strong&gt;&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nulong a = 10;\r\nulong b = 0b101;\r\nulong c = 0xFF;\r\n&lt;/code&gt;\r\n&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;float&lt;/strong&gt;: хранит число с плавающей точкой от &lt;strong&gt;-3.4*10&lt;sup&gt;38&lt;/sup&gt;&lt;/strong&gt; до &lt;strong&gt;3.4*10&lt;sup&gt;38&lt;/sup&gt;&lt;/strong&gt; и \r\nзанимает 4 байта. Представлен системным типом &lt;strong&gt;System.Single&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;double&lt;/strong&gt;: хранит число с плавающей точкой от &lt;strong&gt;±5.0*10&lt;sup&gt;-324&lt;/sup&gt;&lt;/strong&gt; до &lt;strong&gt;±1.7*10&lt;sup&gt;308&lt;/sup&gt;&lt;/strong&gt; и \r\nзанимает 8 байта. Представлен системным типом &lt;strong&gt;System.Double&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;decimal&lt;/strong&gt;: хранит десятичное дробное число. Если употребляется без десятичной запятой, имеет значение от ±1.0*10&lt;sup&gt;-28&lt;/sup&gt; до ±7.9228*10&lt;sup&gt;28&lt;/sup&gt;, \r\nможет хранить 28 знаков после запятой и занимает 16 байт. Представлен системным типом &lt;strong&gt;System.Decimal&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;char&lt;/strong&gt;: хранит одиночный символ в кодировке Unicode и занимает 2 байта. Представлен системным типом \r\n&lt;strong&gt;System.Char&lt;/strong&gt;. Этому типу соответствуют символьные литералы:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nchar a = &#039;A&#039;;\r\nchar b = &#039;\\x5A&#039;;\r\nchar c = &#039;u0420&#039;;\r\n&lt;/code&gt;\r\n&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;string&lt;/strong&gt;: хранит набор символов Unicode. Представлен системным типом &lt;strong&gt;System.String&lt;/strong&gt;. Этому типу соответствуют строковые литералы.&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nstring hello = &quot;Hello&quot;;\r\nstring word = &quot;world&quot;;\r\n&lt;/code&gt;\r\n&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;object&lt;/strong&gt;: может хранить значение любого типа данных и занимает 4 байта на 32-разрядной платформе и 8 байт на 64-разрядной платформе. Представлен системным типом \r\n&lt;strong&gt;System.Object&lt;/strong&gt;, который является базовым для всех других типов и классов .NET.&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nobject a = 22;\r\nobject b = 3.14;\r\nobject c = &quot;hello code&quot;;\r\n&lt;/code&gt;\r\n&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Например, определим несколько переменных разных типов и выведем их значения на консоль:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nstring name = &quot;Tom&quot;;\r\nint age = 33;\r\nbool isEmployed = false;\r\ndouble weight = 78.65;\r\n \r\nConsole.WriteLine($&quot;Имя: {name}&quot;);\r\nConsole.WriteLine($&quot;Возраст: {age}&quot;);\r\nConsole.WriteLine($&quot;Вес: {weight}&quot;);\r\nConsole.WriteLine($&quot;Работает: {isEmployed}&quot;);\r\n&lt;/code&gt;\r\n&lt;p&gt;Для вывода данных на консоль здесь применяется интерполяция: перед строкой ставится знак $ и после этого мы можем вводить в строку в фигурных скобках значения переменных. \r\nКонсольный вывод программы:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Имя: Tom\r\nВозраст: 33\r\nВес: 78,65\r\nРаботает: False\r\n&lt;/pre&gt;\r\n\r\n&lt;h3&gt;Использование суффиксов&lt;/h3&gt;\r\n&lt;p&gt;При присвоении значений надо иметь в виду следующую тонкость: все вещественные литералы (дробные числа) рассматриваются как значения типа \r\n&lt;strong&gt;double&lt;/strong&gt;. И чтобы указать, что дробное число представляет тип &lt;strong&gt;float&lt;/strong&gt; или тип &lt;strong&gt;decimal&lt;/strong&gt;, \r\nнеобходимо к литералу добавлять суффикс: F/f - для float и M/m - для decimal.&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nfloat a = 3.14F;\r\nfloat b = 30.6f;\r\n \r\ndecimal c = 1005.8M;\r\ndecimal d = 334.8m;\r\n&lt;/code&gt;\r\n&lt;p&gt;Подобным образом все целочисленные литералы рассматриваются как значения типа &lt;strong&gt;int&lt;/strong&gt;. Чтобы явным образом указать, что целочисленный литерал представляет значение \r\nтипа uint, надо использовать суффикс &lt;strong&gt;U/u&lt;/strong&gt;, для типа &lt;strong&gt;long&lt;/strong&gt; - суффикс &lt;strong&gt;L/l&lt;/strong&gt;, а для типа \r\n&lt;strong&gt;ulong&lt;/strong&gt; - суффикс &lt;strong&gt;UL/ul&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nuint a = 10U;\r\nlong b = 20L;\r\nulong c = 30UL;\r\n&lt;/code&gt;		\r\n&lt;h3&gt;Использование системных типов&lt;/h3&gt;\r\n&lt;p&gt;Выше при перечислении всех базовых типов данных для каждого упоминался системный тип. Потому что название встроенного типа по сути представляет собой сокращенное обозначение системного типа. Например, следующие переменные будут эквивалентны по типу:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint a = 4;\r\nSystem.Int32 b = 4;\r\n&lt;/code&gt;	\r\n&lt;h3&gt;Неявная типизация&lt;/h3&gt;\r\n&lt;p&gt;Ранее мы явным образом указывали тип переменных, например, &lt;strong&gt;int x;&lt;/strong&gt;. И компилятор при запуске уже знал, что x хранит целочисленное значение.&lt;/p&gt;\r\n&lt;p&gt;Однако мы можем использовать и модель неявной типизации:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar hello = &quot;Hell to World&quot;;\r\nvar c = 20;\r\n&lt;/code&gt;\r\n&lt;p&gt;Для неявной типизации вместо названия типа данных используется ключевое слово &lt;strong&gt;var&lt;/strong&gt;. Затем уже при компиляции компилятор сам выводит \r\nтип данных исходя из присвоенного значения. Так как по умолчанию все целочисленные значения рассматриваются как значения типа \r\n&lt;strong&gt;int&lt;/strong&gt;, то поэтому в итоге переменная c будет иметь тип &lt;strong&gt;int&lt;/strong&gt;. Аналогично переменной &lt;strong&gt;hello&lt;/strong&gt; присваивается строка, поэтому эта переменная будет иметь тип &lt;strong&gt;string&lt;/strong&gt;&lt;/p&gt;\r\n&lt;p&gt;Эти переменные подобны обычным, однако они имеют некоторые ограничения.&lt;/p&gt;\r\n&lt;p&gt;Во-первых, мы не можем сначала объявить неявно типизируемую переменную, а затем инициализировать:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\n// этот код работает\r\nint a;\r\na = 20;\r\n \r\n// этот код не работает\r\nvar c;\r\nc= 20;\r\n&lt;/code&gt;\r\n&lt;p&gt;Во-вторых, мы не можем указать в качестве значения неявно типизируемой переменной &lt;strong&gt;null&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\n// этот код не работает\r\nvar c=null;\r\n&lt;/code&gt;\r\n&lt;p&gt;Так как значение null, то компилятор не сможет вывести тип данных.&lt;/p&gt;\r\n');
INSERT INTO `lectures` (`IDLecture`, `Name`, `IDChapter`, `SerialNumber`, `IDStatus`, `Content`) VALUES
(8, 'Консольный ввод-вывод', 2, 5, 2, '&lt;p&gt;Для вывода информации на консоль мы уже использовали встроенный метод &lt;strong&gt;Console.WriteLine&lt;/strong&gt;. \r\nТо есть, если мы хотим вывести некоторую информацию на консоль, то нам надо передать ее в метод Console.WriteLine:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nstring hello = &quot;Привет мир&quot;;\r\nConsole.WriteLine(hello);\r\nConsole.WriteLine(&quot;Добро пожаловать в C#!&quot;);\r\nConsole.WriteLine(&quot;Пока мир...&quot;);\r\nConsole.WriteLine(24.5);\r\n&lt;/code&gt;\r\n&lt;p&gt;Консольный вывод:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Привет мир!\r\nДобро пожаловать в C#!\r\nПока мир...\r\n24,5\r\n&lt;/pre&gt;\r\n\r\n&lt;p&gt;Нередко возникает необходимость вывести на консоль в одной строке значения сразу нескольких переменных. В этом случае мы можем использовать прием, который \r\nназывается интерполяцией:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nstring name = &quot;Tom&quot;;\r\nint age = 34;\r\ndouble height = 1.7;\r\nConsole.WriteLine($&quot;Имя: {name}  Возраст: {age}  Рост: {height}м&quot;);\r\n&lt;/code&gt;\r\n&lt;p&gt;Для встраивания отдельных значений в выводимую на консоль строку используются фигурные скобки, в которые заключается встраиваемое значение. \r\nЭто можем значение переменной (&lt;strong&gt;{name}&lt;/strong&gt;) или более сложное выражение (например, операция сложения &lt;strong&gt;{4 + 7}&lt;/strong&gt;). А перед всей строкой ставится знак доллара $.&lt;/p&gt;\r\n&lt;p&gt;При выводе на консоль вместо помещенных в фигурные скобки выражений будут выводиться их значения:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Имя: Tom  Возраст: 34  Рост: 1,7м\r\n&lt;/pre&gt;\r\n\r\n&lt;p&gt;Есть другой способ вывода на консоль сразу нескольких значений:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nstring name = &quot;Tom&quot;;\r\nint age = 34;\r\ndouble height = 1.7;\r\nConsole.WriteLine(&quot;Имя: {0}  Возраст: {2}  Рост: {1}м&quot;, name, height, age);\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь мы видим, что строка в &lt;strong&gt;Console.WriteLine&lt;/strong&gt; содержит некие числа в фигурных скобках: {0}, {1}, {2}. Это плейсхолдеры, вместо которых при выводе строки на консоль \r\nбудут подставляться некоторые значения. Подставляемые значения указываются после строки через запятую.&lt;/p&gt;\r\n&lt;p&gt;При этом важен порядок подобных плейсхолдеров. Например, в данном случае после строки первой указана переменная name, потом height и потом age. Поэтому значение переменной name будет всавляться вместо \r\nпервого плейсхолдера - {0} (нумерация начинается с нуля), height - вместо {1}, а age - вместо {2}. Поэтому в итоге пи выводе на консоль строка&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\n&quot;Имя: {0}  Возраст: {2}  Рост: {1}м&quot;\r\n&lt;/code&gt;\r\n&lt;p&gt;будет заменена на&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\n&quot;Имя: Tom  Возраст: 34  Рост: 1,7м&quot;\r\n&lt;/code&gt;\r\n&lt;h4&gt;Console.Write&lt;/h4&gt;\r\n&lt;p&gt;Кроме &lt;strong&gt;Console.WriteLine()&lt;/strong&gt; можно также использовать метод &lt;strong&gt;Console.Write()&lt;/strong&gt;, он работает точно так же за тем исключением, \r\nчто не добавляет переход на следующую строку, то есть последующий консольный вывод будет выводиться на той же строке.&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nstring name = &quot;Tom&quot;;\r\nint age = 34;\r\ndouble height = 1.7;\r\nConsole.Write($&quot;Имя: {name}  Возраст: {age}  Рост: {height}м&quot;);\r\n&lt;/code&gt;\r\n&lt;h3&gt;Консольный ввод&lt;/h3&gt;\r\n&lt;p&gt;Кроме вывода информации на консоль мы можем получать информацию с консоли. Для этого предназначен метод &lt;strong&gt;Console.ReadLine()&lt;/strong&gt;. Он позволяет получить введенную строку.&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nConsole.Write(&quot;Введите свое имя: &quot;);\r\nstring? name = Console.ReadLine();\r\nConsole.WriteLine($&quot;Привет {name}&quot;);\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае все, что вводит пользователь, с помощью метода Console.ReadLine() передается в переменную name.&lt;/p&gt;Пример работы программы:&lt;p&gt;&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Введите свое имя: Том\r\nПривет Том\r\n&lt;/pre&gt;\r\n\r\n&lt;p&gt;Особенностью метода &lt;strong&gt;Console.ReadLine()&lt;/strong&gt; является то, что он может считать информацию с консоли только в виде строки. Кроме того, возможная ситуация, когда для метода \r\nConsole.ReadLine не окажется доступных для считывания строк, то есть когда ему нечего считывать, он возвращаает значение &lt;strong&gt;null&lt;/strong&gt;, то есть, грубо говоря, фактически отсутствие значения. \r\nИ чтобы отразить эту ситуацию мы определяем переменную &lt;strong&gt;name&lt;/strong&gt;, в которую получаем ввод с консоли, как переменную типа &lt;strong&gt;string?&lt;/strong&gt;. Здесь &lt;strong&gt;string&lt;/strong&gt; указывает, \r\nчто переменная может хранить значения типа string, то есть строки. А знак вопроса &lt;strong&gt;?&lt;/strong&gt; указывает, что переменная также может хранить значение &lt;strong&gt;null&lt;/strong&gt;, то есть по сути не иметь никакого значения. Далее мы более подробно разберем \r\n&lt;strong&gt;null&lt;/strong&gt; и как с ним работать.&lt;/p&gt;\r\n&lt;p&gt;Однако, может возникнуть вопрос, как нам быть, если, допустим, мы хотим ввести возраст в переменную типа int или другую информацию \r\nв переменные типа double или decimal? По умолчанию платформа .NET предоставляет ряд методов, которые позволяют преобразовать различные значения к типам int, double и т.д. Некоторые из этих методов:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Convert.ToInt32()&lt;/strong&gt; (преобразует к типу int)&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Convert.ToDouble()&lt;/strong&gt; (преобразует к типу double)&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Convert.ToDecimal()&lt;/strong&gt; (преобразует к типу decimal)&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Пример ввода значений:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nConsole.Write(&quot;Введите имя: &quot;);\r\nstring? name = Console.ReadLine();\r\n \r\nConsole.Write(&quot;Введите возраст: &quot;);\r\nint age = Convert.ToInt32(Console.ReadLine());\r\n \r\nConsole.Write(&quot;Введите рост: &quot;);\r\ndouble height = Convert.ToDouble(Console.ReadLine());\r\n \r\nConsole.Write(&quot;Введите размер зарплаты: &quot;);\r\ndecimal salary = Convert.ToDecimal(Console.ReadLine());\r\n \r\nConsole.WriteLine($&quot;Имя: {name}  Возраст: {age}  Рост: {height}м  Зарплата: {salary}$&quot;);\r\n&lt;/code&gt;\r\n&lt;p&gt;При вводе важно учитывать текущую операционную систему. В одних культурах разделителем между целой и дробной частью является точка (США, Великобритания...), \r\nв других - запятая (Россия, Германия...). Например, если текущая ОС - русскоязычная, значит, надо вводить дробные числа с разделителем запятой. \r\nЕсли локализация англоязычная, значит, разделителем целой и дробной части при вводе будет точка.&lt;/p&gt;\r\n&lt;p&gt;Пример работы программы:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Введите имя: Том\r\nВведите возраст: 25\r\nВведите рост: 1,75\r\nВведите размер зарплаты: 300,67\r\nИмя: Том  Возраст: 25  Рост: 1,75м  Зарплата: 300,67$\r\n&lt;/pre&gt;\r\n\r\n'),
(9, 'Арифметические операции', 2, 6, 2, '&lt;p&gt;В C# используется большинство операций, которые применяются и в других языках программирования. Операции представляют определенные действия над операндами - \r\nучастниками операции. В качестве операнда может выступать переменной или какое-либо значение (например, число). \r\nОперации бывают унарными (выполняются над одним операндом), бинарными - над двумя операндами и тернарными - выполняются над тремя операндами. Рассмотрим все виды операций.&lt;/p&gt;\r\n&lt;p&gt;Бинарные арифметические операции:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;+&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Операция сложения двух чисел:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint x = 10;\r\nint z = x + 12; // 22\r\n&lt;/code&gt;\r\n&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Операция вычитания двух чисел:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint x = 10;\r\nint z = x - 6; // 4\r\n&lt;/code&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;*&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Операция умножения двух чисел:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint x = 10;\r\nint z = x * 5; // 50\r\n&lt;/code&gt;\r\n&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;/&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;операция деления двух чисел:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint x = 10;\r\nint z = x / 5; // 2\r\n \r\ndouble a = 10;\r\ndouble b = 3;\r\ndouble c = a / b; // 3.33333333\r\n&lt;/code&gt;\r\n&lt;p&gt;При делении стоит учитывать, что если оба операнда представляют целые числа, то результат также будет округляться до целого числа:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ndouble z = 10 /  4; //результат равен 2\r\n&lt;/code&gt;\r\n&lt;p&gt;Несмотря на то, что результат операции в итоге помещается в переменную типа double, которая позволяет сохранить дробную часть, но в самой операции участвуют два литерала, \r\nкоторые по умолчанию рассматриваются как объекты int, то есть целые числа, и результат то же будет целочисленный.&lt;/p&gt;\r\n&lt;p&gt;Для выхода из этой ситуации необходимо определять литералы или переменные, участвующие в операции, именно как типы double или float:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ndouble z = 10.0 /  4.0; //результат равен 2.5\r\n&lt;/code&gt;\r\n&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;%&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Операция получение остатка от целочисленного деления двух чисел:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ndouble x = 10.0;\r\ndouble z = x % 4.0; //результат равен 2\r\n&lt;/code&gt;\r\n&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Также есть ряд унарных операций, в которых принимает участие один операнд:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;++&lt;/strong&gt;&lt;/p&gt;\r\n&lt;p&gt;Операция инкремента&lt;/p&gt;\r\n&lt;p&gt;Инкремент бывает префиксным: &lt;strong&gt;++x&lt;/strong&gt; - сначала значение переменной x увеличивается на 1, \r\nа потом ее значение возвращается в качестве результата операции.&lt;/p&gt;&lt;/li&gt;\r\n&lt;p&gt;И также существует постфиксный инкремент: &lt;strong&gt;x++&lt;/strong&gt; - сначала значение переменной x возвращается в качестве результата операции, \r\nа затем к нему прибавляется 1.&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint x1 = 5;\r\nint z1 = ++x1; // z1=6; x1=6\r\nConsole.WriteLine($&quot;{x1} - {z1}&quot;);\r\n \r\nint x2 = 5;\r\nint z2 = x2++; // z2=5; x2=6\r\nConsole.WriteLine($&quot;{x2} - {z2}&quot;);\r\n&lt;/code&gt;\r\n\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;--&lt;/strong&gt;&lt;/p&gt;\r\n&lt;p&gt;Операция декремента или уменьшения значения на единицу. Также существует префиксная форма декремента (&lt;strong&gt;--x&lt;/strong&gt;) и \r\nпостфиксная (&lt;strong&gt;x--&lt;/strong&gt;).&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint x1 = 5;\r\nint z1 = --x1; // z1=4; x1=4\r\nConsole.WriteLine($&quot;{x1} - {z1}&quot;);\r\n \r\nint x2 = 5;\r\nint z2 = x2--; // z2=5; x2=4\r\nConsole.WriteLine($&quot;{x2} - {z2}&quot;);\r\n&lt;/code&gt;\r\n&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;При выполнении сразу нескольких арифметических операций следует учитывать порядок их выполнения. Приоритет операций от наивысшего к низшему:&lt;/p&gt;\r\n&lt;ol&gt;\r\n&lt;li&gt;&lt;p&gt;Инкремент, декремент&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Умножение, деление, получение остатка&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Сложение, вычитание&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;Для изменения порядка следования операций применяются скобки.&lt;/p&gt;\r\n&lt;p&gt;Рассмотрим набор операций:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint a = 3;\r\nint b = 5;\r\nint c = 40;\r\nint d = c---b*a;    // a=3  b=5  c=39  d=25\r\nConsole.WriteLine($&quot;a={a}  b={b}  c={c}  d={d}&quot;);\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь мы имеем дело с тремя операциями: декремент, вычитание и умножение. Сначала выполняется декремент переменной c, затем умножение b*a, и в конце вычитание. То есть фактически набор операций выглядел так:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint d = (c--)-(b*a);\r\n&lt;/code&gt;\r\n&lt;p&gt;Но с помощью скобок мы могли бы изменить порядок операций, например, следующим образом:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint a = 3;\r\nint b = 5;\r\nint c = 40;\r\nint d = (c-(--b))*a;    // a=3  b=4  c=40  d=108\r\nConsole.WriteLine($&quot;a={a}  b={b}  c={c}  d={d}&quot;);\r\n&lt;/code&gt;\r\n&lt;h3&gt;Ассоциативность операторов&lt;/h3&gt;\r\n&lt;p&gt;Как выше было отмечено, операции умножения и деления имеют один и тот же приоритет, но какой тогда результат будет в выражении:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint x = 10 / 5 * 2;\r\n&lt;/code&gt;\r\n&lt;p&gt;Стоит нам трактовать это выражение как &lt;strong&gt;(10 / 5) * 2&lt;/strong&gt; или как &lt;strong&gt;10 / (5 * 2)&lt;/strong&gt;? Ведь в зависимости от трактовки \r\nмы получим разные результаты.&lt;/p&gt;\r\n&lt;p&gt;Когда операции имеют один и тот же приоритет, порядок вычисления определяется ассоциативностью операторов. В зависимости от ассоциативности \r\nесть два типа операторов:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;Левоассоциативные операторы, которые выполняются слева направо&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Правоассоциативные операторы, которые выполняются справа налево&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Все арифметические операторы являются левоассоциативными, то есть выполняются слева направо. Поэтому выражение &lt;strong&gt;10 / 5 * 2&lt;/strong&gt; \r\nнеобходимо трактовать как &lt;strong&gt;(10 / 5) * 2&lt;/strong&gt;, то есть результатом будет 4.&lt;/p&gt;'),
(10, 'Классы и объекты', 3, 1, 2, '&lt;p&gt;C# является полноценным объектно-ориентированным языком. Это значит, что программу на C# можно представить в виде взаимосвязанных \r\nвзаимодействующих между собой объектов.&lt;/p&gt;\r\n&lt;p&gt;Описанием объекта является &lt;strong&gt;класс&lt;/strong&gt;, а объект представляет экземпляр этого класса. Можно еще провести следующую аналогию. \r\nУ нас у всех есть некоторое представление о человеке, у которого есть имя, возраст, какие-то другие характеристики. \r\nТо есть некоторый шаблон - этот шаблон можно назвать классом. Конкретное воплощение этого шаблона может отличаться, например, одни люди имеют одно имя, другие - другое имя. \r\nИ реально существующий человек (фактически экземпляр данного класса) будет представлять объект этого класса.&lt;/p&gt;\r\n&lt;p&gt;В принципе ранее уже использовались классы. Например, тип &lt;strong&gt;string&lt;/strong&gt;, который представляет строку, фактически является классом. Или, например, класс &lt;strong&gt;Console&lt;/strong&gt;, \r\nу которого метод &lt;strong&gt;WriteLine()&lt;/strong&gt; выводит на консоль некоторую информацию. Теперь же посмотрим, как мы можем определять свои собственные классы.&lt;/p&gt;\r\n&lt;p&gt;По сути класс представляет новый тип, который определяется пользователем. Класс определяется с помощью ключевого слова &lt;strong&gt;сlass&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass название_класса\r\n{\r\n    // содержимое класса\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;После слова &lt;strong&gt;class&lt;/strong&gt; идет имя класса и далее в фигурных скобках идет собственно содержимое класса. \r\nНапример, определим в файле &lt;strong&gt;Program.cs&lt;/strong&gt; класс Person, который будет представлять человека:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Person\r\n{\r\n  \r\n}\r\n&lt;/code&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/3.25.png&quot; alt=&quot;Классы и объекты в языке программирования C# и .NET&quot;&gt;\r\n&lt;p&gt;Однако такой класс не особо показателен, поэтому добавим в него некоторую функциональность.&lt;/p&gt;\r\n&lt;h3&gt;Поля и методы класса&lt;/h3&gt;\r\n&lt;p&gt;Класс может хранить некоторые данные. Для хранения данных в классе применяются &lt;strong&gt;поля&lt;/strong&gt;. По сути &lt;strong&gt;поля класса&lt;/strong&gt; - \r\nэто переменные, определенные на уровне класса.&lt;/p&gt;\r\n&lt;p&gt;Кроме того, класс может определять некоторое поведение или выполняемые действия. Для определения поведения в классе применяются методы.&lt;/p&gt;\r\n&lt;p&gt;Итак, добавим в класс Person поля и методы:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Person \r\n{\r\n    public string name = &quot;Undefined&quot;;   // имя\r\n    public int age;                     // возраст\r\n \r\n    public void Print()\r\n    {\r\n        Console.WriteLine($&quot;Имя: {name}  Возраст: {age}&quot;);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае в классе Person определено поле &lt;strong&gt;name&lt;/strong&gt;, которое хранит имя, и поле &lt;strong&gt;age&lt;/strong&gt;, которое хранит \r\nвозраст человека. В отличие от переменных, определенных в методах, поля класса могут иметь модификаторы, которые указываются перед полем. \r\nТак, в данном случае, чтобы все поля были доступны вне класса Person поля определены с модификатором &lt;strong&gt;public&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;p&gt;При определении полей мы можем  присвоить им некоторые значения, как в примере выше в случае переменной &lt;strong&gt;name&lt;/strong&gt;. \r\nЕсли поля класса не инициализированы, то они получают значения по умолчанию. Для переменных числовых типов это число 0.&lt;/p&gt;\r\n&lt;p&gt;Также в классе Person определен метод &lt;strong&gt;Print()&lt;/strong&gt;. Методы класса имеют доступ к его поля, и в данном случае обращаемся к полям класса name и age для вывода их значения на консоль. \r\nИ чтобы этот метод был виден вне класса, он также определен с модификатором &lt;strong&gt;public&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;h3&gt;Создание объекта класса&lt;/h3&gt;\r\n&lt;p&gt;После определения класса мы можем создавать его объекты. Для создания объекта применяются &lt;strong&gt;конструкторы&lt;/strong&gt;. По \r\nсути конструкторы представляют специальные методы, которые называются так же как и класс, и которые вызываются при создании нового \r\nобъекта класса и выполняют инициализацию объекта. Общий синтаксис вызова конструктора:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nnew конструктор_класса(параметры_конструктора);\r\n&lt;/code&gt;\r\n&lt;p&gt;Сначала идет оператор &lt;strong&gt;new&lt;/strong&gt;, который выделяет память для объекта, а после \r\nнего идет вызов &lt;strong&gt;конструктора&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;h4&gt;Конструктор по умолчанию&lt;/h4&gt;\r\n&lt;p&gt;Если в классе не определено ни одного конструктора (как в случае с нашим классом Person), то для этого класса автоматически \r\nсоздается пустой конструктор по умолчанию, который не принимает никаких параметров.&lt;/p&gt;\r\n&lt;p&gt;Теперь создадим объект класса Person:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson tom = new Person();  // создание объекта класса Person\r\n \r\n// определение класса Person\r\nclass Person \r\n{\r\n    public string name = &quot;Undefined&quot;;\r\n    public int age;\r\n \r\n    public void Print()\r\n    {\r\n        Console.WriteLine($&quot;Имя: {name}  Возраст: {age}&quot;);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/3.26.png&quot; alt=&quot;создание классов в языке программирования C# и .NET&quot;&gt;\r\n&lt;p&gt;Для создания объекта Person используется выражение &lt;strong&gt;new Person()&lt;/strong&gt;. В итоге после выполнения данного выражения в памяти \r\nбудет выделен участок, где будут храниться все данные объекта Person. А переменная &lt;strong&gt;tom&lt;/strong&gt; получит ссылку на созданный объект, \r\nи через эту переменную мы можем использовать данный объект и обращаться к его функциональности.&lt;/p&gt;\r\n\r\n&lt;h3&gt;Обращение к функциональности класса&lt;/h3&gt;\r\n&lt;p&gt;Для обращения к функциональности класса - полям, методам (а также другим элементам класса) применяется точечная нотация точки - после объекта класса ставится точка, а затем элемент класса:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nобъект.поле_класса\r\nобъект.метод_класса(параметры_метода)\r\n&lt;/code&gt;\r\n&lt;p&gt;Например, обратимся к полям и методам объекта Person:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson tom = new Person();  // создание объекта класса Person\r\n \r\n// Получаем значение полей в переменные\r\nstring personName = tom.name;\r\nint personAge = tom.age;\r\nConsole.WriteLine($&quot;Имя: {personName}  Возраст {personAge}&quot;);   // Имя: Undefined  Возраст: 0\r\n \r\n// устанавливаем новые значения полей\r\ntom.name = &quot;Tom&quot;;\r\ntom.age = 37;\r\n \r\n// обращаемся к методу Print\r\ntom.Print();    // Имя: Tom  Возраст: 37\r\n \r\nclass Person \r\n{\r\n    public string name = &quot;Undefined&quot;;\r\n    public int age;\r\n \r\n    public void Print()\r\n    {\r\n        Console.WriteLine($&quot;Имя: {name}  Возраст: {age}&quot;);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Консольный вывод данной программы:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Имя: Undefined	Возраст: 0\r\nИмя: Tom	Возраст: 37\r\n&lt;/pre&gt;\r\n\r\n&lt;h3&gt;Константы классы&lt;/h3&gt;\r\n&lt;p&gt;Кроме полей класс может определять для хранения данных константы. В отличие от полей из значение устанавливается один раз непосредственно при их \r\nобъявлении и впоследствии не может быть изменено. Кроме того, константы хранят некоторые данные, которые относятся не к одному объекту, а ко всему классу в целом. И для обращения к константам применяется \r\nне имя объекта, а имя класса:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson tom = new Person();\r\ntom.name = &quot;Tom&quot;;\r\ntom.age = 37;\r\ntom.Print();    // Person: Tom - 37\r\n \r\nConsole.WriteLine(Person.type); // Person\r\n// Person.type = &quot;User&quot;;    // !Ошибка: изменить константу нельзя\r\n \r\nclass Person\r\n{\r\n    public const string type = &quot;Person&quot;;\r\n    public string name = &quot;Undefined&quot;;\r\n    public int age;\r\n    public void Print() =&gt; Console.WriteLine($&quot;{type}: {name} - {age}&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь в классе Person определена константа &lt;strong&gt;type&lt;/strong&gt;, которая хранит название класса:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\npublic const string type = &quot;Person&quot;;\r\n&lt;/code&gt;\r\n&lt;p&gt;Название класса не зависит от объекта. Мы можем создать много объектов Person, но название класса от этого не должно измениться - оно относится ко всем объектам Person и не \r\nдолжно меняться. Поэтому название типа можно сохранить в виде константы.&lt;/p&gt;\r\n&lt;p&gt;Стоит отметить, что константе сразу при ее определении необходимо присвоить значение.&lt;/p&gt;\r\n&lt;p&gt;Подобно обычным полям мы можем обращаться к константам класса внутри этого класса. Например, в методе Print значение константы выводится на консоль.&lt;/p&gt;\r\n&lt;p&gt;Однако если мы хотим обратиться к константе вне ее класса, то для обращения необходимо использовались имя класса:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nConsole.WriteLine(Person.type); // Person\r\n&lt;/code&gt;\r\n&lt;p&gt;Таким образом, если необходимо хранить данные, которые относятся ко всему классу в целом&lt;/p&gt;\r\n&lt;h3&gt;Добавление класса в Visual Studio&lt;/h3&gt;\r\n&lt;p&gt;Обычно классы помещаются в отдельные файлы. Нередко для одного класса предназначен один файл. И Visual Studio предоставляет по умолчанию встроенные шаблоны для добвления класса.&lt;/p&gt;\r\n&lt;p&gt;Для добавления класса нажмем в Visual Studio правой кнопкой мыши на название проекта:&lt;/p&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/3.39.png&quot; alt=&quot;Добавление класса в Visual Studio в C#&quot;&gt;\r\n&lt;p&gt;В появившемся контекстном меню выберем пункт &lt;strong&gt;Add -&gt; New Item...&lt;/strong&gt; (или &lt;strong&gt;Add -&gt; Class...&lt;/strong&gt;)&lt;/p&gt;\r\n&lt;p&gt;В открывшемся окне добавления нового элемента убедимся, что в центральной части с шаблонами элементов у нас выбран пункт &lt;strong&gt;Class&lt;/strong&gt;. \r\nА внизу окна в поле &lt;strong&gt;Name&lt;/strong&gt; введем название добавляемого класса - пусть он будет назваться &lt;strong&gt;Person&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/3.40.png&quot; alt=&quot;Добавление нового класса в Visual Studio в C#&quot;&gt;\r\n&lt;p&gt;В качестве названия класса можно вводить как Person, так и Person.cs. И после нажатия на кнопку добавления в проект будет добавлен новый класс:&lt;/p&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/3.41.png&quot; alt=&quot;Добавление класса в проект в Visual Studio в C#&quot;&gt;\r\n&lt;p&gt;В файле &lt;strong&gt;Person.cs&lt;/strong&gt; определим следующий код:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Person\r\n{\r\n    public string name = &quot;Undefined&quot;;\r\n    public void Print()\r\n    {\r\n        Console.WriteLine($&quot;Person {name}&quot;);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь определен класс Person с одним полем name и методом Print.&lt;/p&gt;\r\n&lt;p&gt;В файле &lt;strong&gt;Program.cs&lt;/strong&gt;, который представляет основной файл программы используем класс Person:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson tom = new Person();\r\ntom.name = &quot;Tom&quot;;\r\ntom.Print();    // Person Tom\r\n&lt;/code&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/3.42.png&quot; alt=&quot;Использование классов в проекте в Visual Studio в языке программирования C#&quot;&gt;\r\n&lt;p&gt;Таким образом, мы можем определять классы в отдельных файлах и использовать их в программе.&lt;/p&gt;\r\n'),
(11, 'Конструкторы, инициализаторы и деконструкторы', 3, 2, 2, '&lt;p&gt;В прошлой статье для создания объекта использовался конструктор по умолчанию. Однако мы сами можем определить свои конструкторы. Как правило, конструктор выполняет инициализацию объекта. \r\nПри этом если в классе определяются свои конструкторы, то он лишается конструктора по умолчанию.&lt;/p&gt;\r\n&lt;p&gt;На уровне кода конструктор представляет метод, который называется по имени класса, который может иметь параметры, но для него не надо определять \r\nвозвращаемый тип. Например, определим в классе Person простейший конструктор:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson tom = new Person();  // Создание объекта класса Person\r\n \r\ntom.Print();    // Имя: Tom  Возраст: 37\r\n \r\nclass Person \r\n{\r\n    public string name;\r\n    public int age;\r\n    public Person()\r\n    {\r\n        Console.WriteLine(&quot;Создание объекта Person&quot;);\r\n        name = &quot;Tom&quot;;\r\n        age = 37;\r\n    }\r\n    public void Print()\r\n    {\r\n        Console.WriteLine($&quot;Имя: {name}  Возраст: {age}&quot;);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Итак, здесь определен конструктор, который выводит на консоль некоторое сообщение и инициализирует поля класса.&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\npublic Person()\r\n{\r\n    Console.WriteLine(&quot;Создание объекта Person&quot;);\r\n    name = &quot;Tom&quot;;\r\n    age = 37;\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Конструкторы могут иметь модификаторы, которые указываются перед именем конструктора. Так, в данном случае, чтобы конструктор был доступен вне класса Person, он определен с модификатором &lt;strong&gt;public&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;p&gt;Определив конструктор, мы можем вызвать его для создания объекта Person:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson tom = new Person();  // Создание объекта Person\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае выражение &lt;strong&gt;Person()&lt;/strong&gt; как раз представляет вызов определенного в классе конструктора (это больше не автоматический конструктор по умолчанию, которого у класса теперь нет). \r\nСоответственно при его выполнении на консоли будет выводиться строка &quot;Создание объекта Person&quot;&lt;/p&gt;\r\n&lt;p&gt;Подобным образом мы можем определять и другие конструкторы в классе. Например, изменим класс Person следующим образом:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson tom = new Person();          // вызов 1-ого конструктора без параметров\r\nPerson bob = new Person(&quot;Bob&quot;);     //вызов 2-ого конструктора с одним параметром\r\nPerson sam = new Person(&quot;Sam&quot;, 25); // вызов 3-его конструктора с двумя параметрами\r\n \r\ntom.Print();          // Имя: Неизвестно  Возраст: 18\r\nbob.Print();          // Имя: Bob  Возраст: 18\r\nsam.Print();          // Имя: Sam  Возраст: 25\r\n \r\nclass Person \r\n{\r\n    public string name;\r\n    public int age;\r\n    public Person() { name = &quot;Неизвестно&quot;; age = 18; }      // 1 конструктор\r\n    public Person(string n) { name = n; age = 18; }         // 2 конструктор\r\n    public Person(string n, int a) { name = n; age = a; }   // 3 конструктор\r\n \r\n    public void Print()\r\n    {\r\n        Console.WriteLine($&quot;Имя: {name}  Возраст: {age}&quot;);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Теперь в классе определено три конструктора, каждый из которых принимает различное количество параметров и устанавливает значения \r\nполей класса. И мы можем вызвать один из этих конструкторов для создания объекта класса.&lt;/p&gt;\r\n&lt;p&gt;Консольный вывод данной программы:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Имя: Неизвестно  Возраст: 18\r\nИмя: Bob  Возраст: 18\r\nИмя: Sam  Возраст: 25\r\n&lt;/pre&gt;\r\n\r\n&lt;p&gt;Стоит отметить, что начиная с версии C# 9 мы можем сократить вызов конструктора, убрав из него название типа:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson tom = new ();            // аналогично new Person();\r\nPerson bob = new (&quot;Bob&quot;);       // аналогично new Person(&quot;Bob&quot;);\r\nPerson sam = new (&quot;Sam&quot;, 25);   // аналогично new Person(&quot;Sam&quot;, 25);\r\n&lt;/code&gt;\r\n&lt;h3&gt;Ключевое слово this&lt;/h3&gt;\r\n&lt;p&gt;Ключевое слово &lt;strong&gt;this&lt;/strong&gt; представляет ссылку на текущий экземпляр/объект класса. В каких ситуациях оно нам может пригодиться?&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson sam = new(&quot;Sam&quot;, 25); \r\nsam.Print();          // Имя: Sam  Возраст: 25\r\n \r\nclass Person \r\n{\r\n    public string name;\r\n    public int age;\r\n    public Person() { name = &quot;Неизвестно&quot;; age = 18; }\r\n    public Person(string name) { this.name = name; age = 18; }\r\n    public Person(string name, int age) \r\n    { \r\n        this.name = name; \r\n        this.age = age; \r\n    }\r\n    public void Print() =&gt; Console.WriteLine($&quot;Имя: {name}  Возраст: {age}&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В примере выше во втором и третьем конструкторе параметры называются также, как и поля класса. И чтобы разграничить параметры и поля класса, к полям класса обращение идет через ключевое слово &lt;strong&gt;this&lt;/strong&gt;. \r\nТак, в выражении&lt;/p&gt;\r\n&lt;pre class=&quot;b&quot;&gt;this.name = name;&lt;/pre&gt;\r\n&lt;p&gt;первая часть - &lt;strong&gt;this.name&lt;/strong&gt; означает, что &lt;strong&gt;name&lt;/strong&gt; - это \r\nполе текущего класса, а не название параметра name. Если бы у нас параметры и поля назывались по-разному, то использовать слово \r\n&lt;strong&gt;this&lt;/strong&gt; было бы необязательно. Также через ключевое слово &lt;strong&gt;this&lt;/strong&gt; можно обращаться к любому полю или методу.&lt;/p&gt;\r\n&lt;h3&gt;Цепочка вызова конструкторов&lt;/h3&gt;\r\n&lt;p&gt;В примере выше определены три конструктора. Все три конструктора выполняют однотипные действия - устанавливают значения полей name и age. Но этих повторяющихся действий могло быть больше. \r\nИ мы можем не дублировать функциональность конструкторов, а просто обращаться из одного конструктора к другому также через ключевое слово \r\n&lt;strong&gt;this&lt;/strong&gt;, передавая нужные значения для параметров:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Person \r\n{\r\n    public string name;\r\n    public int age;\r\n    public Person() : this(&quot;Неизвестно&quot;)    // первый конструктор\r\n    { }\r\n    public Person(string name) : this(name, 18) // второй конструктор\r\n    { }\r\n    public Person(string name, int age)     // третий конструктор\r\n    {\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n    public void Print() =&gt; Console.WriteLine($&quot;Имя: {name}  Возраст: {age}&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае первый конструктор вызывает второй, а второй конструктор вызывает третий. По количеству и типу параметров компилятор узнает, \r\nкакой именно конструктор вызывается. Например, во втором конструкторе:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\npublic Person(string name) : this(name, 18)\r\n{ }\r\n&lt;/code&gt;\r\n&lt;p&gt;идет обращение к третьему конструктору, которому передаются два значения. Причем в начале будет выполняться именно третий конструктор, и только потом код второго конструктора.&lt;/p&gt;\r\n&lt;p&gt;Стоит отметить, что в примере выше фактически все конструкторы не определяют каких-то других действий, кроме как передают третьему конструктору некоторые значения. Поэтому в реальности в данном случае \r\nпроще оставить один конструктор, определив для его параметров значения по умолчанию:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson tom = new();\r\nPerson bob = new(&quot;Bob&quot;);\r\nPerson sam = new(&quot;Sam&quot;, 25);\r\n \r\ntom.Print();          // Имя: Неизвестно  Возраст: 18\r\nbob.Print();          // Имя: Bob  Возраст: 18\r\nsam.Print();          // Имя: Sam  Возраст: 25\r\n \r\nclass Person \r\n{\r\n    public string name;\r\n    public int age;\r\n    public Person(string name = &quot;Неизвестно&quot;, int age = 18)\r\n    {\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n    public void Print() =&gt; Console.WriteLine($&quot;Имя: {name}  Возраст: {age}&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;И если при вызове конструктора мы не передаем значение для какого-то параметра, то применяется значение по умолчанию.&lt;/p&gt;\r\n&lt;h3&gt;Инициализаторы объектов&lt;/h3&gt;\r\n&lt;p&gt;Для инициализации объектов классов можно применять &lt;strong&gt;инициализаторы&lt;/strong&gt;. \r\nИнициализаторы представляют передачу в фигурных скобках значений доступным полям и свойствам объекта:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson tom = new Person { name = &quot;Tom&quot;, age = 31 };\r\n// или так\r\n// Person tom = new() { name = &quot;Tom&quot;, age = 31 };\r\ntom.Print();          // Имя: Tom  Возраст: 31\r\n&lt;/code&gt;\r\n&lt;p&gt;С помощью инициализатора объектов можно присваивать значения всем доступным полям и свойствам объекта в момент создания. При использовании инициализаторов следует учитывать следующие моменты:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;С помощью инициализатора мы можем установить значения только доступных из вне класса полей и свойств объекта. \r\nНапример, в примере выше поля name и age имеют модификатор доступа public, поэтому они доступны из любой части программы.&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Инициализатор выполняется после конструктора, поэтому если и в конструкторе, и в инициализаторе устанавливаются значения одних и тех же \r\nполей и свойств, то значения, устанавливаемые в конструкторе, заменяются значениями из инициализатора.&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Инициализаторы удобно применять, когда поле или свойство класса представляет другой класс:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson tom = new Person{ name = &quot;Tom&quot;, company = { title = &quot;Microsoft&quot;} };\r\ntom.Print();          // Имя: Tom  Компания: Microsoft\r\n \r\nclass Person\r\n{\r\n    public string name;\r\n    public Company company;\r\n    public Person() \r\n    { \r\n        name = &quot;Undefined&quot;;\r\n        company = new Company();\r\n    }\r\n    public void Print() =&gt; Console.WriteLine($&quot;Имя: {name}  Компания: {company.title}&quot;);\r\n}\r\n \r\nclass Company\r\n{\r\n    public string title = &quot;Unknown&quot;;\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Обратите внимание, как устанавливается поле &lt;strong&gt;company&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ncompany = { title = &quot;Microsoft&quot;}\r\n&lt;/code&gt;\r\n&lt;h3&gt;Деконструкторы&lt;/h3&gt;\r\n&lt;p&gt;Деконструкторы (не путать с деструкторами) позволяют выполнить декомпозицию объекта на отдельные части.&lt;/p&gt;\r\n&lt;p&gt;Например, пусть у нас есть следующий класс Person:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Person\r\n{\r\n    string name;\r\n    int age;\r\n    public Person(string name, int age)\r\n    {\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n \r\n    public void Deconstruct(out string personName, out int personAge)\r\n    {\r\n        personName = name;\r\n        personAge = age;\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В этом случае мы могли бы выполнить декомпозицию объекта Person так:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson person = new Person(&quot;Tom&quot;, 33);\r\n \r\n(string name, int age) = person;\r\n \r\nConsole.WriteLine(name);    // Tom\r\nConsole.WriteLine(age);     // 33\r\n&lt;/code&gt;\r\n&lt;p&gt;Значения переменным из деконструктора передаюся по позиции. То есть первое возвращаемое значение в виде параметра personName передается первой переменной - name, \r\nвторое возващаемое значение - переменной age.&lt;/p&gt;\r\n&lt;p&gt;По сути деконструкторы это не более,чем синтаксический сахар. Это все равно, что если бы мы написали:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson person = new Person(&quot;Tom&quot;, 33);\r\n \r\nstring name; int age;\r\nperson.Deconstruct(out name, out age);\r\n&lt;/code&gt;\r\n&lt;p&gt;При получении значений из декоструктора нам необходимо предоставить столько переменных, сколько деконструктор возвращает значений. Однако бывает, \r\nчто не все эти значения нужны. И вместо возвращаемых значений мы можм использовать прочерк &lt;strong&gt;_&lt;/strong&gt;. Например, нам \r\nнадо получить только возраст пользователя:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson person = new Person(&quot;Tom&quot;, 33);\r\n \r\n(_, int age) = person;\r\n \r\nConsole.WriteLine(age);    // 33\r\n&lt;/code&gt;\r\n&lt;p&gt;Поскольку первое возвращаемое значение - это имя пользователя, которое не нужно, в в данном случае вместо переменной прочерк.&lt;/p&gt;\r\n'),
(12, '', NULL, 1, 3, ''),
(13, '', NULL, 1, 3, ''),
(14, 'тест', 1, 4, 3, ''),
(15, '', NULL, 1, 3, ''),
(16, '', 2, 7, 3, ''),
(17, '', 2, 7, 3, '');
INSERT INTO `lectures` (`IDLecture`, `Name`, `IDChapter`, `SerialNumber`, `IDStatus`, `Content`) VALUES
(18, 'Циклы', 2, 7, 2, '&lt;p&gt;Циклы являются управляющими конструкциями, позволяя в зависимости от определенных условий выполнять некоторое действие множество раз. В \r\nC# имеются следующие виды циклов:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;for&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;foreach&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;while&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;do...while&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;h3&gt;Цикл for&lt;/h3&gt;\r\n&lt;p&gt;Цикл for имеет следующее формальное определение:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nfor ([действия_до_выполнения_цикла]; [условие]; [действия_после_выполнения])\r\n{\r\n    // действия\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Объявление цикла &lt;strong&gt;for&lt;/strong&gt; состоит из трех частей. Первая часть объявления цикла - некоторые действия, которые выполняются один раз \r\nдо выполнения цикла. Обычно здесь определяются переменные, которые будут использоваться в цикле.&lt;/p&gt;\r\n&lt;p&gt;Вторая часть - условие, при котором будет выполняться цикл. Пока условие равно &lt;strong&gt;true&lt;/strong&gt;, будет выполняться цикл.&lt;/p&gt;\r\n&lt;p&gt;И третья часть - некоторые действия, которые выполняются после завершения блока цикла. Эти действия выполняются каждый раз при завершении блока цикла.&lt;/p&gt;\r\n&lt;p&gt;После объявления цикла в фигурных скобках помещаются сами действия цикла.&lt;/p&gt;\r\n&lt;p&gt;Рассмотрим стандартный цикл for:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nfor (int i = 1; i &lt; 4; i++)\r\n{\r\n    Console.WriteLine(i);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь первая часть объявления цикла - &lt;strong&gt;int i = 1&lt;/strong&gt; - создает и инициализирует переменную i.&lt;/p&gt;\r\n&lt;p&gt;Вторая часть - условие &lt;strong&gt;i &lt; 4&lt;/strong&gt;. То есть пока переменная &lt;strong&gt;i&lt;/strong&gt; меньше 4, будет выполняться цикл.&lt;/p&gt;\r\n&lt;p&gt;И третья часть - действия, выполняемые после завершения действий из блока цикла - увеличение переменной &lt;strong&gt;i&lt;/strong&gt; на единицу.&lt;/p&gt;\r\n&lt;p&gt;Весь процесс цикла можно представить следующим образом:&lt;/p&gt;\r\n&lt;ol&gt;\r\n&lt;li&gt;&lt;p&gt;Определяется переменная &lt;strong&gt;int i = 1&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Проверяется условие &lt;strong&gt;i &lt; 4&lt;/strong&gt;. Оно истинно (так как 1 меньше 4), поэтому выполняется блок цикла, а именно инструкция \r\n&lt;strong&gt;Console.WriteLine(i)&lt;/strong&gt;, которая выводит на консоль значение переменной &lt;strong&gt;i&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Блок цикла закончил выполнение, поэтому выполняется треться часть объявления цикла - &lt;strong&gt;i++&lt;/strong&gt;. После этого переменная &lt;strong&gt;i&lt;/strong&gt; будет равна 2.&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Снова проверяется условие &lt;strong&gt;i &lt; 4&lt;/strong&gt;. Оно истинно (так как 2 меньше 4), поэтому опять выполняется блок цикла - \r\n&lt;strong&gt;Console.WriteLine(i)&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Блок цикла закончил выполнение, поэтому снова выполняется выражение &lt;strong&gt;i++&lt;/strong&gt;. После этого переменная &lt;strong&gt;i&lt;/strong&gt; будет равна 3.&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Снова проверяется условие &lt;strong&gt;i &lt; 4&lt;/strong&gt;. Оно истинно (так как 3 меньше 4), поэтому опять выполняется блок цикла - \r\n&lt;strong&gt;Console.WriteLine(i)&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Блок цикла закончил выполнение, поэтому снова выполняется выражение &lt;strong&gt;i++&lt;/strong&gt;. После этого переменная &lt;strong&gt;i&lt;/strong&gt; будет равна 4.&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Снова проверяется условие &lt;strong&gt;i &lt; 4&lt;/strong&gt;. Теперь оно возвражает &lt;strong&gt;false&lt;/strong&gt;, так как значение переменной i НЕ меньше 4, \r\nпоэтому цикл завершает выполнение. Далее уже выполняется остальная часть программы, которая идет после цикла&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;\r\n&lt;p&gt;В итоге блок цикла сработает 3 раза, пока значение i не станет равным 4. И каждый раз это значение будет увеличиваться на 1. Однократное выполнение блока цикла \r\nназывается &lt;strong&gt;итерацией&lt;/strong&gt;. Таким образом, здесь цикл выполнит три итерации. Результат работы программы:&lt;/p&gt;\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;1\r\n2\r\n3\r\n&lt;/pre&gt;\r\n&lt;p&gt;Если блок цикла &lt;strong&gt;for&lt;/strong&gt; содержит одну инструкцию, то мы можем его сократить, убрав фигурные свобки:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nfor (int i = 1; i &lt; 4; i++)\r\n    Console.WriteLine(i);\r\n \r\n// или так\r\nfor (int i = 1; i &lt; 4; i++) Console.WriteLine(i);\r\n&lt;/code&gt;\r\n&lt;p&gt;При этом необязательно именно в первой части цикла объявлять переменную, а в третий части изменять ее значение - это могут быть любые действия. Например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar i = 1;\r\n \r\nfor (Console.WriteLine(&quot;Начало выполнения цикла&quot;); i &lt; 4; Console.WriteLine($&quot;i = {i}&quot;))\r\n{\r\n    i++;\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь опять же цикл срабатывает, пока переменная i меньше 4, только приращение переменной i происходит в блоке цикла. Консольный вывод данной программы:&lt;/p&gt;\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Начало выполнения цикла\r\ni = 2\r\ni = 3\r\ni = 4\r\n&lt;/pre&gt;\r\n\r\n\r\n&lt;p&gt;Нам необязательно указывать все условия при объявлении цикла. Например, мы можем написать так:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint i = 1;\r\nfor (; ;)\r\n{\r\n    Console.WriteLine($&quot;i = {i}&quot;);\r\n    i++;\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Формально определение цикла осталось тем же, только теперь блоки в определении у нас пустые: &lt;strong&gt;for (; ;)&lt;/strong&gt;. У нас нет \r\nинициализированной переменной, нет условия, поэтому цикл будет работать вечно - бесконечный цикл.&lt;/p&gt;\r\n&lt;p&gt;Мы также можем опустить ряд блоков:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint i = 1;\r\nfor (; i&lt;4;)\r\n{\r\n    Console.WriteLine($&quot;i = {i}&quot;);\r\n    i++;\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Этот пример по сути эквивалентен первому примеру: у нас также есть переменная-счетчик, только определена она вне цикла. У нас есть условие выполнения цикла. \r\nИ есть приращение переменной уже в самом блоке for.&lt;/p&gt;\r\n&lt;p&gt;Также стоит отметить, что можно определять несколько переменных в объявлении цикла:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nfor (int i = 1, j = 1; i &lt; 10; i++, j++)\r\n    Console.WriteLine($&quot;{i * j}&quot;);\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь в первой части объявления цикла определяются две переменных: i и j. Цикл выполняется, пока i не будет равна 10. После каждой итерации \r\nпеременые i и j увеличиваются на единицу. Консольный вывод программы:&lt;/p&gt;\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;0\r\n1\r\n4\r\n9\r\n16\r\n25\r\n36\r\n49\r\n64\r\n81\r\n&lt;/pre&gt;\r\n&lt;h3&gt;Цикл do..while&lt;/h3&gt;\r\n&lt;p&gt;В цикле do сначала выполняется код цикла, а потом происходит проверка условия в инструкции while. И пока это условие истинно, \r\nцикл повторяется.&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ndo\r\n{\r\n    действия цикла\r\n}\r\nwhile (условие)\r\n&lt;/code&gt;\r\n&lt;p&gt;Например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint i = 6;\r\ndo\r\n{\r\n    Console.WriteLine(i);\r\n    i--;\r\n}\r\nwhile (i &gt; 0);\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь код цикла сработает 6 раз, пока i не станет равным нулю. Но важно отметить, что цикл do гарантирует хотя бы единократное выполнение действий, \r\nдаже если условие в инструкции while не будет истинно. То есть мы можем написать:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint i = -1;\r\ndo\r\n{\r\n    Console.WriteLine(i);\r\n    i--;\r\n}\r\nwhile (i &gt; 0);\r\n&lt;/code&gt;\r\n&lt;p&gt;Хотя у нас переменная i меньше 0, цикл все равно один раз выполнится.&lt;/p&gt;\r\n&lt;h3&gt;Цикл while&lt;/h3&gt;\r\n&lt;p&gt;В отличие от цикла do цикл &lt;strong&gt;while&lt;/strong&gt; сразу проверяет истинность некоторого условия, и если условие истинно, то код цикла выполняется:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nwhile (условие)\r\n{\r\n    действия цикла\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint i = 6;\r\nwhile (i &gt; 0)\r\n{\r\n    Console.WriteLine(i);\r\n    i--;\r\n}\r\n&lt;/code&gt;\r\n&lt;h3&gt;Цикл foreach&lt;/h3&gt;\r\n&lt;p&gt;Цикл foreach предназначен для перебора набора или коллекции элементов. Его общее определение:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nforeach(тип_данных переменная in коллекция)\r\n{\r\n    // действия цикла\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;После оператора &lt;strong&gt;foreach&lt;/strong&gt; в скобках сначала идет определение переменной. Затем ключевое слово &lt;strong&gt;in&lt;/strong&gt; и далее коллекция, \r\nэлементы которой надо перебрать.&lt;/p&gt;\r\n&lt;p&gt;При выполнении цикл последовательно перебирает элементы коллекции и помещает их в переменную, и таким образом в блоке цикла мы можем выполнить с ними некоторые действия.&lt;/p&gt;\r\n&lt;p&gt;Например, возьмем строку. Строка по сути - это коллекция символов. И .NET позволяет перебрать все элементы строки - ее символы с помощью цикла &lt;strong&gt;foreach&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nforeach(char c in &quot;Tom&quot;)\r\n{\r\n    Console.WriteLine(c);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь цикл foreach пробегается по всем символам строки &quot;Tom&quot; и каждый символ помещает в символьную переменную &lt;strong&gt;c&lt;/strong&gt;. В блоке цикла \r\nзначение переменной &lt;strong&gt;c&lt;/strong&gt; выводится на консоль. Поскольку в строке &quot;Tom&quot; три символа, то цикл выполнится три раза. Консольный вывод программы:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;T\r\no\r\nm&lt;/pre&gt;\r\n\r\n&lt;p&gt;Стоит отметить, что определяемая в объявлении цикла должна по типу соответствовать типу элементов перебираемой коллекции. Так, элементы строки - значения типа \r\n&lt;strong&gt;char&lt;/strong&gt; - символы. Поэтому переменная &lt;strong&gt;c&lt;/strong&gt; имеет тип &lt;strong&gt;char&lt;/strong&gt;. Однако в реальности не всегда бывает очевидно, какой тип представляют \r\nэлементы коллекции. В этом случае мы можем определить переменную с помощью оператора &lt;strong&gt;var&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nforeach(var c in &quot;Tom&quot;)\r\n{\r\n    Console.WriteLine(c);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В дальнейшем мы подробнее рассмотрим, что представляют собой коллекции в .NET и какие именно коллекции можно перебирать с помощью цикла &lt;strong&gt;foreach&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;h3&gt;Операторы continue и break&lt;/h3&gt;\r\n&lt;p&gt;Иногда возникает ситуация, когда требуется выйти из цикла, не дожидаясь его завершения. В этом случае мы можем воспользоваться оператором \r\n&lt;strong&gt;break&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;p&gt;Например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nfor (int i = 0; i &lt; 9; i++)\r\n{\r\n    if (i == 5)\r\n        break;\r\n    Console.WriteLine(i);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Хотя в условии цикла сказано, что цикл будет выполняться, пока счетчик i не достигнет значения 9, в реальности цикл сработает 5 раз. \r\nТак как при достижении счетчиком i значения 5, сработает оператор break, и цикл завершится.&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;0\r\n1\r\n2\r\n3\r\n4\r\n&lt;/pre&gt;\r\n\r\n&lt;p&gt;Теперь поставим себе другую задачу. А что если мы хотим, чтобы при проверке цикл не завершался, а просто пропускал текущую итерацию. \r\nДля этого мы можем воспользоваться оператором &lt;strong&gt;continue&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nfor (int i = 0; i &lt; 9; i++)\r\n{\r\n    if (i == 5)\r\n        continue;\r\n    Console.WriteLine(i);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В этом случае цикл, когда дойдет до числа 5, которое не удовлетворяет условию проверки, просто пропустит это число и перейдет к следующей итерации:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;0\r\n1\r\n2\r\n3\r\n4\r\n6\r\n7\r\n8\r\n&lt;/pre&gt;\r\n\r\n&lt;p&gt;Стоит отметить, что операторы &lt;strong&gt;break&lt;/strong&gt; и &lt;strong&gt;continue&lt;/strong&gt; можно применять в любом типе циклов.&lt;/p&gt;\r\n&lt;h3&gt;Вложенные циклы&lt;/h3&gt;\r\n&lt;p&gt;Одни циклы могут быть вложенными в другие. Например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nfor (int i = 1; i &lt; 10; i++)\r\n{\r\n    for (int j = 1; j &lt; 10; j++)\r\n    {\r\n        Console.Write($&quot;{i * j} \\t&quot;);\r\n    }\r\n    Console.WriteLine();\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае цикл &lt;strong&gt;for (int i = 1; i &lt; 10; i++)&lt;/strong&gt; выполняется 9 раз, то есть имеет 9 итераций. Но в рамках каждой итерации \r\nвыполняется девять раз вложенный цикл &lt;strong&gt;for (int j = 1; j &lt; 10; j++)&lt;/strong&gt;. В итоге данная программа выведет таблицу умножения.&lt;/p&gt;'),
(19, 'Массивы', 2, 8, 2, '&lt;p&gt;Массив представляет набор однотипных данных. Объявление массива похоже на объявление переменной за тем исключением, что после указания типа ставятся квадратные скобки:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nтип_переменной[] название_массива;\r\n&lt;/code&gt;\r\n&lt;p&gt;Например, определим массив целых чисел:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint[] numbers;\r\n&lt;/code&gt;\r\n&lt;p&gt;После определения переменной массива мы можем присвоить ей определенное значение:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint[] nums = new int[4];\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь вначале мы объявили массив nums, который будет хранить данные типа &lt;strong&gt;int&lt;/strong&gt;. Далее используя операцию &lt;strong&gt;new&lt;/strong&gt;, \r\nмы выделили память для 4 элементов массива: &lt;strong&gt;new int[4]&lt;/strong&gt;. Число 4 еще называется &lt;strong&gt;длиной массива&lt;/strong&gt;. \r\nПри таком определении все элементы получают значение по умолчанию, которое предусмотренно для их типа. Для типа int значение по умолчанию - 0.&lt;/p&gt;\r\n&lt;p&gt;Также мы сразу можем указать значения для этих элементов:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint[] nums2 = new int[4] { 1, 2, 3, 5 };\r\n \r\nint[] nums3 = new int[] { 1, 2, 3, 5 };\r\n \r\nint[] nums4 = new[] { 1, 2, 3, 5 };\r\n \r\nint[] nums5 = { 1, 2, 3, 5 };\r\n&lt;/code&gt;\r\n&lt;p&gt;Все перечисленные выше способы будут равноценны.&lt;/p&gt;\r\n&lt;p&gt;Подобным образом можно определять массивы и других типов, например, массив значений типа &lt;strong&gt;string&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nstring[] people = { &quot;Tom&quot;, &quot;Sam&quot;, &quot;Bob&quot; };\r\n&lt;/code&gt;\r\n&lt;h3&gt;Индексы и получение элементов массива&lt;/h3&gt;\r\n&lt;p&gt;Для обращения к элементам массива используются &lt;strong&gt;индексы&lt;/strong&gt;. Индекс представляет номер элемента в массиве, при этом нумерация начинается с \r\nнуля, поэтому индекс первого элемента будет равен 0, индекс четвертого элемента - 3.&lt;/p&gt;\r\n&lt;p&gt;Используя индексы, мы можем получить элементы массива:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint[] numbers = { 1, 2, 3, 5 };\r\n \r\n// получение элемента массива\r\nConsole.WriteLine(numbers[3]);  // 5\r\n \r\n// получение элемента массива в переменную\r\nvar n = numbers[1];     // 2\r\nConsole.WriteLine(n);  // 2\r\n&lt;/code&gt;\r\n&lt;p&gt;Также мы можем изменить элемент массива по индексу:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint[] numbers = { 1, 2, 3, 5 };\r\n \r\n// изменим второй элемент массива\r\nnumbers[1] = 505;\r\n \r\nConsole.WriteLine(numbers[1]);  // 505\r\n&lt;/code&gt;\r\n&lt;p&gt;И так как у нас массив определен только для 4 элементов, то мы не можем обратиться, например, к шестому элементу. \r\nЕсли мы так попытаемся сделать, то мы получим ошибку во время выполнения:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint[] numbers = { 1, 2, 3, 5 };\r\n \r\nConsole.WriteLine(numbers[6]);  // ! Ошибка - в массиве только 4 элемента\r\n&lt;/code&gt;\r\n&lt;h3&gt;Свойство Length и длина массива&lt;/h3&gt;\r\n&lt;p&gt;каждый массив имеет свойство &lt;strong&gt;Length&lt;/strong&gt;, которое хранит длину массива. Например, получим длину выше созданного массива numbers:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint[] numbers = { 1, 2, 3, 5 };\r\n \r\nConsole.WriteLine(numbers.Length);  // 4\r\n&lt;/code&gt;\r\n&lt;p&gt;Для получения длины массива после названия массива через точку указывается свойство &lt;strong&gt;Length&lt;/strong&gt;: &lt;strong&gt;numbers.Length&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;h3&gt;Получение элементов с конца массива&lt;/h3&gt;\r\n&lt;p&gt;Благодаря наличию свойства &lt;strong&gt;Length&lt;/strong&gt;, мы можем вычислить индекс последнего элемента массива - это длина массива - 1. Например, если длина массива - 4 (то есть \r\nмассив имеет 4 элемента), то индекс последнего элемента будет равен 3. И, используя свойство &lt;strong&gt;Length&lt;/strong&gt;, мы можем легко получить элементы с конца массива:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint[] numbers = { 1, 2, 3, 5};\r\n \r\nConsole.WriteLine(numbers[numbers.Length - 1]);  // 5 - первый с конца или последний элемент\r\nConsole.WriteLine(numbers[numbers.Length - 2]);  // 3 - второй с конца или предпоследний элемент\r\nConsole.WriteLine(numbers[numbers.Length - 3]);  // 2 - третий элемент с конца\r\n&lt;/code&gt;\r\n&lt;p&gt;Однако при подобном подходе выражения типа &lt;strong&gt;numbers.Length - 1&lt;/strong&gt;, смысл которых состоит в том, чтобы получить какой-то определенный элемент с конца массива, \r\nутяжеляют код. И, начиная, с версии C# 8.0 в язык был добавлен специальный оператор &lt;strong&gt;^&lt;/strong&gt;, \r\nс помощью которого можно задать индекс относительно конца коллекции.&lt;/p&gt;\r\n&lt;p&gt;Перепишем предыдущий пример, применяя оператор &lt;strong&gt;^&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint[] numbers = { 1, 2, 3, 5};\r\n \r\nConsole.WriteLine(numbers[^1]);  // 5 - первый с конца или последний элемент\r\nConsole.WriteLine(numbers[^2]);  // 3 - второй с конца или предпоследний элемент\r\nConsole.WriteLine(numbers[^3]);  // 2 - третий элемент с конца\r\n&lt;/code&gt;\r\n&lt;h3&gt;Перебор массивов&lt;/h3&gt;\r\n&lt;p&gt;Для перебора массивов мы можем использовать различные типы циклов. Например, цикл &lt;strong&gt;foreach&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint[] numbers = { 1, 2, 3, 4, 5 };\r\nforeach (int i in numbers)\r\n{\r\n    Console.WriteLine(i);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь в качестве контейнера выступает массив данных типа &lt;strong&gt;int&lt;/strong&gt;. Поэтому мы объявляем переменную с типом &lt;strong&gt;int&lt;/strong&gt;&lt;/p&gt;\r\n&lt;p&gt;Подобные действия мы можем сделать и с помощью цикл for:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint[] numbers = { 1, 2, 3, 4, 5 };\r\nfor (int i = 0; i &lt; numbers.Length; i++)\r\n{\r\n    Console.WriteLine(numbers[i]);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В то же время цикл &lt;strong&gt;for&lt;/strong&gt; более гибкий по сравнению с &lt;strong&gt;foreach&lt;/strong&gt;. Если &lt;strong&gt;foreach&lt;/strong&gt; последовательно извлекает элементы контейнера и только для чтения, \r\nто в цикле for мы можем перескакивать на несколько элементов вперед в зависимости от приращения счетчика, а также можем изменять элементы:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint[] numbers = { 1, 2, 3, 4, 5 };\r\nfor (int i = 0; i &lt; numbers.Length; i++)\r\n{\r\n    numbers[i] = numbers[i] * 2;\r\n    Console.WriteLine(numbers[i]);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Также можно использовать и другие виды циклов, например, &lt;strong&gt;while&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint[] numbers = { 1, 2, 3, 4, 5 };\r\nint i = 0;\r\nwhile(i &lt; numbers.Length)\r\n{\r\n    Console.WriteLine(numbers[i]);\r\n    i++;\r\n}\r\n&lt;/code&gt;\r\n&lt;h3&gt;Многомерные массивы&lt;/h3&gt;\r\n&lt;p&gt;Массивы характеризуются таким понятием как &lt;strong&gt;ранг&lt;/strong&gt; или количество измерений. Выше мы рассматривали \r\nмассивы, которые имеют одно измерение (то есть их ранг равен 1) - такие массивы можно представлять в виде ряда (строки или столбца) элемента. \r\nНо массивы также бывают многомерными. У таких массивов количество измерений (то есть ранг) больше 1.&lt;/p&gt;\r\n&lt;p&gt;Массивы которые имеют два измерения (ранг равен 2) называют двухмерными. Например, создадим одномерный и двухмерный массивы, которые имеют одинаковые элементы:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint[] nums1 = new int[] { 0, 1, 2, 3, 4, 5 };\r\n \r\nint[,] nums2 = { { 0, 1, 2 }, { 3, 4, 5 } };\r\n&lt;/code&gt;\r\n&lt;p&gt;Визуально оба массива можно представить следующим образом:&lt;/p&gt;\r\n&lt;h5&gt;Одномерный массив nums1&lt;/h5&gt;\r\n&lt;code&gt;\r\n012345\r\n&lt;/code&gt;\r\n&lt;h5&gt;Двухмерный массив nums2&lt;/h5&gt;\r\n&lt;code&gt;\r\n012\r\n345\r\n&lt;/code&gt;\r\n&lt;p&gt;Поскольку массив nums2 двухмерный, он представляет собой простую таблицу. Все возможные способы определения двухмерных массивов:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint[,] nums1;\r\nint[,] nums2 = new int[2, 3];\r\nint[,] nums3 = new int[2, 3] { { 0, 1, 2 }, { 3, 4, 5 } };\r\nint[,] nums4 = new int[,] { { 0, 1, 2 }, { 3, 4, 5 } };\r\nint[,] nums5 = new [,]{ { 0, 1, 2 }, { 3, 4, 5 } };\r\nint[,] nums6 = { { 0, 1, 2 }, { 3, 4, 5 } };\r\n&lt;/code&gt;\r\n&lt;p&gt;Массивы могут иметь и большее количество измерений. Объявление трехмерного массива могло бы выглядеть так:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint[,,] nums3 = new int[2, 3, 4];\r\n&lt;/code&gt;\r\n&lt;p&gt;Соответственно могут быть и четырехмерные массивы и массивы с большим количеством измерений. Но на практике \r\nобычно используются одномерные и двухмерные массивы.&lt;/p&gt;\r\n&lt;p&gt;Определенную сложность может представлять перебор многомерного массива. Прежде всего надо учитывать, что длина такого массива - это совокупное количество элементов.&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint[,] numbers = { { 1, 2, 3 }, { 4, 5, 6 }};\r\nforeach (int i in numbers)\r\n    Console.Write($&quot;{i} &quot;);\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае длина массива numbers равна 6. И цикл foreach выводит все элементы массива в строку:&lt;/p&gt;\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;1 2 3 4 5 6&lt;/pre&gt;\r\n\r\n&lt;p&gt;Но что если мы хотим отдельно пробежаться по каждой строке в таблице? В этом случае надо получить количество элементов в размерности. \r\nВ частности, у каждого массива есть метод &lt;strong&gt;GetUpperBound(номер_размерности)&lt;/strong&gt;, который возвращает индекс последнего \r\nэлемента в определенной размерности. И если мы говорим непосредственно о двухмерном массиве, то первая размерность (с индексом 0) \r\nпо сути это и есть таблица. И с помощью выражения&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nnumbers.GetUpperBound(0) + 1\r\n&lt;/code&gt;\r\n&lt;p&gt;можно получить количество строк таблицы, представленной двухмерным массивом. А через&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nnumbers.Length / количество_строк\r\n&lt;/code&gt;\r\n&lt;p&gt;можно получить количество элементов в каждой строке:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint[,] numbers = { { 1, 2, 3 }, { 4, 5, 6 }};\r\n \r\nint rows = numbers.GetUpperBound(0) + 1;    // количество строк\r\nint columns = numbers.Length / rows;        // количество столбцов\r\n// или так\r\n// int columns = numbers.GetUpperBound(1) + 1;\r\n \r\nfor (int i = 0; i &lt; rows; i++)\r\n{\r\n    for (int j = 0; j &lt; columns; j++)\r\n    {\r\n        Console.Write($&quot;{numbers[i, j]} \\t&quot;);\r\n    }\r\n    Console.WriteLine();\r\n}\r\n&lt;/code&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;1	2	3\r\n4	5	6\r\n&lt;/pre&gt;\r\n\r\n&lt;h3&gt;Массив массивов&lt;/h3&gt;\r\n&lt;p&gt;От многомерных массивов надо отличать &lt;strong&gt;массив массивов&lt;/strong&gt; или так называемый &quot;зубчатый массив&quot;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint[][] nums = new int[3][];\r\nnums[0] = new int[2] { 1, 2 };          // выделяем память для первого подмассива\r\nnums[1] = new int[3] { 1, 2, 3 };       // выделяем память для второго подмассива\r\nnums[2] = new int[5] { 1, 2, 3, 4, 5 }; // выделяем память для третьего подмассива\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь две группы квадратных скобок указывают, что это &lt;strong&gt;массив массивов&lt;/strong&gt;, то есть такой массив, который в свою очередь содержит в себе \r\nдругие массивы. Причем длина массива указывается только в первых квадратных скобках, все последующие квадратные скобки должны быть пусты: \r\n&lt;strong&gt;new int[3][]&lt;/strong&gt;. В данном случае у нас массив nums содержит три массива. Причем размерность каждого из этих массивов может не совпадать.&lt;/p&gt;\r\n&lt;p&gt;Альтернативное определение массива массивов:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint[][] numbers = { \r\n    new int[] { 1, 2 }, \r\n    new int[] { 1, 2, 3 }, \r\n    new int[] { 1, 2, 3, 4, 5 } \r\n};\r\n&lt;/code&gt;\r\n&lt;h5&gt;Зубчатый массив nums&lt;/h5&gt;\r\n&lt;code&gt;\r\n\r\n12\r\n123\r\n12345\r\n\r\n&lt;/code&gt;\r\n&lt;p&gt;Используя вложенные циклы, можно перебирать зубчатые массивы. Например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint[][] numbers = new int[3][];\r\nnumbers[0] = new int[] { 1, 2 };\r\nnumbers[1] = new int[] { 1, 2, 3 };\r\nnumbers[2] = new int[] { 1, 2, 3, 4, 5 };\r\nforeach(int[] row in numbers)\r\n{\r\n    foreach(int number in row)\r\n    {\r\n        Console.Write($&quot;{number} 	&quot;);\r\n    }\r\n    Console.WriteLine();\r\n}\r\n \r\n// перебор с помощью цикла for\r\nfor (int i = 0; i&lt;numbers.Length;i++)\r\n{\r\n    for (int j =0; j&lt;numbers[i].Length; j++)\r\n    {\r\n        Console.Write($&quot;{numbers[i][j]} 	&quot;);\r\n    }\r\n    Console.WriteLine();\r\n}\r\n&lt;/code&gt;\r\n&lt;h3&gt;Основные понятия массивов&lt;/h3&gt;\r\n&lt;p&gt;Суммируем основные понятия массивов:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Ранг&lt;/strong&gt; (rank): количество измерений массива&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Длина измерения&lt;/strong&gt; (dimension length): длина отдельного измерения массива&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Длина массива&lt;/strong&gt; (array length): количество всех элементов массива&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Например, возьмем массив&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint[,] numbers = new int[3, 4];\r\n&lt;/code&gt;\r\n&lt;p&gt;Массив numbers двухмерный, то есть он имеет два измерения, поэтому его ранг равен 2. Длина первого измерения - 3, длина второго измерения - 4. Длина массива (то есть общее количество элементов) - 12.&lt;/p&gt;\r\n&lt;p&gt;Примеры массивов:&lt;/p&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/array.png&quot; alt=&quot;Массивы в языке C#&quot;&gt;\r\n'),
(20, 'Конструкция switch', 2, 9, 2, '&lt;p&gt;Конструкция &lt;strong&gt;switch/case&lt;/strong&gt; оценивает некоторое выражение и сравнивает его значение с набором значений. \r\nИ при совпадении значений выполняет определенный код.:&lt;/p&gt;\r\n&lt;p&gt;Конструкция switch имеет следующее формальное определение:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nswitch (выражение)\r\n{\r\n    case значение1:\r\n        код,выполняемый если выражение имеет значение1\r\n        break;\r\n    case значение2:\r\n        код,выполняемый если выражение имеет значение1\r\n        break;\r\n    //.............\r\n    case значениеN:\r\n        код, выполняемый если выражение имеет значениеN\r\n        break;\r\n    default:\r\n        код, выполняемый если выражение не имеет ни одно из выше указанных значений\r\n        break;\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;После ключевого слова &lt;strong&gt;switch&lt;/strong&gt; в скобках идет сравниваемое выражение. Значение этого выражения последовательно \r\nсравнивается со значениями, помещенными после оператора &lt;strong&gt;сase&lt;/strong&gt;. И если совпадение будет найдено, то будет \r\nвыполняться определенный блок &lt;strong&gt;сase&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;p&gt;В конце каждого блока сase должен ставиться один из операторов перехода: \r\n&lt;strong&gt;break&lt;/strong&gt;, &lt;strong&gt;goto case&lt;/strong&gt;, &lt;strong&gt;return&lt;/strong&gt; или &lt;strong&gt;throw&lt;/strong&gt;. \r\nКак правило, используется оператор &lt;strong&gt;break&lt;/strong&gt;. При его применении другие блоки &lt;strong&gt;case&lt;/strong&gt; выполняться не будут.&lt;/p&gt;\r\n&lt;p&gt;Например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nstring name = &quot;Tom&quot;;\r\n \r\nswitch (name)\r\n{\r\n    case &quot;Bob&quot;:\r\n        Console.WriteLine(&quot;Ваше имя - Bob&quot;);\r\n        break;\r\n    case &quot;Tom&quot;:\r\n        Console.WriteLine(&quot;Ваше имя - Tom&quot;);\r\n        break;\r\n    case &quot;Sam&quot;:\r\n        Console.WriteLine(&quot;Ваше имя - Sam&quot;);\r\n        break;\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае конструкция &lt;strong&gt;switch&lt;/strong&gt; последовательно сравнивает значение переменной &lt;strong&gt;name&lt;/strong&gt; с набором значений, \r\nкоторые указаны после операторов &lt;strong&gt;case&lt;/strong&gt;. Поскольку здесь значение переменной &lt;strong&gt;name&lt;/strong&gt; - строка &quot;Tom&quot;, то будет выполняться блок&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ncase &quot;Tom&quot;:\r\n    Console.WriteLine(&quot;Ваше имя - Tom&quot;);\r\n    break;\r\n&lt;/code&gt;\r\n&lt;p&gt;Соответственно мы увидим на консоли&lt;/p&gt;\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Ваше имя - Tom&lt;/pre&gt;\r\n&lt;p&gt;Если значение переменной &lt;strong&gt;name&lt;/strong&gt; не совпадает ни с каким значением после операторов &lt;strong&gt;case&lt;/strong&gt;, то ни один из блоков case не выполняется. \r\nОднако если даже в этом случае нам все равно надо выполнить какие-нибудь действия, то мы можем добавить в конструкцию &lt;strong&gt;switch&lt;/strong&gt; необязательный \r\nблок &lt;strong&gt;default&lt;/strong&gt;. Например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nstring name = &quot;Alex&quot;;\r\n \r\nswitch (name)\r\n{\r\n    case &quot;Bob&quot;:\r\n        Console.WriteLine(&quot;Ваше имя - Bob&quot;);\r\n        break;\r\n    case &quot;Tom&quot;:\r\n        Console.WriteLine(&quot;Ваше имя - Tom&quot;);\r\n        break;\r\n    case &quot;Sam&quot;:\r\n        Console.WriteLine(&quot;Ваше имя - Sam&quot;);\r\n        break;\r\n    default:\r\n        Console.WriteLine(&quot;Неизвестное имя&quot;);\r\n        break;\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае никакое из значений после операторов case не совпадает со значением переменной name, поэтому будет выполняться блок default:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ndefault:\r\n    Console.WriteLine(&quot;Неизвестное имя&quot;);\r\n    break;\r\n&lt;/code&gt;\r\n\r\n&lt;p&gt;Однако если мы хотим, чтобы, наоборот, после выполнения текущего блока case выполнялся другой блок case, то мы можем использовать вместо break оператор \r\n&lt;strong&gt;goto case&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint number = 1;\r\nswitch (number)\r\n{\r\n    case 1:\r\n        Console.WriteLine(&quot;case 1&quot;);\r\n        goto case 5; // переход к case 5\r\n    case 3:\r\n        Console.WriteLine(&quot;case 3&quot;);\r\n        break;\r\n    case 5:\r\n        Console.WriteLine(&quot;case 5&quot;);\r\n        break;\r\n    default:\r\n        Console.WriteLine(&quot;default&quot;);\r\n        break;\r\n}\r\n&lt;/code&gt;\r\n&lt;h3&gt;Возвращение значения из switch&lt;/h3&gt;\r\n&lt;p&gt;Конструкция &lt;strong&gt;switch&lt;/strong&gt; позволяет возвращать некоторое значение. Для возвращения значения в блоках &lt;strong&gt;case&lt;/strong&gt; может применятся \r\nоператор &lt;strong&gt;return&lt;/strong&gt;. Например, определим следующий метод:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint DoOperation(int op, int a, int b)\r\n{\r\n    switch (op)\r\n    {\r\n        case 1: return a + b;\r\n        case 2: return a - b;\r\n        case 3: return a * b;\r\n        default: return 0;\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В метод &lt;strong&gt;DoOperation()&lt;/strong&gt; передается числовой код операции и два операнда. В зависимости от кода операции над операндами \r\nвыполнется определенная операция и ее результат возвращается из метода. Для примера при по умолчанию из метода возвращается 0, если код операции не равен 1, 2 или 3.&lt;/p&gt;\r\n&lt;p&gt;Затем мы можем вызвать этот метод:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint DoOperation(int op, int a, int b)\r\n{\r\n    switch (op)\r\n    {\r\n        case 1: return a + b;\r\n        case 2: return a - b;\r\n        case 3: return a * b;\r\n        default: return 0;\r\n    }\r\n}\r\n \r\nint result1 = DoOperation(1, 10, 5); // 15\r\nConsole.WriteLine(result1);         // 15\r\n \r\nint result2 = DoOperation(3, 10, 5); // 50\r\nConsole.WriteLine(result2);         // 50\r\n&lt;/code&gt;\r\n&lt;h3&gt;Получение результата из switch&lt;/h3&gt;\r\n&lt;p&gt;Хотя конструкция &lt;strong&gt;switch&lt;/strong&gt; в примере выше прекрасно работает, тем не менее мы ее можем сократить и получить результат неосредственно из конструкции \r\n&lt;strong&gt;switch&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint DoOperation(int op, int a, int b)\r\n{\r\n    int result = op switch {\r\n        1 =&gt; a + b,\r\n        2 =&gt; a - b,\r\n        3 =&gt; a * b,\r\n        _ =&gt; 0\r\n    };\r\n    return result;\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Теперь не требуется оператор &lt;strong&gt;case&lt;/strong&gt;, а после сравниваемого значения ставится оператор стрелка &lt;strong&gt;=&gt;&lt;/strong&gt;. \r\nЗначение справа от стрелки выступает в качестве возвращаемоего значения. Кроме того, вместо оператора &lt;strong&gt;default&lt;/strong&gt; \r\nиспользуется почерк _. В итоге результат конструкции switch будет присвиваиваться \r\nпеременной result.&lt;/p&gt;\r\n&lt;p&gt;Естестввенно, мы можем сразу возвратить из метода результат без присвоения переменной результата конструкции switch:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint DoOperation(int op, int a, int b)\r\n{\r\n    return op switch\r\n    {\r\n        1 =&gt; a + b,\r\n        2 =&gt; a - b,\r\n        3 =&gt; a * b,\r\n        _ =&gt; 0\r\n    };\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Или сделать метод еще короче:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint DoOperation(int op, int a, int b) =&gt; op switch\r\n{\r\n    1 =&gt; a + b,\r\n    2 =&gt; a - b,\r\n    3 =&gt; a * b,\r\n    _ =&gt; 0\r\n};\r\n&lt;/code&gt;\r\n&lt;p&gt;Обращаю внимание, что данное упрощение касается лишь таких конструкций &lt;strong&gt;switch&lt;/strong&gt;, которые &lt;strong&gt;возвращают&lt;/strong&gt; некоторые значения, как в примере выше.&lt;/p&gt;\r\n\r\n&lt;p&gt;Стоит отметить, что при возвращении значения из метода, метод должен в любом случае возвращать значение. Например, следующая версия \r\nметода не будет работать&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint DoOperation(int op, int a, int b)\r\n{\r\n    return op switch\r\n    {\r\n        1 =&gt; a + b,\r\n        2 =&gt; a - b,\r\n        3 =&gt; a * b\r\n    };\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Эта версия метода возвращает значение, если код операции равен 1, 2 или 3. Но что, если будет передано значение 4 или какое-то другое? Поэтому \r\nданная версия метода даже не скомпилируется. Поэтому нам надо предусмотреть возвращение значения из метода при всех возможных вариантах. \r\nТо есть, мы можем, как в примере выше, добавить в конструкцию switch блок default, в котором будет возвращаться значение при всех остальных случаях.&lt;/p&gt;\r\n'),
(21, 'Перечисления enum', 2, 10, 2, '&lt;p&gt;Кроме примитивных типов данных в языке программирования C# есть такой тип как &lt;strong&gt;enum&lt;/strong&gt; или \r\n&lt;strong&gt;перечисление&lt;/strong&gt;. Перечисления представляют набор логически связанных констант.&lt;/p&gt; \r\n&lt;p&gt;Объявление перечисления происходит с помощью оператора &lt;strong&gt;enum&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nenum название_перечисления\r\n{\r\n    // значения перечисления\r\n    значение1,\r\n    значение2,\r\n    .......\r\n    значениеN\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;После оператора &lt;strong&gt;enum&lt;/strong&gt; идет название перечисления. И затем в фигурных скобках через запятую перечисляются константы перечисления.&lt;/p&gt;\r\n&lt;p&gt;Определим простейшее перечисление:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nenum DayTime\r\n{\r\n    Morning,\r\n    Afternoon,\r\n    Evening,\r\n    Night\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь определено перечисление DayTime, которое имеет четыре значения: &lt;strong&gt;Morning, Afternoon, Evening&lt;/strong&gt; и &lt;strong&gt;Night&lt;/strong&gt;&lt;/p&gt;\r\n&lt;p&gt;Каждое перечисление фактически определяет новый тип данных, с помощью которых мы также, как и с помощью любого другого типа, можем определять переменные, константы, параметры методов и т.д. \r\nВ качестве значения переменной, константы и параметра метода, которые представляют перечисление, должна выступать одна из констант \r\nэтого перечисления, например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nconst DayTime dayTime = DayTime.Morning;\r\n&lt;/code&gt;\r\n&lt;p&gt;Далее в программе мы можем использовать подобные переменные/константы/параметры как и любые другие:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nDayTime dayTime = DayTime.Morning;\r\n \r\nif(dayTime == DayTime.Morning)  \r\n    Console.WriteLine(&quot;Доброе утро&quot;);\r\nelse\r\n    Console.WriteLine(&quot;Привет&quot;);\r\n \r\nenum DayTime\r\n{\r\n    Morning,\r\n    Afternoon,\r\n    Evening,\r\n    Night\r\n}\r\n&lt;/code&gt;\r\n&lt;h3&gt;Хранение состояния&lt;/h3&gt;\r\n&lt;p&gt;Зачастую переменная перечисления выступает в качестве хранилища состояния, в зависимости от которого производятся некоторые действия:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nDayTime now = DayTime.Evening;\r\n \r\nPrintMessage(now);                   // Добрый вечер\r\nPrintMessage(DayTime.Afternoon);    // Добрый день\r\nPrintMessage(DayTime.Night);        // Доброй ночи\r\n \r\nvoid PrintMessage(DayTime dayTime)\r\n{\r\n    switch (dayTime)\r\n    {\r\n        case DayTime.Morning:\r\n            Console.WriteLine(&quot;Доброе утро&quot;);\r\n            break;\r\n        case DayTime.Afternoon:\r\n            Console.WriteLine(&quot;Добрый день&quot;);\r\n            break;\r\n        case DayTime.Evening:\r\n            Console.WriteLine(&quot;Добрый вечер&quot;);\r\n            break;\r\n        case DayTime.Night:\r\n            Console.WriteLine(&quot;Доброй ночи&quot;);\r\n            break;\r\n    }\r\n}\r\nenum DayTime\r\n{\r\n    Morning,\r\n    Afternoon,\r\n    Evening,\r\n    Night\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь метод &lt;strong&gt;PrintMessage()&lt;/strong&gt; в качестве параметра принимает значение типа перечисления DayTime и зависимости от этого значения \r\nвыводит определенное приведение.&lt;/p&gt;\r\n&lt;p&gt;Другой пример:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nDoOperation(10, 5, Operation.Add);          // 15\r\nDoOperation(10, 5, Operation.Subtract);     // 5\r\nDoOperation(10, 5, Operation.Multiply);     // 50\r\nDoOperation(10, 5, Operation.Divide);       // 2\r\n \r\nvoid DoOperation(double x, double y, Operation op)\r\n{\r\n    double result = op switch\r\n    {\r\n        Operation.Add =&gt; x + y,\r\n        Operation.Subtract =&gt; x - y,\r\n        Operation.Multiply =&gt; x * y,\r\n        Operation.Divide =&gt; x / y\r\n    };\r\n    Console.WriteLine(result);\r\n}\r\nenum Operation\r\n{\r\n    Add,\r\n    Subtract,\r\n    Multiply,\r\n    Divide\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь определено перечисление Operation, которое представляет арифметические операции. Каждый тип операций определен в виде \r\nодной из констант перечисления. И также определен метод &lt;strong&gt;DoOperation()&lt;/strong&gt;, который в качестве параметров принимает два числа и \r\nтип операции в виде константы перечисления и в зависимости от этого типа возвращает из конструкции &lt;strong&gt;switch&lt;/strong&gt; результат определенной операции.&lt;/p&gt;\r\n&lt;h3&gt;Тип и значения констант перечисления&lt;/h3&gt;\r\n&lt;p&gt;Константы перечисления могут иметь тип. Тип указывается после названия перечисления через двоеточие:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nenum Time : byte\r\n{\r\n    Morning,\r\n    Afternoon,\r\n    Evening,\r\n    Night\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Тип перечисления обязательно должен представлять целочисленный тип (byte, sbyte, short, ushort, int, uint, long, ulong). \r\nЕсли тип явным образом не указан, то по умолчанию используется тип &lt;strong&gt;int&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;p&gt;Тип влияет на значения, которые могут иметь константы. По умолчанию каждому элементу перечисления присваивается \r\nцелочисленное значение, причем первый элемент будет иметь значение 0, второй - 1 и так далее. Например, возьмем выше определенное DayTime:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nDayTime now = DayTime.Morning;\r\n \r\nConsole.WriteLine((int) now);  // 0\r\nConsole.WriteLine((int) DayTime.Night);  // 3\r\n \r\nenum DayTime\r\n{\r\n    Morning,\r\n    Afternoon,\r\n    Evening,\r\n    Night\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Мы можем использовать операцию приведения, чтобы получить целочисленное значение константы перечисления:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\n(int) DayTime.Night // 3\r\n&lt;/code&gt;\r\n&lt;p&gt;В то же время, несмотря на то, что каждая константа сопоставляется с определенным числом, мы НЕ можем присвоить ей числовое значение:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nDayTime now = 2;    // ! Ошибка\r\n&lt;/code&gt;\r\n&lt;p&gt;Можно также явным образом указать значения элементов, либо указав значение первого элемента:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nenum DayTime\r\n{\r\n    Morning = 3,    // каждый следующий элемент по умолчанию увеличивается на единицу\r\n    Afternoon,      // этот элемент равен 4\r\n    Evening,        // 5\r\n    Night           // 6\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Но можно и для всех элементов явным образом указать значения:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nenum DayTime\r\n{\r\n    Morning = 2,\r\n    Afternoon = 4,\r\n    Evening = 8,\r\n    Night = 16\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;При этом константы перечисления могут иметь одинаковые значения, либо даже можно присваивать одной константе значение другой константы:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nenum DayTime\r\n{\r\n    Morning = 1,\r\n    Afternoon = Morning,\r\n    Evening = 2,\r\n    Night = 2\r\n}\r\n&lt;/code&gt;\r\n'),
(22, 'Класс Program и метод Main. Программы верхнего уровня', 3, 3, 2, '&lt;p&gt;Точкой входа в программу на языке C# является метод Main. Именно с этого метода начинается выполнение программы на C#. И программа на C# должна обязательно иметь метод &lt;strong&gt;Main&lt;/strong&gt;. Однако может возникнуть вопрос, какой еще метод Main, если, \r\nнапример, Visual Studio 2022 по умолчанию создает проект консольного приложения со следующим кодом:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\n// See https://aka.ms/new-console-template for more information\r\nConsole.WriteLine(&quot;Hello, World!&quot;);\r\n&lt;/code&gt;\r\n&lt;p&gt;И эта программа никаких методов Main не содержит, но при этом нормально выполняется и выводит на консоль строку &quot;Hello, World!&quot;, как и запланировано. Это так называемая программа \r\nверхнего уровня (top-level program). А вызов &lt;strong&gt;Console.WriteLine(&quot;Hello, World!&quot;)&lt;/strong&gt; представляет инструкцию вехнего уровня (top-level statement)&lt;/p&gt;\r\n&lt;p&gt;Однако в реальности этот код неявно помещается компилятором в метод Main, который, в свою очередь, помещается в класс Program. \r\nВ действительности название класса может быть любым (как правило, это класс Program, собственно поэтому генерируемый по умолчанию файл кода \r\nназывается &lt;strong&gt;Program.cs&lt;/strong&gt;). Но метод Main является обязательной частью консольного приложения. Поэтому выше представленный код фактически \r\nэквивалентен следующей программе:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Program\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        // See https://aka.ms/new-console-template for more information\r\n        Console.WriteLine(&quot;Hello, World!&quot;);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Определение метода &lt;strong&gt;Main&lt;/strong&gt; обязательно начинается с модификатора &lt;strong&gt;static&lt;/strong&gt;, которое указывает, что метод Main - \r\nстатический. Позже мы подробнее разберем, что все это значит.&lt;/p&gt;\r\n&lt;p&gt;Возвращаемым типом метода &lt;strong&gt;Main&lt;/strong&gt; обязательно является тип  &lt;strong&gt;void&lt;/strong&gt;. Кроме того, в качестве параметра он принимает массив строк - &lt;strong&gt;string[] args&lt;/strong&gt; - в реальной программе это те параметры, \r\n через которые при запуске программы из консоли мы можем передать ей некоторые значения. Внутри метода располагаются действия, которые выполняет программа.&lt;/p&gt;\r\n&lt;p&gt;До Visual Studio 2022 все предыдущие студии создавали по умолчанию примерно такой код. Но начиная с Visual Studio 2022 \r\nнам необязательно вручную определять класс Program и в нем метод Main - компилятор генерирует их самостоятельно.&lt;/p&gt;\r\n&lt;p&gt;Если мы определяем какие-то переменные, константы, методы и обращаемся к ним, они помещаются в метод Main. Например, следующая программа верхнего уровня&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nstring hello = &quot;Hello METANIT.COM&quot;;\r\n \r\nPrint(hello);\r\n \r\nvoid Print(string message)\r\n{\r\n    Console.WriteLine(message);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;будет аналогична следующей программе:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Program\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        string hello = &quot;Hello METANIT.COM&quot;;\r\n \r\n        Print(hello);\r\n \r\n        void Print(string message)\r\n        {\r\n            Console.WriteLine(message);\r\n        }\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Если определяются новые типы, например, классы, то они помещаются вне класса Program. Например, код:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson tom = new();\r\ntom.SayHello();\r\n \r\nclass Person\r\n{ \r\n    public void SayHello() =&gt;Console.WriteLine(&quot;Hello&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;будет аналогичен следующему&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Program\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        Person tom = new();\r\n        tom.SayHello();\r\n    }\r\n}\r\nclass Person\r\n{\r\n    public void SayHello() =&gt; Console.WriteLine(&quot;Hello&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Однако надо учитывать, что опредления типов (в частности классов) должны идти в конце файла после инструкций верхнего уровня. То есть:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\n// инструкции верхнего уровня (top-level statements)\r\nPerson tom = new();\r\ntom.SayHello();\r\n \r\n// определение класса идет после инструкций верхнего уровня\r\nclass Person\r\n{\r\n    public void SayHello() =&gt; Console.WriteLine(&quot;Hello&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Таким образом, мы можем продолжать писать программы верхнего уровня без явного \r\nопределения метода Main. Либо мы можем явным образом определить метод Main и класс Program:&lt;/p&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/3.35.png&quot; alt=&quot;top-level programs in C# и Visual Studio 2022&quot;&gt;\r\n&lt;p&gt;И этот код будет выполняться аналогичным образом, как если бы мы не использовали класс Program и метод Main.&lt;/p&gt;');
INSERT INTO `lectures` (`IDLecture`, `Name`, `IDChapter`, `SerialNumber`, `IDStatus`, `Content`) VALUES
(23, 'Структуры', 3, 4, 2, '&lt;p&gt;Наряду с классами структуры представляют еще один способ создания собственных типов данных в C#. Более того многие примитивные типы, например, \r\nint, double и т.д., по сути являются структурами.&lt;/p&gt;\r\n&lt;h3&gt;Определение структуры&lt;/h3&gt;\r\n&lt;p&gt;Для определения структуры применяется ключевое слово &lt;strong&gt;struct&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nstruct имя_структуры\r\n{\r\n    // элементы структуры\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;После слова &lt;strong&gt;struct&lt;/strong&gt; идет название структуры и далее в фигурных скобках размещаются элементы структуры - поля, методы и т.д.&lt;/p&gt;\r\n&lt;p&gt;Например, определим структуру, которая будет называться Person и которая будет представляет человека:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nstruct Person\r\n{\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Как и классы, структуры могут хранить состояние в виде полей (переменных) и определять поведение в виде методов. Например, добавим в структуру Person пару полей и метод:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nstruct Person\r\n{\r\n    public string name;\r\n    public int age;\r\n \r\n    public void Print()\r\n    {\r\n        Console.WriteLine($&quot;Имя: {name}  Возраст: {age}&quot;);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае определены две переменные - name и age для хранения соответственно имени и возраста человека и метод Print для вывода информации о человеке на консоль.&lt;/p&gt;\r\n&lt;p&gt;И как и в случае с классами, для обращения к функциональности структуры - полям, методам и другим компонентам структуры \r\nприменяется точечная нотация - после объекта структуры ставится точка, а затем указывается компонент структуры:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nобъект.поле_структуры\r\nобъект.метод_структуры(параметры_метода)\r\n&lt;/code&gt;\r\n&lt;h3&gt;Создание объекта структуры&lt;/h3&gt;\r\n&lt;h4&gt;Инициализация с помощью конструктора&lt;/h4&gt;\r\n&lt;p&gt;Для использования структуры ее необходмо инициализировать. Для инициализации создания объектов структуры, как и в случае с классами, применяется вызов конструктура с оператором &lt;strong&gt;new&lt;/strong&gt;. \r\nДаже если в коде стуктуры не определено ни одного конструктора, тем не менее \r\n имеет как минимум один конструктор - конструктор по умолчанию, который генерируется компилятором. Этот конструктор не принимает параметров и создает объект структуры со значениями по умолчанию.&lt;/p&gt; \r\n&lt;code&gt;\r\n\r\nnew название_структуры();\r\n&lt;/code&gt;\r\n&lt;p&gt;Например, создадим объект структуры Person с помощью конструктора по умолчанию:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson tom = new Person();  // вызов конструктора\r\n// или так \r\n// Person tom = new();\r\n \r\ntom.name = &quot;Tom&quot;;   // изменяем значение по умолчанию в поле name\r\n \r\ntom.Print();    // Имя: Tom  Возраст: 0\r\n \r\nstruct Person\r\n{\r\n    public string name;\r\n    public int age;\r\n \r\n    public void Print()\r\n    {\r\n        Console.WriteLine($&quot;Имя: {name}  Возраст: {age}&quot;);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае создается объект tom. Для его создания вызывается конструктор по умолчанию, который устанавливает значения по умолчанию для его полей. Для числовых данных это значение 0, поэтому \r\nполе &lt;strong&gt;age&lt;/strong&gt; будет иметь значение 0. Для строк это значение &lt;strong&gt;null&lt;/strong&gt;, которое указывает на отсутствие значения. Но далее, если поля доступны \r\n(а в данном случае поскольку они имеют модификатор &lt;strong&gt;public&lt;/strong&gt; они доступны), мы можем измениь их значения. Так, здесь полю &lt;strong&gt;name&lt;/strong&gt; присваивается строка &quot;Tom&quot;. Соответственно \r\nпри выполнении метода &lt;strong&gt;Print()&lt;/strong&gt; мы получим следующий консольный вывод:&lt;/p&gt;\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Имя: Tom  Возраст: 0&lt;/pre&gt;\r\n&lt;h4&gt;Непосредственная иницилизация полей&lt;/h4&gt;\r\n&lt;p&gt;Если все поля структуры доступны (как в случае с полями структуры Person, который имеют модификатор &lt;strong&gt;public&lt;/strong&gt;), \r\nто структуру можно инициализировать без вызова конструктора. В этом случае необходимо присвоить значения всем полям структуры перед получением значений полей и обращением к методам структуры. \r\nНапример:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson tom;         // не вызываем конструктор\r\n// инициализация полей\r\ntom.name = &quot;Sam&quot;;\r\ntom.age = 37;\r\n \r\ntom.Print();    // Имя: Sam  Возраст: 37\r\n \r\nstruct Person\r\n{\r\n    public string name;\r\n    public int age;\r\n \r\n    public void Print()\r\n    {\r\n        Console.WriteLine($&quot;Имя: {name}  Возраст: {age}&quot;);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;h3&gt;Инициализация полей по умолчанию&lt;/h3&gt;\r\n&lt;p&gt;Стоит отметить, что начиная с версии C# 10, мы можем напрямую инициализировать поля структуры при их определении (до C# 10 это делать было нельзя):&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson tom = new Person();\r\ntom.Print();    // Имя:Tom  Возраст: 1\r\n \r\nstruct Person\r\n{\r\n    // инициализация полей значениями по умолчанию - доступна с C#10\r\n    public string name = &quot;Tom&quot;;\r\n    public int age = 1;\r\n    public Person() { }\r\n    public void Print() =&gt;Console.WriteLine($&quot;Имя: {name}  Возраст: {age}&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Однако даже в этом случае, несмотря на значения по умолчанию, необходимо явно определить и вызывать конструктор, если мы хотим использоват эти значения.&lt;/p&gt;\r\n&lt;h3&gt;Конструкторы структуры&lt;/h3&gt;\r\n&lt;p&gt;Как и класс, структура может определять конструкторы. Однако, если в структуре определяется конструктор, то в нем обязательно надо инициализировать \r\nвсе поля структуры.&lt;/p&gt;\r\n&lt;p&gt;Например, добавим в структуру Person конструктор:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson tom = new();\r\nPerson bob = new(&quot;Bob&quot;);\r\nPerson sam = new(&quot;Sam&quot;, 25);\r\n \r\ntom.Print();    // !!!! Имя:   Возраст: 0\r\nbob.Print();    // Имя: Bob  Возраст: 1 \r\nsam.Print();    // Имя: Sam  Возраст: 25\r\n \r\nstruct Person\r\n{\r\n    public string name;\r\n    public int age;\r\n \r\n    public Person(string name = &quot;Tom&quot;, int age = 1)\r\n    {\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n    public void Print() =&gt; Console.WriteLine($&quot;Имя: {name}  Возраст: {age}&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае в структуре Person определен конструктор с двумя параметрами, для которых предоставлены значения по умолчания. Однако обратите внимание на \r\nсоздание первого объекта структуры:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson tom = new(); // по прежнему используется конструктор без параметров по умолчанию\r\ntom.Print();    // !!!! Имя:   Возраст: 0\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь по-прежнему применяется конструктор по умолчанию, тогда как при инициализации остальных двух переменных структуры применяется явно определенный конструктор.&lt;/p&gt;\r\n&lt;p&gt;Однако начиная с версии C# 10 мы можем определить свой конструктор без параметров:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson tom = new();\r\n \r\ntom.Print();    // Имя: Tom  Возраст: 37\r\n \r\nstruct Person\r\n{\r\n    public string name;\r\n    public int age;\r\n \r\n    public Person()\r\n    {\r\n        name = &quot;Tom&quot;;\r\n        age = 37;\r\n    }\r\n    public void Print() =&gt; Console.WriteLine($&quot;Имя: {name}  Возраст: {age}&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Опять же при определении конструктора без параметров необходимо инициализировать все поля структуры.&lt;/p&gt;\r\n&lt;p&gt;В случае если нам необходимо вызывать конструкторы с различным количеством параметров, то мы можем, как и в случае с классами, вызывать их по цепочке:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson tom = new();\r\nPerson bob = new(&quot;Bob&quot;);\r\nPerson sam = new(&quot;Sam&quot;, 25);\r\n \r\ntom.Print();    // Имя: Tom  Возраст: 1\r\nbob.Print();    // Имя: Bob  Возраст: 1 \r\nsam.Print();    // Имя: Sam  Возраст: 25\r\n \r\nstruct Person\r\n{\r\n    public string name;\r\n    public int age;\r\n \r\n    public Person() : this(&quot;Tom&quot;)\r\n    { }\r\n    public Person(string name) : this(name, 1)\r\n    { }\r\n    public Person(string name, int age)\r\n    {\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n    public void Print() =&gt; Console.WriteLine($&quot;Имя: {name}  Возраст: {age}&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Конструкторы по прежнему должны инициализировать значения всех полей, однако поскольку при вызове любого конструктора цепочка все равно закончится на последнем конструкторе, \r\nкоторый выполняет инициализацию, то инициализацию полей в других конструкторах можно не делать. Консольный вывод программы:&lt;/p&gt;\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Имя: Tom  Возраст: 1\r\nИмя: Bob  Возраст: 1 \r\nИмя: Sam  Возраст: 25\r\n&lt;/pre&gt;\r\n\r\n&lt;h3&gt;Инициализатор структуры&lt;/h3&gt;\r\n&lt;p&gt;Также, как и для класса, можно использовать инициализатор для создания структуры:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson tom = new Person { name = &quot;Tom&quot;, age = 22 };\r\n \r\ntom.Print();    // Имя: Tom  Возраст: 22\r\n \r\nstruct Person\r\n{\r\n    public string name;\r\n    public int age;\r\n    public void Print() =&gt; Console.WriteLine($&quot;Имя: {name}  Возраст: {age}&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;При использовании инициализатора сначала вызывается конструктор без параметров: если мы явным образом не определили конструктор без параметров, то вызывается конструктор по умолчанию. А затем \r\nего полям присваиваются соответствующие значения.&lt;/p&gt;\r\n&lt;h3&gt;Копирование структуры с помощью with&lt;/h3&gt;\r\n&lt;p&gt;Если нам необходимо скопировать в один объект структуры значения из другого с небольшими изменениями, то мы можем использовать оператор \r\n&lt;strong&gt;with&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson tom = new Person { name = &quot;Tom&quot;, age = 22 };\r\nPerson bob = tom with { name = &quot;Bob&quot; };\r\nbob.Print();    // Имя: Bob  Возраст: 22\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае объект bob получает все значения объекта tom, а затем после оператора &lt;strong&gt;with&lt;/strong&gt; в фигурных скобках указывается \r\nполя со значениями, которые мы хотим изменить.&lt;/p&gt;'),
(24, 'Типы значений и ссылочные типы', 3, 5, 2, '&lt;p&gt;Ранее мы рассматривали следующие элементарные типы данных: int, byte, double, string, object и др. Также есть сложные типы: структуры, перечисления, \r\nклассы. Все эти типы данных можно разделить на типы значений, еще называемые значимыми типами, (value types) и ссылочные типы (reference types). Важно понимать между ними \r\nразличия.&lt;/p&gt;\r\n&lt;p&gt;Типы значений:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;Целочисленные типы (&lt;strong&gt;byte, sbyte, short, ushort, int, uint, long, ulong&lt;/strong&gt;)&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Типы с плавающей запятой (&lt;strong&gt;float, double&lt;/strong&gt;)&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Тип &lt;strong&gt;decimal&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Тип &lt;strong&gt;bool&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Тип &lt;strong&gt;char&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Перечисления &lt;strong&gt;enum&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Структуры (&lt;strong&gt;struct&lt;/strong&gt;)&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Ссылочные типы:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;Тип &lt;strong&gt;object&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Тип &lt;strong&gt;string&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Классы (&lt;strong&gt;class&lt;/strong&gt;)&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Интерфейсы (&lt;strong&gt;interface&lt;/strong&gt;)&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Делегаты (&lt;strong&gt;delegate&lt;/strong&gt;)&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;В чем же между ними различия? Для этого надо понять организацию памяти в .NET. Здесь память делится на два типа: стек и куча (heap). \r\nПараметры и переменные метода, которые представляют типы значений, размещают свое значение в стеке. \r\nСтек представляет собой структуру данных, которая растет снизу вверх: каждый новый добавляемый элемент помещается поверх предыдущего. \r\nВремя жизни переменных таких типов ограничено их контекстом. Физически стек - это некоторая область памяти в адресном пространстве.&lt;/p&gt;\r\n&lt;p&gt;Когда программа только запускается на выполнение, в конце блока памяти, зарезервированного для стека устанавливается указатель стека. \r\nПри помещении данных в стек указатель переустанавливается таким образом, что снова указывает на новое свободное место. При вызове каждого отдельного метода в стеке будет \r\nвыделяться область памяти или фрейм стека, где будут храниться значения его параметров и переменных.&lt;/p&gt;\r\n&lt;p&gt;Например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Program\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        Calculate(5);\r\n    }\r\n \r\n    static void Calculate(int t)\r\n    {\r\n        int x = 6;\r\n        int y = 7;\r\n        int z = y + t;\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Пи запуске такой программы в стеке будут определяться два фрейма - для метода Main (так как он вызывается при запуске программы) и для метода Calculate:&lt;/p&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/2.4.png&quot; alt=&quot;Структура стека в языке программирования C#&quot;&gt;\r\n&lt;p&gt;При вызове этого метода Calculate в его фрейм в стеке будут помещаться значения t, x, y и z. Они определяются в контексте данного метода. \r\nКогда метод отработает, область памяти, которая выделялась под стек, впоследствии может быть использована другими методами.&lt;/p&gt;\r\n&lt;p&gt;Причем если параметр или переменная метода представляет тип значений, то в стеке будет храниться непосредсвенное значение этого параметра или переменной. Например, в данном случае переменные и параметр метода Calculate \r\nпредставляют значимый тип - тип int, поэтому в стеке будут храниться их числовые значения.&lt;/p&gt;\r\n&lt;p&gt;Ссылочные типы хранятся в куче или хипе, которую можно представить как неупорядоченный набор разнородных объектов. Физически \r\nэто остальная часть памяти, которая доступна процессу.&lt;/p&gt;\r\n&lt;p&gt;При создании объекта ссылочного типа в стеке помещается ссылка на адрес в куче (хипе). Когда объект ссылочного типа перестает \r\nиспользоваться, в дело вступает автоматический сборщик мусора: \r\nон видит, что на объект в хипе нету больше ссылок, условно удаляет этот объект и очищает память - фактически помечает, что данный сегмент памяти может быть использован для хранения других данных.&lt;/p&gt; \r\n&lt;p&gt;Так, в частности, если мы изменим метод Calculate следующим образом:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nstatic void Calculate(int t)\r\n{\r\n    object x = 6;\r\n    int y = 7;\r\n    int z = y + t;\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;То теперь значение переменной x будет храниться в куче, так как она представляет ссылочный тип object, а в стеке будет храниться ссылка на объект в куче.&lt;/p&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/2.5.png&quot; alt=&quot;Ссылочные типы в куче в языке программирования C#&quot;&gt;\r\n&lt;h3&gt;Составные типы&lt;/h3&gt;\r\n&lt;p&gt;Теперь рассмотим ситуацию, когда тип значений и ссылочный тип представляют составные типы - структуру и класс:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nState state1 = new State(); // State - структура, ее данные размещены в стеке\r\nCountry country1 = new Country(); // Country - класс, в стек помещается ссылка на адрес в хипе\r\n                                  // а в хипе располагаются все данные объекта country1\r\nstruct State\r\n{\r\n    public int x;\r\n    public int y;\r\n}\r\nclass Country\r\n{\r\n    public int x;\r\n    public int y;\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь в методе Main в стеке выделяется память для объекта state1. Далее в стеке создается ссылка для объекта country1 (&lt;strong&gt;Country country1&lt;/strong&gt;), \r\nа с помощью вызова конструктора с ключевым словом new выделяется место в хипе (&lt;strong&gt;new Country()&lt;/strong&gt;). Ссылка в стеке для объекта country1 будет представлять адрес на место в хипе, по которому размещен данный объект..&lt;/p&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/2.2.png&quot; alt=&quot;Ссылычные типы и типы значений в C#&quot;&gt;\r\n&lt;p&gt;Таким образом, в стеке окажутся все поля структуры state1 и ссылка на объект country1 в хипе.&lt;/p&gt;\r\n&lt;p&gt;Но, допустим, в структуре State также определена переменная ссылочного типа Country. Где она будет хранить свое значение, если она определена в типе значений?&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nState state1 = new State();\r\nCountry country1 = new Country();\r\n \r\nstruct State\r\n{\r\n    public int x;\r\n    public int y;\r\n    public Country country = new();\r\n}\r\nclass Country\r\n{\r\n    public int x;\r\n    public int y;\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Значение переменной state1.country также будет храниться в куче, так как эта переменная представляет ссылочный тип:&lt;/p&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/2.6.png&quot; alt=&quot;Стек и куча в языке программирования C#&quot;&gt;\r\n&lt;h3&gt;Копирование значений&lt;/h3&gt;\r\n&lt;p&gt;Тип данных надо учитывать при копировании значений. При присвоении данных объекту значимого типа он получает копию данных. При присвоении данных объекту ссылочного типа он получает не копию объекта, \r\nа ссылку на этот объект в хипе. Например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nState state1 = new State(); // Структура State\r\nState state2 = new State();\r\nstate2.x = 1;\r\nstate2.y = 2;\r\nstate1 = state2;\r\nstate2.x = 5; // state1.x=1 по-прежнему\r\nConsole.WriteLine(state1.x); // 1\r\nConsole.WriteLine(state2.x); // 5\r\n \r\nCountry country1 = new Country(); // Класс Country\r\nCountry country2 = new Country();\r\ncountry2.x = 1;\r\ncountry2.y = 4;\r\ncountry1 = country2;\r\ncountry2.x = 7; // теперь и country1.x = 7, так как обе ссылки и country1 и country2 \r\n                // указывают на один объект в хипе\r\nConsole.WriteLine(country1.x); // 7\r\nConsole.WriteLine(country2.x); // 7\r\n&lt;/code&gt;\r\n&lt;p&gt;Так как state1 - структура, то при присвоении &lt;strong&gt;state1 = state2&lt;/strong&gt; она получает копию структуры state2. А объект класса country1 \r\nпри присвоении &lt;strong&gt;country1 = country2;&lt;/strong&gt; получает ссылку на тот же объект, на который указывает country2. Поэтому с изменением \r\ncountry2, так же будет меняться и country1.&lt;/p&gt;\r\n&lt;h3&gt;Ссылочные типы внутри типов значений&lt;/h3&gt;\r\n&lt;p&gt;Теперь рассмотрим более изощренный пример, когда внутри структуры у нас может быть переменная ссылочного типа, например, какого-нибудь класса:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nState state1 = new State();\r\nState state2 = new State();\r\n \r\nstate2.country = new Country();\r\nstate2.country.x = 5;\r\nstate1 = state2;\r\nstate2.country.x = 8; // теперь и state1.country.x=8, так как state1.country и state2.country\r\n                      // указывают на один объект в хипе\r\nConsole.WriteLine(state1.country.x); // 8\r\nConsole.WriteLine(state2.country.x); // 8\r\n \r\n \r\nstruct State\r\n{\r\n    public int x;\r\n    public int y;\r\n    public Country country = new(); // выделение памяти для объекта Country\r\n}\r\nclass Country\r\n{\r\n    public int x;\r\n    public int y;\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Переменные ссылочных типов в структурах также сохраняют в стеке ссылку на объект в хипе. И при присвоении двух структур \r\n&lt;strong&gt;state1 = state2;&lt;/strong&gt; структура state1 также получит ссылку на объект country в хипе. Поэтому изменение state2.country повлечет за \r\nсобой также изменение state1.country.&lt;/p&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/2.3.png&quot;&gt;\r\n&lt;h3&gt;Объекты классов как параметры методов&lt;/h3&gt;\r\n&lt;p&gt;Организацию объектов в памяти следует учитывать при передаче параметров по значению и по ссылке. Если параметры методов представляют объекты классов, \r\nто использование параметров имеет некоторые особенности. Например, создадим метод, который в качестве параметра принимает объект Person:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson p = new Person { name = &quot;Tom&quot;, age = 23 };\r\nChangePerson(p);\r\n \r\nConsole.WriteLine(p.name); // Alice\r\nConsole.WriteLine(p.age); // 23\r\n \r\nvoid ChangePerson(Person person)\r\n{\r\n    // сработает\r\n    person.name = &quot;Alice&quot;;\r\n    // сработает только в рамках данного метода\r\n    person = new Person { name = &quot;Bill&quot;, age = 45 };\r\n    Console.WriteLine(person.name); // Bill\r\n}\r\n \r\nclass Person\r\n{\r\n    public string name = &quot;&quot;;\r\n    public int age;\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;При передаче объекта класса по значению в метод передается копия ссылки на объект. Эта копия указывает на тот же объект, что и исходная ссылка, \r\nпотому мы можем изменить отдельные поля и свойства объекта, но не можем изменить сам объект. Поэтому в примере выше сработает \r\nтолько строка &lt;strong&gt;person.name = &quot;Alice&quot;&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;p&gt;А другая строка &lt;strong&gt;person = new Person { name = &quot;Bill&quot;, age = 45 }&lt;/strong&gt; создаст новый объект в памяти, и person теперь будет указывать на новый объект в памяти. \r\nДаже если после этого мы его изменим, то это никак не повлияет на ссылку &lt;strong&gt;p&lt;/strong&gt; в методе Main, поскольку ссылка p все еще указывает на старый объект в памяти.&lt;/p&gt;\r\n&lt;p&gt;Но при передаче параметра по ссылке (с помощью ключевого слова &lt;strong&gt;ref&lt;/strong&gt;) в метод в качестве аргумента передается сама ссылка на объект в памяти. Поэтому можно изменить как поля и свойства объекта, так и сам объект:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson p = new Person { name = &quot;Tom&quot;, age = 23 };\r\nChangePerson(ref p);\r\n \r\nConsole.WriteLine(p.name); // Bill\r\nConsole.WriteLine(p.age); // 45\r\n \r\nvoid ChangePerson(ref Person person)\r\n{\r\n    // сработает\r\n    person.name = &quot;Alice&quot;;\r\n    // сработает\r\n    person = new Person { name = &quot;Bill&quot;, age = 45 };\r\n}\r\n \r\nclass Person\r\n{\r\n    public string name = &quot;&quot;;\r\n    public int age;\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Операция &lt;strong&gt;new&lt;/strong&gt; создаст новый объект в памяти, и теперь ссылка person (она же ссылка p из метода Main) будет указывать уже на новый объект в памяти.&lt;/p&gt;'),
(25, 'Пространства имен', 3, 6, 2, '&lt;p&gt;Обычно определяемые классы и другие типы в .NET не существуют сами по себе, а заключаются в специальные контейнеры - \r\n&lt;strong&gt;пространства имен&lt;/strong&gt;. Пространства имен позволяют организовать код программы в логические блоки, \r\nповоляют объединить и отделить от остального кода некоторую функциональность, которая связана некоторой общей идеей или которая \r\nвыполняет определенную задачу.&lt;/p&gt;\r\n&lt;p&gt;Для определения пространства имен применяется ключевое слово &lt;span class=&quot;=&amp;quot;b&amp;quot;&quot;&gt;namespace&lt;/span&gt;, после которого идет название название пространства имен:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nnamespace имя_пространства_имен\r\n{\r\n    // содержимое пространства имен\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Например, определим в файле &lt;strong&gt;Program.cs&lt;/strong&gt; пространство имен, которое будет называться &lt;strong&gt;Base&lt;/strong&gt;&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nnamespace Base\r\n{\r\n    class Person\r\n    {\r\n        string name;\r\n        public Person(string name) =&gt; this.name = name;\r\n        public void Print() =&gt; Console.WriteLine($&quot;Имя: {name}&quot;);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь пространство имен содержит класс Person, которой имеет одну переменную - name, конструктор и метод Print.&lt;/p&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/3.27.png&quot; alt=&quot;пространства имен в языке программирования C# и .NET&quot;&gt;\r\n&lt;p&gt;Теперь попробуем использовать класс Person:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson tom = new Person(&quot;Tom&quot;); // Ошибка - Visual Studio не видит класс Person\r\ntom.Print();\r\n \r\nnamespace Base\r\n{\r\n    class Person\r\n    {\r\n        string name;\r\n        public Person(string name) =&gt; this.name = name;\r\n        public void Print() =&gt; Console.WriteLine($&quot;Имя: {name}&quot;);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь на первой строке мы столкнемся с ошибкой, так как Visual Studio не может найти класс Person. Чтобы все-таки обратиться к классу Person, \r\nнеобходимо использовать полное имя этого класса с учетом пространства имен:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nBase.Person tom = new(&quot;Tom&quot;);\r\ntom.Print();          // Имя: Tom\r\n \r\nnamespace Base\r\n{\r\n    class Person\r\n    {\r\n        string name;\r\n        public Person(string name) =&gt; this.name = name;\r\n        public void Print() =&gt; Console.WriteLine($&quot;Имя: {name}&quot;);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Поскольку класс Person располагается в пространстве имен Base, то его полное имя - &lt;strong&gt;Base.Person&lt;/strong&gt;. Соответственно, используя это имя, мы можем обращаться \r\nк данному классу вне его пространства имен.&lt;/p&gt;\r\n&lt;h3&gt;Подключение пространства имен&lt;/h3&gt;\r\n&lt;p&gt;Однако полное имя класса с учетом пространства имен добавляет в код избыточность - особенно, если пространство имен содержит множество классов, которые мы хотим использовать. \r\nИ чтобы не писать полное имя класса, мы можем просто подключить пространство имен с помощью директивы &lt;strong&gt;using&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nusing Base; // подключение пространства имен Base\r\n \r\nPerson tom = new(&quot;Tom&quot;);\r\ntom.Print();     // Имя: Tom\r\n \r\nnamespace Base\r\n{\r\n    class Person\r\n    {\r\n        string name;\r\n        public Person(string name) =&gt; this.name = name;\r\n        public void Print() =&gt; Console.WriteLine($&quot;Имя: {name}&quot;);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/3.28.png&quot; alt=&quot;подключение пространства имен и using в языке программирования C# и .NET&quot;&gt;\r\n&lt;h3&gt;Вложенные пространства имен&lt;/h3&gt;\r\n&lt;p&gt;Одни пространства имен могут содержать другие. Например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nnamespace Base\r\n{\r\n    namespace PersonTypes\r\n    {\r\n        class Person\r\n        {\r\n            string name;\r\n            OrganisationTypes.Company company;\r\n            public Person(string name, OrganisationTypes.Company company) \r\n            { \r\n                this.name = name; \r\n                this.company = company; \r\n            }\r\n            public void Print()\r\n            {\r\n                Console.WriteLine($&quot;Имя: {name} &quot;);\r\n                company.Print();\r\n            }\r\n        }\r\n    }\r\n    namespace OrganisationTypes\r\n    {\r\n        class Company\r\n        {\r\n            string title;\r\n            public Company(string title) =&gt; this.title = title;\r\n            public void Print() =&gt; Console.WriteLine($&quot;Название компании: {title}&quot;);\r\n        }\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае классы Person и Company находятся в разных вложенных пространствах имен, поэтому чтобы в классе Person использовать класс Company, надо прописывать имя класса с учетом его пространства имен: \r\n&lt;strong&gt;OrganisationTypes.Company&lt;/strong&gt; (так как оба класса в итоге находятся в общем пространстве - Base, то его имя можно не указывать в названии класса) или подключать пространство имен класса Company с помощью директивы &lt;strong&gt;using&lt;/strong&gt;. &lt;/p&gt;\r\n&lt;p&gt;Для обращения к этим классам вне пространства Base необходимо использовать всю цепочку пространств имен:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nusing Base.PersonTypes; // подключение пространства имен Base.PersonTypes для класса Person\r\n \r\nBase.OrganisationTypes.Company microsoft = new(&quot;Microsoft&quot;);\r\nPerson tom = new(&quot;Tom&quot;, microsoft);\r\ntom.Print();     // Имя: Tom   Название компании: Microsoft\r\n \r\nnamespace Base\r\n{\r\n    namespace PersonTypes\r\n    {\r\n        class Person\r\n        {\r\n            string name;\r\n            OrganisationTypes.Company company;\r\n            public Person(string name, OrganisationTypes.Company company) \r\n            { \r\n                this.name = name; \r\n                this.company = company; \r\n            }\r\n            public void Print()\r\n            {\r\n                Console.WriteLine($&quot;Имя: {name} &quot;);\r\n                company.Print();\r\n            }\r\n        }\r\n    }\r\n    namespace OrganisationTypes\r\n    {\r\n        class Company\r\n        {\r\n            string title;\r\n            public Company(string title) =&gt; this.title = title;\r\n            public void Print() =&gt; Console.WriteLine($&quot;Название компании: {title}&quot;);\r\n        }\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;h3&gt;Пространства имен уровня файла&lt;/h3&gt;\r\n&lt;p&gt;Начиная с .NET 6 и C# 10 можно определять пространства имен на уровне файла. Например, добавим в проект новый файл с кодом c#. Для этого в Visual Studio \r\nнажмем на название проекта правой кнопкой мыши и в появившемся меню выберем пункт &lt;strong&gt;Add -&gt; New Item...&lt;/strong&gt;&lt;/p&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/3.29.png&quot; alt=&quot;добавление нового пространства имен C# в Visual Studio&quot;&gt;\r\n&lt;p&gt;В окне добавления нового элемента выберем пункт &lt;strong&gt;Class&lt;/strong&gt; и поле &lt;strong&gt;Name&lt;/strong&gt; в качестве имени файла укажем \r\n&lt;strong&gt;Base.cs&lt;/strong&gt;&lt;/p&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/3.30.png&quot; alt=&quot;пространства имен уровня файла C# в Visual Studio&quot;&gt;\r\n&lt;p&gt;После этого в проект будет добавлен файл &lt;strong&gt;Base.cs&lt;/strong&gt;. Удалим из него все содержимое по умолчанию и определим в нем следующий код:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nnamespace Base;\r\n \r\nclass Person\r\n{\r\n    string name;\r\n    public Person(string name) =&gt; this.name = name;\r\n    public void Print() =&gt; Console.WriteLine($&quot;Имя: {name} &quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Директива &lt;strong&gt;namespace Base&lt;/strong&gt; в начале файла указывает, что содержимое файла будет представлять пространство имен Base.&lt;/p&gt;\r\n&lt;p&gt;Теперь подключим это пространство имен в файле &lt;strong&gt;Program.cs&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nusing Base; // подключение пространства имен Base\r\n \r\nPerson tom = new(&quot;Tom&quot;);\r\ntom.Print();\r\n&lt;/code&gt;\r\n'),
(26, 'Модификаторы доступа', 3, 7, 2, '&lt;p&gt;Все поля, методы и остальные компоненты класса имеют &lt;strong&gt;модификаторы доступа&lt;/strong&gt;. \r\nМодификаторы доступа позволяют задать допустимую область видимости \r\nдля компонентов класса. То есть модификаторы доступа определяют контекст, в котором можно употреблять данную переменную или метод.&lt;/p&gt;\r\n&lt;p&gt;В языке C# применяются следующие модификаторы доступа:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;private&lt;/strong&gt;: закрытый или приватный компонент класса или структуры. Приватный компонент доступен только в \r\nрамках своего класса или структуры.&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;private protected&lt;/strong&gt;: компонент класса доступен из любого места в своем классе или в производных классах, которые определены в той же сборке.&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;protected&lt;/strong&gt;: такой компонент класса доступен из любого места в своем классе или в производных классах. При этом производные классы могут располагаться в других сборках.&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;internal&lt;/strong&gt;: компоненты класса или структуры доступен из любого места кода в той же сборке, однако \r\nон недоступен для других программ и сборок.&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;protected internal&lt;/strong&gt;: совмещает функционал двух модификаторов &lt;strong&gt;protected&lt;/strong&gt; и &lt;strong&gt;internal&lt;/strong&gt;. \r\nТакой компонент класса доступен из любого места в текущей сборке и из производных классов, которые могут располагаться в других сборках.&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;public&lt;/strong&gt;: публичный, общедоступный компонент класса или структуры. Такой компонент доступен из любого места в \r\nкоде, а также из других программ и сборок.&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/3.38.png&quot; alt=&quot;Модификаторы доступа public, protected, internal, private в языке программирования C# и в .NET&quot;&gt;\r\n&lt;p&gt;Стоит отметить, что эти модификаторы могут применяться как к компонентам класса, так и к компонентам структуры за тем исключением, что структуры не могут \r\nиспользовать модификаторы &lt;strong&gt;private protected&lt;/strong&gt;, &lt;strong&gt;protected&lt;/strong&gt; и &lt;strong&gt;protected internal&lt;/strong&gt;, поскольку структуры не могут быть унаследованы.&lt;/p&gt;\r\n&lt;p&gt;Все классы и структуры, определенные напрямую вне других типов (классов и структур) могут иметь только модификаторы &lt;strong&gt;public&lt;/strong&gt; или &lt;strong&gt;internal&lt;/strong&gt;.&lt;/p&gt;\r\n\r\n&lt;p&gt;Мы можем явно задать модификатор доступа, а можем его и не указывать:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\npublic class Person\r\n{\r\n    string name;\r\n    public Person(string name) \r\n    {\r\n        this.name = name;\r\n    }\r\n    public void Print() =&gt; Console.WriteLine($&quot;Name: {name}&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Если для компонентов не определен модификатор доступа, то по умолчанию для них применяется модификатор &lt;strong&gt;private&lt;/strong&gt;. Например, в примере выше переменная &lt;strong&gt;name&lt;/strong&gt; \r\nнеявно будет иметь модификатор &lt;strong&gt;private&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;p&gt;Классы и структуры, которые объявлены без модификатора и которые расположены вне других типов, по умолчанию имеют доступ &lt;strong&gt;internal&lt;/strong&gt;, а вложенные классы и структуры, как и остальные \r\nкомпоненты классов/структур имеют модификатор &lt;strong&gt;private&lt;/strong&gt;. Например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Phone\r\n{\r\n    struct Camera\r\n    {\r\n \r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь класс Phone не является вложенным ни в один другой класс/структуру, поэтому неявно имеет модификатор &lt;strong&gt;internal&lt;/strong&gt;. \r\nА структура Camera является вложенной, поэтому, как и другие компоненты класса, неявно имеет модификатор &lt;strong&gt;private&lt;/strong&gt;&lt;/p&gt;\r\n&lt;h3&gt;Модификаторы в рамках текущего проекта&lt;/h3&gt;\r\n&lt;p&gt;Посмотрим на примере и создадим следующий класс State:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass State\r\n{\r\n    // все равно, что private string defaultVar;\r\n    string defaultVar =&quot;default&quot;;\r\n    // поле доступно только из текущего класса\r\n    private string privateVar = &quot;private&quot;;\r\n    // доступно из текущего класса и производных классов, которые определены в этом же проекте\r\n    protected private string protectedPrivateVar = &quot;protected private&quot;;\r\n    // доступно из текущего класса и производных классов\r\n    protected string protectedVar = &quot;protected&quot;;\r\n    // доступно в любом месте текущего проекта\r\n    internal string internalVar = &quot;internal&quot;;\r\n    // доступно в любом месте текущего проекта и из классов-наследников в других проектах\r\n    protected internal string protectedInternalVar = &quot;protected internal&quot;;\r\n    // доступно в любом месте программы, а также для других программ и сборок\r\n    public string publicVar = &quot;public&quot;;\r\n \r\n    // по умолчанию имеет модификатор private\r\n    void Print() =&gt; Console.WriteLine(defaultVar);\r\n \r\n    // метод доступен только из текущего класса\r\n    private void PrintPrivate() =&gt; Console.WriteLine(privateVar);\r\n \r\n    // доступен из текущего класса и производных классов, которые определены в этом же проекте\r\n    protected private void PrintProtectedPrivate() =&gt; Console.WriteLine(protectedPrivateVar);\r\n \r\n    // доступен из текущего класса и производных классов\r\n    protected void PrintProtected() =&gt; Console.WriteLine(protectedVar);\r\n \r\n    // доступен в любом месте текущего проекта\r\n    internal void PrintInternal() =&gt; Console.WriteLine(internalVar);\r\n \r\n    // доступен в любом месте текущего проекта и из классов-наследников в других проектах\r\n    protected internal void PrintProtectedInternal() =&gt; Console.WriteLine(protectedInternalVar);\r\n \r\n    // доступен в любом месте программы, а также для других программ и сборок\r\n    public void PrintPublic() =&gt; Console.WriteLine(publicVar);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Так как класс State не имеет явного модификатора, по умолчанию он имеет модификатор &lt;strong&gt;internal&lt;/strong&gt;, \r\nпоэтому он будет доступен из любого места данного проекта, однако не будет доступен из других программ и сборок.&lt;/p&gt; \r\n&lt;p&gt;Класс State имеет шесть полей для каждого уровня доступа. Плюс одна переменная без модификатора, которая является закрытой (private) по умолчанию. А также определено семь методов с разными модификаторами, \r\nкоторые выводят значения соответствующих переменных на консоль. Поскольку все модификаторы позволяют использовать компоненты класса внутри данного класса, то и все переменные класса, в том числе закрытые, у нас доступны всем его методам, \r\nтак как все находятся в контексте класса State.&lt;/p&gt;\r\n&lt;p&gt;Теперь посмотрим, как мы сможем использовать переменные класса State в другом классе, который, допустим, будет называться StateConsumer и который \r\nрасположен &lt;strong&gt;в том же проекте&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass StateConsumer\r\n{\r\n    public void PrintState()\r\n    {\r\n        State state = new State();\r\n \r\n        // обратиться к переменной defaultVar у нас не получится,\r\n        // так как она имеет модификатор private и класс StateConsumer ее не видит\r\n        Console.WriteLine(state.defaultVar); //Ошибка, получить доступ нельзя\r\n \r\n        // то же самое относится и к переменной privateVar\r\n        Console.WriteLine(state.privateVar); // Ошибка, получить доступ нельзя\r\n \r\n        // обратиться к переменной protectedPrivateVar не получится,\r\n        // так как класс StateConsumer не является классом-наследником класса State\r\n        Console.WriteLine(state.protectedPrivateVar); // Ошибка, получить доступ нельзя\r\n \r\n        // обратиться к переменной protectedVar тоже не получится,\r\n        // так как класс StateConsumer не является классом-наследником класса State\r\n        Console.WriteLine(state.protectedVar); // Ошибка, получить доступ нельзя\r\n \r\n        // переменная internalVar с модификатором internal доступна из любого места текущего проекта\r\n        // поэтому спокойно присваиваем ей значение\r\n        Console.WriteLine(state.internalVar);\r\n \r\n        // переменная protectedInternalVar так же доступна из любого места текущего проекта\r\n        Console.WriteLine(state.protectedInternalVar);\r\n \r\n        // переменная publicVar общедоступна\r\n        Console.WriteLine(state.publicVar);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Таким образом, в классе StateConsumer мы смогли только обратиться к переменным internalVar, protectedInternalVar и publicVar, \r\nтак как их модификаторы позволяют использовать в данном контексте.&lt;/p&gt;\r\n&lt;p&gt;Аналогично дело обстоит и с методами:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass StateConsumer\r\n{\r\n    public void PrintState()\r\n    {\r\n        State state = new State();\r\n \r\n        state.Print(); //Ошибка, получить доступ нельзя\r\n \r\n        state.PrintPrivate(); // Ошибка, получить доступ нельзя\r\n \r\n        state.PrintProtectedPrivate(); // Ошибка, получить доступ нельзя\r\n \r\n        state.PrintProtected(); // Ошибка, получить доступ нельзя\r\n \r\n        state.PrintInternal();    // норм\r\n \r\n        state.PrintProtectedInternal();  // норм\r\n \r\n        state.PrintPublic();      // норм\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь нам оказались доступны только три метода: PrintInternal, PrintProtectedInternal, PrintPublic, которые имееют соответственно модификаторы internal, protected internal, public.&lt;/p&gt;\r\n&lt;h3&gt;Модификаторы в рамках сборок&lt;/h3&gt;\r\n&lt;p&gt;Допустим, у нас есть проект (и соответственно сборка) MyLib, в которой определены три класса:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nnamespace MyLib;\r\n// класс доступен из других сборок\r\npublic class PublicState\r\n{\r\n    internal void PrintInternal() =&gt; Console.WriteLine(&quot;internal&quot;);\r\n    protected internal void PrintProtectedInternal() =&gt; Console.WriteLine(&quot;protected internal&quot;);\r\n    public void PrintPublic() =&gt; Console.WriteLine(&quot;public&quot;);\r\n \r\n}\r\n \r\n// класс доступен только в текущей сборке - по умолчанию internal\r\nclass DefaultlState { }\r\n// класс доступен только в текущей сборке\r\ninternal class InternalState{  }\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь классы DefaultlState и InternalState имеют модификатор &lt;strong&gt;internal&lt;/strong&gt;, поэтому доступны только в текущем проекте.&lt;/p&gt;\r\n&lt;p&gt;Класс PublicState  модификатором &lt;strong&gt;public&lt;/strong&gt; доступен из других проектов. Однако его методы &lt;strong&gt;PrintInternal()&lt;/strong&gt; \r\nи &lt;strong&gt;PrintProtectedInternal()&lt;/strong&gt; доступны только в текущем проекте. Вне текущего проекта доступен только его метод &lt;strong&gt;PrintPublic&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;p&gt;Допустим, мы подключаем сборку этого проекта MyLib в другой проект, где есть класс StateConsumer:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nusing MyLib;\r\nclass StateConsumer\r\n{\r\n    public void PrintState()\r\n    {\r\n        // Ошибка DefaultState - по умолчанию internal, поэтому нет доступа\r\n        DefaultState defaultState = new DefaultState();\r\n        // Ошибка InternalState - internal, поэтому нет доступа\r\n        InternalState internalState = new InternalState();\r\n \r\n        // норм, PublicState - public, доступен из других программ\r\n        PublicState publicState = new PublicState();\r\n        // Ошибка, нет доступа - метод доступен только в свой сборке\r\n        publicState.PrintInternal();\r\n        // Ошибка, нет доступа - метод доступен только в свой сборке\r\n        publicState.PrintProtectedInternal();  // нет доступа\r\n        // норм - общедоступный метод\r\n        publicState.PrintPublic();      // норм\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/3.37.png&quot; alt=&quot;Модификаторы доступа в языке программирования C# и в .NET&quot;&gt;\r\n&lt;p&gt;В классе StateConsumer есть доступ только к классу PublicState и его методу &lt;strong&gt;PrintPublic&lt;/strong&gt;, потому что они имеют модификатор &lt;strong&gt;public&lt;/strong&gt;. \r\nК остальной функциональности подключенной сборки StateConsumer доступа не имеет.&lt;/p&gt;\r\n&lt;p&gt;Благодаря такой системе модификаторов доступа можно скрывать некоторые моменты реализации класса от других частей программы.&lt;/p&gt;\r\n'),
(27, 'Перегрузка методов', 3, 8, 2, '&lt;p&gt;Иногда возникает необходимость создать один и тот же метод, но с разным набором параметров. \r\nИ в зависимости от имеющихся параметров применять определенную версию метода. Такая возможность еще называется &lt;strong&gt;перегрузкой методов&lt;/strong&gt; \r\n(method overloading).&lt;/p&gt;\r\n&lt;p&gt;И в языке C# мы можем создавать в классе несколько методов с одним и тем же именем, но разной сигнатурой. Что такое сигнатура? \r\n&lt;strong&gt;Сигнатура&lt;/strong&gt; складывается из следующих аспектов:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;Имя метода&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Количество параметров&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Типы параметров&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Порядок параметров&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Модификаторы параметров&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Но названия параметров в сигнатуру НЕ входят. Например, возьмем следующий метод:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\npublic int Sum(int x, int y) \r\n{ \r\n    return x + y;\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;У данного метода сигнатура будет выглядеть так: &lt;strong&gt;Sum(int, int)&lt;/strong&gt;&lt;/p&gt;\r\n&lt;p&gt;И перегрузка метода как раз заключается в том, что методы имеют разную сигнатуру, в которой совпадает только название метода. То есть методы должны \r\nотличаться по:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;Количеству параметров&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Типу параметров&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Порядку параметров&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Модификаторам параметров&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Например, пусть у нас есть следующий класс:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Calculator\r\n{\r\n    public void Add(int a, int b)\r\n    {\r\n        int result = a + b;\r\n        Console.WriteLine($&quot;Result is {result}&quot;);\r\n    }\r\n    public void Add(int a, int b, int c)\r\n    {\r\n        int result = a + b + c;\r\n        Console.WriteLine($&quot;Result is {result}&quot;);\r\n    }\r\n    public int Add(int a, int b, int c, int d)\r\n    {\r\n        int result = a + b + c + d;\r\n        Console.WriteLine($&quot;Result is {result}&quot;);\r\n        return result;\r\n    }\r\n    public void Add(double a, double b)\r\n    {\r\n        double result = a + b;\r\n        Console.WriteLine($&quot;Result is {result}&quot;);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь представлены четыре разных версии метода Add, то есть определены четыре перегрузки данного метода.&lt;/p&gt;\r\n&lt;p&gt;Первые три версии метода отличаются по количеству параметров. Четвертая версия совпадает с первой по количеству параметров, но отличается по их типу. При этом достаточно, чтобы хотя бы один параметр отличался по типу. Поэтому это тоже допустимая перегрузка метода Add.&lt;/p&gt;\r\n&lt;p&gt;То есть мы можем представить сигнатуры данных методов следующим образом:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nAdd(int, int)\r\nAdd(int, int, int)\r\nAdd(int, int, int, int)\r\nAdd(double, double)\r\n&lt;/code&gt;\r\n&lt;p&gt;После определения перегруженных версий мы можем использовать их в программе:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nCalculator calc = new Calculator();\r\ncalc.Add(1, 2); // 3\r\ncalc.Add(1, 2, 3); // 6\r\ncalc.Add(1, 2, 3, 4); // 10\r\ncalc.Add(1.4, 2.5); // 3.9\r\n&lt;/code&gt;\r\n&lt;p&gt;Консольный вывод:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Result is 3\r\nResult is 6\r\nResult is 10\r\nResult is 3.9\r\n&lt;/pre&gt;\r\n\r\n&lt;p&gt;Также перегружаемые методы могут отличаться по используемым модификаторам. Например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvoid Increment(ref int val)\r\n{\r\n    val++;\r\n    Console.WriteLine(val);\r\n}\r\n \r\nvoid Increment(int val)\r\n{\r\n    val++;\r\n    Console.WriteLine(val);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае обе версии метода Increment имеют одинаковый набор параметров одинакового типа, однако в первом случае параметр имеет \r\nмодификатор ref. Поэтому обе версии метода будут корректными перегрузками метода Increment.&lt;/p&gt;\r\n&lt;p&gt;А отличие методов по возвращаемому типу или по имени параметров не является основанием для перегрузки. Например, возьмем следующий набор методов:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint Sum(int x, int y)\r\n{\r\n    return x + y;\r\n}\r\nint Sum(int number1, int number2)\r\n{\r\n    return number1 + number2;\r\n}\r\nvoid Sum(int x, int y)\r\n{\r\n    Console.WriteLine(x + y);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Сигнатура у всех этих методов будет совпадать:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nSum(int, int)\r\n&lt;/code&gt;\r\n&lt;p&gt;Поэтому данный набор методов не представляет корректные перегрузки метода Sum и &lt;strong&gt;работать не будет&lt;/strong&gt;.&lt;/p&gt;');
INSERT INTO `lectures` (`IDLecture`, `Name`, `IDChapter`, `SerialNumber`, `IDStatus`, `Content`) VALUES
(28, 'Наследование', 4, 1, 2, '&lt;p&gt;Наследование (inheritance) является одним из ключевых моментов ООП. Благодаря наследованию один класс может унаследовать функциональность \r\nдругого класса.&lt;/p&gt;\r\n&lt;p&gt;Пусть у нас есть следующий класс Person, который описывает отдельного человека:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Person\r\n{\r\n    private string _name = &quot;&quot;;\r\n \r\n    public string Name\r\n    {\r\n        get { return _name; }\r\n        set { _name = value; }\r\n    }\r\n    public void Print()\r\n    {\r\n        Console.WriteLine(Name);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Но вдруг нам потребовался класс, описывающий сотрудника предприятия - класс Employee. Поскольку этот класс будет реализовывать тот же \r\nфункционал, что и класс Person, так как сотрудник - это также и человек, то было бы рационально сделать класс Employee производным \r\n(или наследником, или подклассом) от класса Person, который, в свою очередь, называется базовым классом или родителем (или суперклассом):&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Employee : Person\r\n{\r\n     \r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;После двоеточия мы указываем базовый класс для данного класса. Для класса Employee базовым является Person, и поэтому класс Employee \r\nнаследует все те же свойства, методы, поля, которые есть в классе Person. Единственное, что не передается при наследовании, это конструкторы базового класса.&lt;/p&gt;\r\n&lt;p&gt;Таким образом, наследование реализует отношение &lt;strong&gt;is-a&lt;/strong&gt; (является), объект класса Employee также является объектом класса Person:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson person = new Person { Name = &quot;Tom&quot; };\r\nperson.Print();   // Tom\r\nperson = new Employee { Name = &quot;Sam&quot; };\r\nperson.Print();   // Sam\r\n&lt;/code&gt;\r\n&lt;p&gt;И поскольку объект Employee является также и объектом Person, то мы можем так определить переменную: &lt;strong&gt;Person p = new Employee()&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;p&gt;По умолчанию все классы наследуются от базового класса &lt;strong&gt;Object&lt;/strong&gt;, даже если мы явным образом не устанавливаем наследование. \r\nПоэтому выше определенные классы Person и Employee кроме своих собственных методов, также будут иметь и методы класса \r\nObject: ToString(), Equals(), GetHashCode() и GetType().&lt;/p&gt;\r\n&lt;p&gt;Все классы по умолчанию могут наследоваться. Однако здесь есть ряд ограничений:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;Не поддерживается множественное наследование, класс может наследоваться только от одного класса.&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;При создании производного класса надо учитывать тип доступа к базовому классу - тип доступа к производному классу должен быть \r\nтаким же, как и у базового класса, или более строгим. То есть, если базовый класс у нас имеет тип доступа &lt;strong&gt;internal&lt;/strong&gt;, \r\nто производный класс может иметь тип доступа &lt;strong&gt;internal&lt;/strong&gt; или &lt;strong&gt;private&lt;/strong&gt;, но не &lt;strong&gt;public&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;p&gt;Однако следует также учитывать, что если базовый и производный класс находятся в разных сборках (проектах), то в этом случае производый класс может наследовать только от класса, \r\nкоторый имеет модификатор public.&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Если класс объявлен с модификатором &lt;strong&gt;sealed&lt;/strong&gt;, то от этого класса нельзя наследовать и создавать производные классы. \r\nНапример, следующий класс не допускает создание наследников:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nsealed class Admin\r\n{\r\n}\r\n&lt;/code&gt;\r\n&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Нельзя унаследовать класс от статического класса.&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;h3&gt;Доступ к членам базового класса из класса-наследника&lt;/h3&gt;\r\n&lt;p&gt;Вернемся к нашим классам Person и Employee. Хотя Employee наследует весь функционал от класса Person, посмотрим, что будет в следующем случае:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Employee : Person\r\n{\r\n    public void PrintName()\r\n    {\r\n        Console.WriteLine(_name);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Этот код не сработает и выдаст ошибку, так как переменная &lt;strong&gt;_name&lt;/strong&gt; объявлена с модификатором &lt;strong&gt;private&lt;/strong&gt; и поэтому \r\nк ней доступ имеет только класс &lt;strong&gt;Person&lt;/strong&gt;. Но зато в классе Person определено общедоступное свойство Name, которое мы \r\nможем использовать, поэтому следующий код у нас будет работать нормально:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Employee : Person\r\n{\r\n    public void PrintName()\r\n    {\r\n        Console.WriteLine(Name);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Таким образом, производный класс может иметь доступ только к тем членам базового класса, которые определены с модификаторами \r\n&lt;strong&gt;private protected&lt;/strong&gt; (если базовый и производный класс находятся в одной сборке), &lt;strong&gt;public&lt;/strong&gt;, &lt;strong&gt;internal&lt;/strong&gt; (если базовый и производный класс находятся в одной сборке), &lt;strong&gt;protected&lt;/strong&gt; и &lt;strong&gt;protected internal&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;h3&gt;Ключевое слово base&lt;/h3&gt;\r\n&lt;p&gt;Теперь добавим в наши классы конструкторы:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Person\r\n{\r\n    public string Name { get; set;}\r\n    public Person(string name)\r\n    {\r\n        Name = name;\r\n    }\r\n    public void Print()\r\n    {\r\n        Console.WriteLine(Name);\r\n    }\r\n}\r\n \r\nclass Employee : Person\r\n{\r\n    public string Company { get; set; }\r\n    public Employee(string name, string company)\r\n        : base(name)\r\n    {\r\n        Company = company;\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Класс Person имеет конструктор, который устанавливает свойство Name. Поскольку класс Employee наследует и устанавливает то же свойство Name, \r\nто логично было бы не писать по сто раз код установки, а как-то вызвать соответствующий код класса Person. \r\nК тому же свойств, которые надо установить в конструкторе базового класса, и параметров может быть гораздо больше.&lt;/p&gt;\r\n&lt;p&gt;С помощью ключевого слова &lt;strong&gt;base&lt;/strong&gt; мы можем обратиться к базовому классу. В нашем случае в конструкторе класса Employee \r\nнам надо установить имя и компанию. Но имя мы передаем на установку в конструктор базового класса, то есть в конструктор \r\nкласса Person, с помощью выражения &lt;strong&gt;base(name)&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson person = new Person(&quot;Bob&quot;);\r\nperson.Print();     // Bob\r\nEmployee employee = new Employee(&quot;Tom&quot;, &quot;Microsoft&quot;);\r\nemployee.Print();   // Tom\r\n&lt;/code&gt;\r\n&lt;h3&gt;Конструкторы в производных классах&lt;/h3&gt;\r\n&lt;p&gt;Конструкторы не передаются производному классу при наследовании. И если в базовом классе &lt;strong&gt;не определен&lt;/strong&gt; конструктор по умолчанию \r\nбез параметров, а только конструкторы с параметрами (как в случае с базовым классом Person), то в производном \r\nклассе мы обязательно должны вызвать один из этих конструкторов через ключевое слово base. Например, из класса Employee уберем определение конструктора:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Employee : Person\r\n{\r\n    public string Company { get; set; } = &quot;&quot;;\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае мы получим ошибку, так как класс Employee не соответствует классу Person, а именно не вызывает конструктор базового класса. \r\nДаже если бы мы добавили какой-нибудь конструктор, который бы устанавливал все те же свойства, то мы все равно бы получили ошибку:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Employee : Person\r\n{\r\n    public string Company { get; set; } = &quot;&quot;;\r\n    public Employee(string name, string company)    // ! Ошибка\r\n    {\r\n        Name = name;\r\n        Company = company;\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;То есть в классе Employee через ключевое слово &lt;strong&gt;base&lt;/strong&gt; надо явным образом вызвать конструктор класса Person:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Employee : Person\r\n{\r\n    public string Company { get; set; } = &quot;&quot;;\r\n    public Employee(string name, string company)\r\n        : base(name)\r\n    {\r\n        Company = company;\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Либо в качестве альтернативы мы могли бы определить в базовом классе конструктор без параметров:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Person\r\n{\r\n    public string Name { get; set; }\r\n    // конструктор без параметров\r\n    public Person()\r\n    {\r\n        Name = &quot;Tom&quot;;\r\n        Console.WriteLine(&quot;Вызов конструктора без параметров&quot;);\r\n    }\r\n    public Person(string name)\r\n    {\r\n        Name = name;\r\n    }\r\n    public void Print()\r\n    {\r\n        Console.WriteLine(Name);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Тогда в любом конструкторе производного класса, где нет обращения конструктору базового класса, все равно неявно вызывался бы этот конструктор по умолчанию. \r\nНапример, следующий конструктор&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\npublic Employee(string company)\r\n{\r\n    Company = company;\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Фактически был бы эквивалентен следующему конструктору:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\npublic Employee(string company)\r\n    :base()\r\n{\r\n    Company = company;\r\n}\r\n&lt;/code&gt;\r\n&lt;h3&gt;Порядок вызова конструкторов&lt;/h3&gt;\r\n&lt;p&gt;При вызове конструктора класса сначала отрабатывают конструкторы базовых классов и только затем конструкторы производных. \r\nНапример, возьмем следующие классы:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Person\r\n{\r\n    string name;\r\n    int age;\r\n \r\n    public Person(string name)\r\n    {\r\n        this.name = name;\r\n        Console.WriteLine(&quot;Person(string name)&quot;);\r\n    }\r\n    public Person(string name, int age) : this(name)\r\n    {\r\n        this.age = age;\r\n        Console.WriteLine(&quot;Person(string name, int age)&quot;);\r\n    }\r\n}\r\nclass Employee : Person\r\n{\r\n    string company;\r\n \r\n    public Employee(string name, int age, string company) : base(name, age)\r\n    {\r\n        this.company = company;\r\n        Console.WriteLine(&quot;Employee(string name, int age, string company)&quot;);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;При создании объекта Employee:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nEmployee tom = new Employee(&quot;Tom&quot;, 22, &quot;Microsoft&quot;);\r\n&lt;/code&gt;\r\n&lt;p&gt;Мы получим следующий консольный вывод:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Person(string name)\r\nPerson(string name, int age)\r\nEmployee(string name, int age, string company)\r\n&lt;/pre&gt;\r\n\r\n&lt;p&gt;В итоге мы получаем следующую цепь выполнений.&lt;/p&gt;\r\n&lt;ol&gt;\r\n&lt;li&gt;&lt;p&gt;Вначале вызывается конструктор &lt;strong&gt;Employee(string name, int age, string company)&lt;/strong&gt;. Он делегирует \r\nвыполнение конструктору &lt;strong&gt;Person(string name, int age)&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Вызывается конструктор &lt;strong&gt;Person(string name, int age)&lt;/strong&gt;, который сам пока не выполняется и передает \r\nвыполнение конструктору &lt;strong&gt;Person(string name)&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Вызывается конструктор &lt;strong&gt;Person(string name)&lt;/strong&gt;, который передает выполнение конструктору класса System.Object, \r\nтак как это базовый по умолчанию класс для Person.&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Выполняется конструктор &lt;strong&gt;System.Object.Object()&lt;/strong&gt;, затем выполнение возвращается конструктору &lt;strong&gt;Person(string name)&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Выполняется тело конструктора &lt;strong&gt;Person(string name)&lt;/strong&gt;, затем выполнение возвращается конструктору \r\n&lt;strong&gt;Person(string name, int age)&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Выполняется тело конструктора &lt;strong&gt;Person(string name, int age)&lt;/strong&gt;, затем выполнение возвращается конструктору \r\n&lt;strong&gt;Employee(string name, int age, string company)&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Выполняется тело конструктора &lt;strong&gt;Employee(string name, int age, string company)&lt;/strong&gt;. В итоге создается объект Employee&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ol&gt;'),
(29, 'Преобразование типов', 4, 2, 2, '&lt;p&gt;В предыдущей главе мы говорили о преобразованиях объектов простых типов. Сейчас затронем тему преобразования объектов классов. Допустим, у нас есть \r\nследующая иерархия классов:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Person\r\n{\r\n    public string Name { get; set; }\r\n    public Person(string name)\r\n    {\r\n        Name = name;\r\n    }\r\n    public void Print()\r\n    {\r\n        Console.WriteLine($&quot;Person {Name}&quot;);\r\n    }\r\n}\r\n \r\nclass Employee : Person\r\n{\r\n    public string Company { get; set; }\r\n    public Employee(string name, string company) : base(name)\r\n    {\r\n        Company = company;\r\n    }\r\n}\r\n \r\nclass Client : Person\r\n{\r\n    public string Bank { get; set; }\r\n    public Client(string name, string bank) : base(name)\r\n    {\r\n        Bank = bank;\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В этой иерархии классов мы можем проследить следующую цепь наследования: Object (все классы неявно наследуются от типа Object) -&gt; Person -&gt; Employee|Client.&lt;/p&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/3.12.png&quot; alt=&quot;Иерархия наследования в языке C#&quot;&gt;\r\n&lt;p&gt;Причем в этой иерархии классов базовые типы находятся вверху, а производные типы - внизу.&lt;/p&gt;\r\n&lt;h3&gt;Восходящие преобразования. Upcasting&lt;/h3&gt;\r\n&lt;p&gt;Объекты производного типа (который находится внизу иерархии) в то же время представляют и базовый тип. Например, объект Employee в то же время является и \r\nобъектом класса Person. Что в принципе естественно, так как каждый сотрудник (Employee) является человеком (Person). И мы можем написать, например, \r\nследующим образом:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nEmployee employee = new Employee(&quot;Tom&quot;, &quot;Microsoft&quot;);\r\nPerson person = employee;   // преобразование от Employee к Person\r\n \r\nConsole.WriteLine(person.Name); \r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае переменной person, которая представляет тип Person, присваивается ссылка на объект Employee. \r\nНо чтобы сохранить ссылку на объект одного класса в переменную другого класса, необходимо выполнить преобразование типов - в данном случае от типа Employee \r\nк типу Person. И так как Employee наследуется от класса Person, то автоматически выполняется неявное восходящее преобразование - преобразование к типу, \r\nкоторые находятся вверху иерархии классов, то есть к базовому классу.&lt;/p&gt;\r\n&lt;p&gt;В итоге переменные employee и person будут указывать на один и тот же объект в памяти, но переменной person будет доступна только та часть, которая представляет функционал типа Person.&lt;/p&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/3.15.png&quot; alt=&quot;Преобразование типов в C#&quot;&gt;\r\n&lt;p&gt;Подобным образом поизводятся и другие восходящие преобразования:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson bob = new Client(&quot;Bob&quot;, &quot;ContosoBank&quot;);   // преобразование от Client к Person\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь переменная bob, которая представляет тип Person, хранит ссылку на объект Client, поэтому также выполняется \r\nвосходящее неявное преобразование от производного класса Client к базовому типу Person.&lt;/p&gt;\r\n&lt;p&gt;Восходящее неявное преобразование будет происходить и в следующем случае:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nobject person1 = new Employee(&quot;Tom&quot;, &quot;Microsoft&quot;);  // от Employee к object\r\nobject person2 = new Client(&quot;Bob&quot;, &quot;ContosoBank&quot;);  // от Client к object\r\nobject person3 = new Person(&quot;Sam&quot;);                 // от Person к object\r\n&lt;/code&gt;\r\n&lt;p&gt;Так как тип object - базовый для всех остальных типов, то преобразование к нему будет производиться автоматически.&lt;/p&gt;\r\n&lt;h3&gt;Нисходящие преобразования. Downcasting&lt;/h3&gt;\r\n&lt;p&gt;Но кроме восходящих преобразований от производного к базовому типу есть нисходящие преобразования или downcasting - от базового типа к производному. Например, \r\nв следующем коде переменная person хранит ссылку на объект Employee:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nEmployee employee = new Employee(&quot;Tom&quot;, &quot;Microsoft&quot;);\r\nPerson person = employee;   // преобразование от Employee к Person\r\n&lt;/code&gt;\r\n&lt;p&gt;И может возникнуть вопрос, можно ли обратиться к функционалу типа Employee через переменную типа Person. Но автоматически такие преобразования не проходят, ведь не каждый \r\nчеловек (объект Person) является сотрудником предприятия (объектом Employee). \r\nИ для нисходящего преобразования необходимо применить явное преобразование, указав в скобках тип, к которому нужно выполнить преобразование:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nEmployee employee1 = new Employee(&quot;Tom&quot;, &quot;Microsoft&quot;);\r\nPerson person = employee1;   // преобразование от Employee к Person\r\n \r\n//Employee employee2 = person;    // так нельзя, нужно явное преобразование\r\nEmployee employee2 = (Employee)person;  // преобразование от Person к Employee\r\n&lt;/code&gt;\r\n&lt;p&gt;Рассмотрим некоторые примеры преобразований:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\n// Объект Employee также представляет тип object\r\nobject obj = new Employee(&quot;Bill&quot;, &quot;Microsoft&quot;);\r\n \r\n// чтобы обратиться к возможностям типа Employee, приводим объект к типу Employee\r\nEmployee employee = (Employee) obj;\r\n \r\n// объект Client также представляет тип Person\r\nPerson person = new Client(&quot;Sam&quot;, &quot;ContosoBank&quot;);\r\n// преобразование от типа Person к Client\r\nClient client = (Client)person;\r\n&lt;/code&gt;\r\n&lt;p&gt;В первом случае переменной obj присвоена ссылка на объект Employee, поэтому мы можем преобразовать объект obj к любому типу который располагается в иерархии \r\nклассов между типом object и Employee.&lt;/p&gt;\r\n&lt;p&gt;Если нам надо обратиться к каким-то отдельным свойствам или методам объекта, то нам необязательно присваивать преобразованный объект переменной:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\n// Объект Employee также представляет тип object\r\nobject obj = new Employee(&quot;Bill&quot;, &quot;Microsoft&quot;);\r\n \r\n// преобразование к типу Person для вызова метода Print\r\n((Person)obj).Print();\r\n// либо так\r\n// ((Employee)obj).Print();\r\n \r\n// преобразование к типу Employee, чтобы получить свойство Company\r\nstring company = ((Employee)obj).Company;\r\n&lt;/code&gt;\r\n&lt;p&gt;В то же время необходимо соблюдать осторожность при подобных преобразованиях. Например, что будет в следующем случае:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\n// Объект Employee также представляет тип object\r\nobject obj = new Employee(&quot;Bill&quot;, &quot;Microsoft&quot;);\r\n \r\n// преобразование к типу Client, чтобы получить свойство Bank\r\nstring bank = ((Client)obj).Bank;\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае мы получим ошибку, так как переменная obj хранит ссылку на объект Employee. Данный объект является также объектом типов object и Person, \r\nпоэтому мы можем преобразовать его к этим типам. Но к типу Client мы преобразовать не можем.&lt;/p&gt;\r\n&lt;p&gt;Другой пример:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nEmployee employee1 = new Person(&quot;Tom&quot;); // ! Ошибка\r\n \r\nPerson person = new Person(&quot;Bob&quot;);\r\nEmployee employee2 = (Employee) person; // ! Ошибка\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае мы пытаемся преобразовать объект типа Person к типу Employee, а объект Person не является объектом Employee. \r\nПричем в последнем случае Visual Studio не подскжет, что в данной строке ошибка, и данная строка даже нормально скомилируется, тем не менее \r\nв процессе выполнения программы мы получим ощибку. В этом в том числе и кроектся коварство преобразований, поэтому в подобных ситуациях надо проявлять осторожность.&lt;/p&gt;\r\n&lt;p&gt;Существует ряд способов, чтобы избежать подобных ошибок преобразования.&lt;/p&gt;\r\n&lt;h3&gt;Способы преобразований&lt;/h3&gt;\r\n&lt;p&gt;Во-первых, можно использовать ключевое слово &lt;strong&gt;as&lt;/strong&gt;. С помощью него программа пытается преобразовать выражение к определенному типу, при этом не \r\nвыбрасывает исключение. В случае неудачного преобразования выражение будет содержать значение null:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson person = new Person(&quot;Tom&quot;);\r\nEmployee? employee = person as Employee;\r\nif (employee == null)\r\n{\r\n    Console.WriteLine(&quot;Преобразование прошло неудачно&quot;);\r\n}\r\nelse\r\n{\r\n    Console.WriteLine(employee.Company);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Стоит отметить, что переменная &lt;strong&gt;employee&lt;/strong&gt; здесь определяется не просто как переменная Employee, а именно &lt;strong&gt;Employee?&lt;/strong&gt; - после названия типа ставится вопросительный знак. Что указывает, \r\nчто переменная может хранить как значение null, так и значение Employee.&lt;/p&gt;\r\n&lt;p&gt;Второй способ заключается в проверке допустимости преобразования с помощью ключевого слова &lt;strong&gt;is&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nзначение is тип\r\n&lt;/code&gt;\r\n&lt;p&gt;Если значение слева от оператора представляет тип, указаный справа от оператора, то оператор is возвращает &lt;strong&gt;true&lt;/strong&gt;, иначе возвращается &lt;strong&gt;false&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;p&gt;Причем оператор &lt;strong&gt;is&lt;/strong&gt; позволяет автоматически преобразовать значение к типу, если это значение представляет данный тип. Например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson person = new Person(&quot;Tom&quot;);\r\nif (person is Employee employee)\r\n{\r\n    Console.WriteLine(employee.Company);\r\n}\r\nelse\r\n{\r\n    Console.WriteLine(&quot;Преобразование не допустимо&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Выражение &lt;strong&gt;if (person is Employee employee)&lt;/strong&gt; проверяет, является ли переменная person объектом типа Employee. И если person является объектом \r\nEmployee, то автоматически преобразует значение переменной person в тип Employee и преобразованное значение сохраняет в переменную employee. Далее в блоке if мы можем \r\nиспользовать объект employee как значение типа Employee.&lt;/p&gt; \r\n&lt;p&gt;Однако, если person не является объектом Employee, как в данном случае, то такая проверка вернет значение &lt;strong&gt;false&lt;/strong&gt;, и преобразование \r\nне сработает.&lt;/p&gt;\r\n&lt;p&gt;Оператор &lt;strong&gt;is&lt;/strong&gt; также можно применять и без преобразования, просто проверяя на соответствие типу:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson person = new Person(&quot;Tom&quot;);\r\nif (person is Employee)\r\n{\r\n    Console.WriteLine(&quot;Представляет тип Employee&quot;);\r\n}\r\nelse\r\n{\r\n    Console.WriteLine(&quot;НЕ является объектом типа Employee&quot;);\r\n}\r\n&lt;/code&gt;'),
(30, 'Абстрактные классы и члены классов', 4, 3, 2, '&lt;p&gt;Кроме обычных классов в C# есть &lt;strong&gt;абстрактные классы&lt;/strong&gt;. Зачем они нужны? Классы обычно представляют некий план \r\nопределенного рода объектов или сущностей. Например, мы можем определить класс Car для преставления машин или класс Person для \r\nпредставления людей, вложив в эти классы соответствующие свойства, поля, методы, которые будут описывать данные объекты. \r\nОднако некоторые сущности, которые мы хотим выразить с помощью языка программирования, могут не иметь конкретного воплощения. \r\nНапример, в реальности не существует геометрической фигуры как таковой. Есть круг, прямоугольник, квадрат, но просто фигуры нет. \r\nОднако же и круг, и прямоугольник имеют что-то общее и являются фигурами. И для описания подобных сущностей, которые не имеют конкретного \r\nвоплощения, предназначены абстрактные классы.&lt;/p&gt;\r\n&lt;p&gt;Абстрактный класс похож на обычный класс. Он также может иметь переменные, методы, конструкторы, свойства. \r\nЕдинственное, что при определении абстрактных классов используется ключевое слово &lt;strong&gt;abstract&lt;/strong&gt;. Например, \r\nопределим абстрактный класс, который представляет некое транспортное средство:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nabstract class Transport\r\n{\r\n    public void Move()\r\n    {\r\n        Console.WriteLine(&quot;Транспортно средство движется&quot;);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Транспортное средство представляет некоторую абстракцию, которая не имеет конкретного воплощения. То есть есть легковые и грузовые машины, смолеты, морские судна, кто-то на космическом корабле любит покататься, но как такового \r\nтранспортного средства нет. Тем не менее все транспортные средства имеют нечто общее - они могут перемещаться. И для этого в классе определен метод Move, который эмулирует \r\nперемещение.&lt;/p&gt;\r\n&lt;p&gt;Но главное отличие абстрактных классов от обычных состоит в том, что мы &lt;strong&gt;НЕ можем&lt;/strong&gt; использовать конструктор абстрактного класса для создания экземпляра класса. \r\nНапример, следующим образом:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nTransport tesla = new Transport();\r\n&lt;/code&gt;\r\n&lt;p&gt;Тем не менее абстрактные классы полезны для описания некотоого общего функционала, который могут наследовать и использовать производные классы:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nTransport car = new Car();\r\nTransport ship = new Ship();\r\nTransport aircraft = new Aircraft();\r\n \r\ncar.Move();\r\nship.Move();\r\naircraft.Move();\r\nabstract class Transport\r\n{\r\n    public void Move()\r\n    {\r\n        Console.WriteLine(&quot;Транспортное средство движется&quot;);\r\n    }\r\n}\r\n// класс корабля\r\nclass Ship : Transport { }\r\n// класс самолета\r\nclass Aircraft : Transport { }\r\n// класс машины\r\nclass Car : Transport { }\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае от класса Transport наследуются три класса, которые представляют различные типы транспортных средств. Тем не менее они имеют общую черту - они могут перемещаться с помощью метода &lt;strong&gt;Move()&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;p&gt;Выше писалось, что мы не можем использовать конструктор абстрактного класса для создания экземпляра этого класса. Тем не менее такой класс также может определять конструкторы:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nTransport car = new Car(&quot;машина&quot;);\r\nTransport ship = new Ship(&quot;корабль&quot;);\r\nTransport aircraft = new Aircraft(&quot;самолет&quot;);\r\n \r\ncar.Move();         // машина движется\r\nship.Move();        // корабль движется\r\naircraft.Move();    // самолет движется\r\nabstract class Transport\r\n{\r\n    public string Name { get; }\r\n    // конструктор абстрактного класса Transport\r\n    public Transport(string name)\r\n    {\r\n        Name = name;\r\n    }\r\n    public void Move() =&gt;Console.WriteLine($&quot;{Name} движется&quot;);\r\n}\r\n// класс корабля\r\nclass Ship : Transport \r\n{\r\n    // вызываем конструктор базового класса\r\n    public Ship(string name) : base(name) { }\r\n}\r\n// класс самолета\r\nclass Aircraft : Transport\r\n{\r\n    public Aircraft(string name) : base(name) { }\r\n}\r\n// класс машины\r\nclass Car : Transport\r\n{\r\n    public Car(string name) : base(name) { }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае в абстрактном классе Transport определен конструктор - с помощью параметра он устанавливает значение свойства Name, которое хранит название \r\nтранспортного средства. И в этом случае производные классы должны в своих конструкторах вызвать этот конструктор.&lt;/p&gt;\r\n&lt;h3&gt;Абстрактные члены классов&lt;/h3&gt;\r\n&lt;p&gt;Кроме обычных свойств и методов абстрактный класс может иметь абстрактные члены классов, которые определяются с помощью ключевого слова &lt;strong&gt;abstract&lt;/strong&gt; и \r\nне имеют никакого функционала. В частности, абстрактными могут быть:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;Методы&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Свойства&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Индексаторы&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;События&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Абстрактные члены классов не должны иметь модификатор private. При этом производный класс обязан переопределить и реализовать все абстрактные методы и свойства, которые имеются в базовом абстрактном \r\nклассе. При переопределении в производном классе такой метод или свойство также объявляются с модификатором &lt;strong&gt;override&lt;/strong&gt; \r\n(как и при обычном переопределении виртуальных методов и свойств). \r\nТакже следует учесть, что если класс имеет хотя бы одный абстрактный метод (или абстрактные свойство, индексатор, событие), то этот класс должен быть определен как \r\n&lt;strong&gt;абстрактный&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;p&gt;Абстрактные члены также, как и виртуальные, являются частью полиморфного интерфейса. Но если в случае с виртуальными методами мы говорим, что класс-наследник \r\nнаследует реализацию, то в случае с абстрактными методами наследуется интерфейс, представленный этими абстрактными методами.&lt;/p&gt;\r\n&lt;h4&gt;Абстрактные методы&lt;/h4&gt;\r\n&lt;p&gt;Например, выше в примере с транспортными средствами метод Move описывает передвижение транспортного средства. Однако различные типы транспорта \r\nперемещаются по разному - едят по земле, летят по воздуху, плывут на воде и т.д. В этом случае мы можем сделать метод Move абстрактным, а его реализацию переложить на производные классы:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nabstract class Transport\r\n{\r\n    public abstract void Move();\r\n}\r\n// класс корабля\r\nclass Ship : Transport \r\n{\r\n    // мы должны реализовать все абстрактные методы и свойства базового класса\r\n    public override void Move()\r\n    {\r\n        Console.WriteLine(&quot;Корабль плывет&quot;);\r\n    }\r\n}\r\n// класс самолета\r\nclass Aircraft : Transport\r\n{\r\n    public override void Move()\r\n    {\r\n        Console.WriteLine(&quot;Самолет летит&quot;);\r\n    }\r\n}\r\n// класс машины\r\nclass Car : Transport\r\n{\r\n    public override void Move()\r\n    {\r\n        Console.WriteLine(&quot;Машина едет&quot;);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Применение классов:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nTransport car = new Car();\r\nTransport ship = new Ship();\r\nTransport aircraft = new Aircraft();\r\n \r\ncar.Move();         // машина едет\r\nship.Move();        // корабль плывет\r\naircraft.Move();    // самолет летит\r\n&lt;/code&gt;\r\n&lt;h4&gt;Абстрактные свойства&lt;/h4&gt;\r\n&lt;p&gt;Следует отметить использование абстрактных свойств. Их определение похоже на определение автосвойств. Например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nabstract class Transport\r\n{\r\n    // абстрактное свойство для хранения скорости\r\n    public abstract int Speed { get; set; } \r\n}\r\n// класс корабля\r\nclass Ship: Transport\r\n{\r\n    int speed;\r\n    public override int Speed \r\n    { \r\n        get =&gt; speed; \r\n        set =&gt; speed = value; \r\n    }\r\n}\r\n \r\nclass Aircraft : Transport\r\n{\r\n    public override int Speed { get; set; }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В классе Transport определено абстрактное свойство Speed, котоое должно хранить скорость транспортного средства. Оно похоже на автосвойство, но \r\nэто не автосвойство. Так как данное свойство не должно иметь реализацию, то оно имеет только пустые блоки get и set. \r\nВ производных классах мы можем переопределить это свойство, сделав его полноценным свойством (как в классе Ship), \r\nлибо же сделав его автоматическим (как в классе Aircraft).&lt;/p&gt;\r\n&lt;h4&gt;Отказ от реализации абстрактных членов&lt;/h4&gt;\r\n&lt;p&gt;Производный класс обязан реализовать все абстрактные члены базового класса. Однако мы можем отказаться от реализации, но в этом случае \r\nпроизводный класс также должен быть определен как абстрактный:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nTransport tesla = new Auto();\r\ntesla.Move();           // легковая машина едет\r\nabstract class Transport\r\n{\r\n    public abstract void Move();\r\n}\r\n// класс машины\r\nabstract class Car :Transport{}\r\n \r\nclass Auto: Car\r\n{\r\n    public override void Move()\r\n    {\r\n        Console.WriteLine(&quot;легковая машина едет&quot;);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае класс Car не реализует абстрактный метод Move базового класса Transport и поэтому также определен как абстрактный. Однако любые \r\nнеабстрактные классы, производные от Car, все равно должны реализовать все унаследованные абстрактные методы и свойства.&lt;/p&gt;\r\n&lt;h3&gt;Пример абстрактного класса&lt;/h3&gt;\r\n&lt;p&gt;Xрестоматийным примером является система геометрических фигур. В реальности не существует геометрической фигуры как таковой. Есть круг, прямоугольник, \r\nквадрат, но просто фигуры нет. Однако же и круг, и прямоугольник имеют что-то общее и являются фигурами:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\n// абстрактный класс фигуры\r\nabstract class Shape\r\n{\r\n    // абстрактный метод для получения периметра\r\n    public abstract double GetPerimeter();\r\n    // абстрактный метод для получения площади\r\n    public abstract double GetArea();\r\n}\r\n// производный класс прямоугольника\r\nclass Rectangle : Shape\r\n{\r\n    public float Width { get; set; }\r\n    public float Height { get; set; }\r\n \r\n    // переопределение получения периметра\r\n    public override double GetPerimeter() =&gt; Width * 2 + Height * 2;\r\n    // переопрелеление получения площади\r\n    public override double GetArea() =&gt; Width * Height;\r\n}\r\n// производный класс окружности\r\nclass Circle : Shape\r\n{\r\n    public double Radius { get; set; }\r\n \r\n    // переопределение получения периметра\r\n    public override double GetPerimeter() =&gt; Radius * 2 * 3.14;\r\n    // переопрелеление получения площади\r\n    public override double GetArea() =&gt; Radius * Radius * 3.14;\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Применение классов:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar rectanle = new Rectangle { Width = 20, Height = 20 };\r\nvar circle = new Circle { Radius = 200 };\r\nPrintShape(rectanle); // Perimeter: 80   Area: 400\r\nPrintShape(circle); // Perimeter: 1256  Area: 125600\r\n \r\nvoid PrintShape(Shape shape)\r\n{\r\n    Console.WriteLine($&quot;Perimeter: {shape.GetPerimeter()}  Area: {shape.GetArea()}&quot;);\r\n}   \r\n&lt;/code&gt;'),
(31, 'Класс System.Object и его методы', 4, 4, 2, '&lt;p&gt;Все классы в .NET, даже те, которые мы сами создаем, а также базовые типы, такие как \r\n&lt;strong&gt;System.Int32&lt;/strong&gt;, являются неявно производными от класса Object. Даже если мы не указываем класс Object в качестве базового, \r\nпо умолчанию неявно класс Object все равно стоит на вершине иерархии наследования. Поэтому все типы и классы могут реализовать те методы, \r\nкоторые определены в классе System.Object. Рассмотрим эти методы.&lt;/p&gt;\r\n&lt;h3&gt;ToString&lt;/h3&gt;\r\n&lt;p&gt;Метод &lt;strong&gt;ToString&lt;/strong&gt; служит для получения строкового представления данного объекта. Для базовых типов просто будет выводиться их строковое \r\nзначение:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint i = 5;\r\nConsole.WriteLine(i.ToString()); // выведет число 5\r\n \r\ndouble d = 3.5;\r\nConsole.WriteLine(d.ToString()); // выведет число 3,5\r\n&lt;/code&gt;\r\n&lt;p&gt;Для классов же этот метод выводит полное название класса с указанием пространства имен, в котором определен этот класс. И мы можем \r\nпереопределить данный метод. Посмотрим на примере:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson person = new Person { Name = &quot;Tom&quot; };\r\nConsole.WriteLine(person.ToString()); // выведет название класса Person\r\n \r\nClock clock = new Clock { Hours = 15, Minutes = 34, Seconds = 53 };\r\nConsole.WriteLine(clock.ToString()); // выведет 15:34:53\r\n \r\nclass Clock\r\n{\r\n    public int Hours { get; set; }\r\n    public int Minutes { get; set; }\r\n    public int Seconds { get; set; }\r\n    public override string ToString()\r\n    {\r\n        return $&quot;{Hours}:{Minutes}:{Seconds}&quot;;\r\n    }\r\n}\r\nclass Person\r\n{\r\n    public string Name { get; set; } = &quot;&quot;;\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Для переопределения метода &lt;strong&gt;ToString()&lt;/strong&gt; в классе Clock, который представляет часы, используется ключевое слово \r\n&lt;strong&gt;override&lt;/strong&gt; (как и при обычном переопределении виртуальных или абстрактных методов). В данном случае \r\nметод &lt;strong&gt;ToString()&lt;/strong&gt; выводит в строке значения свойств Hours, Minutes, Seconds.&lt;/p&gt;\r\n&lt;p&gt;Класс Person не переопределяет метод ToString, поэтому для этого класса срабатывает стандартная реализация этого метода, которая выводит \r\nпросто название класса.&lt;/p&gt;\r\n&lt;p&gt;Кстати в данном случае мы могли задействовать обе реализации:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson tom = new Person { Name = &quot;Tom&quot; };\r\nConsole.WriteLine(tom.ToString()); // Tom\r\n \r\nPerson undefined = new Person();\r\nConsole.WriteLine(undefined.ToString()); // Person\r\n \r\nclass Person\r\n{\r\n    public string Name { get; set; } = &quot;&quot;;\r\n \r\n    public override string? ToString()\r\n    {\r\n        if (string.IsNullOrEmpty(Name))\r\n            return base.ToString();\r\n        return Name;\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;То есть если имя - свойство Name не имеет значения, оно представляет пустую строку, то возвращается базовая реализация - название класса. \r\nСтоит отметить, что базовая реализация возвращает не просто строку, а объект &lt;strong&gt;string?&lt;/strong&gt; - то есть это может \r\nбыть строка string, либо значение &lt;strong&gt;null&lt;/strong&gt;, которое указывает на отсутствие значения. И в реальности в качестве возвращаемого типа для метода \r\nмы можем использовать как &lt;strong&gt;string&lt;/strong&gt;, так и &lt;strong&gt;string?&lt;/strong&gt;&lt;/p&gt;  \r\n&lt;p&gt;Если же имя у объекта Person установлено, то возвращается значение свойства Name. Для проверки строки на наличие значения применяется метод &lt;strong&gt;String.IsNullOrEmpty()&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;p&gt;Стоит отметить, что различные технологии на платформе .NET активно используют метод ToString для разных целей. В частности, тот же метод \r\n&lt;strong&gt;Console.WriteLine()&lt;/strong&gt; по умолчанию выводит именно строковое представление объекта. Поэтому, если нам надо вывести строковое представление объекта на консоль, то при передаче \r\nобъекта в метод Console.WriteLine необязательно использовать метод ToString() - он вызывается неявно:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson person = new Person { Name = &quot;Tom&quot; };\r\nConsole.WriteLine(person);  // Tom\r\n \r\nClock clock = new Clock { Hours = 15, Minutes = 34, Seconds = 53 };\r\nConsole.WriteLine(clock); // выведет 15:34:53\r\n&lt;/code&gt;\r\n&lt;h3&gt;Метод GetHashCode&lt;/h3&gt;\r\n&lt;p&gt;Метод &lt;strong&gt;GetHashCode&lt;/strong&gt; позволяет возвратить некоторое числовое значение, которое будет соответствовать данному объекту или его хэш-код. \r\nПо данному числу, например, можно сравнивать объекты. Можно определять самые разные алгоритмы генерации подобного числа или взять реализаци базового типа:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Person\r\n{\r\n    public string Name { get; set; } = &quot;&quot;;\r\n \r\n    public override int GetHashCode()\r\n    {\r\n        return Name.GetHashCode();\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае метод GetHashCode возвращает хеш-код для значения свойства Name. То есть два объекта Person, которые имеют одно и то же имя, будут возвращать один и тот \r\nже хеш-код. Однако в реальности алгоритм может быть самым различным.&lt;/p&gt;\r\n\r\n&lt;h3&gt;Получение типа объекта и метод GetType&lt;/h3&gt;\r\n&lt;p&gt;Метод &lt;strong&gt;GetType&lt;/strong&gt; позволяет получить тип данного объекта:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson person = new Person { Name = &quot;Tom&quot; };\r\nConsole.WriteLine(person.GetType());    // Person\r\n&lt;/code&gt;\r\n&lt;p&gt;Этот метод возвращает объект &lt;strong&gt;Type&lt;/strong&gt;, то есть тип объекта.&lt;/p&gt;\r\n&lt;p&gt;С помощью ключевого слова &lt;strong&gt;typeof&lt;/strong&gt; мы получаем тип класса и сравниваем его с типом объекта. И если этот объект представляет тип Client, \r\nто выполняем определенные действия.&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nobject person = new Person { Name = &quot;Tom&quot; };\r\nif (person.GetType() == typeof(Person))\r\n    Console.WriteLine(&quot;Это реально класс Person&quot;);\r\n&lt;/code&gt;\r\n&lt;p&gt;Причем поскольку класс Object является базовым типом для всех классов, то мы можем переменной типа object присвоить объект любого типа. Однако для этой переменной \r\nметод GetType все равно вернет тот тип, на объект которого ссылается переменная. То есть в данном случае объект типа Person.&lt;/p&gt;\r\n&lt;p&gt;Стоит отметить, что проверку типа можно скоратить с помощью оператора &lt;strong&gt;is&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nobject person = new Person { Name = &quot;Tom&quot; };\r\nif (person is Person)\r\n    Console.WriteLine(&quot;Это реально класс Person&quot;);\r\n&lt;/code&gt;\r\n&lt;p&gt;В отличие от методов ToString, Equals, GetHashCode метод &lt;strong&gt;GetType()&lt;/strong&gt; не переопределяется.&lt;/p&gt;\r\n&lt;h3&gt;Метод Equals&lt;/h3&gt;\r\n&lt;p&gt;Метод Equals позволяет сравнить два объекта на равенство. В качестве параметра он принимает объект для сравнения в виде типа &lt;strong&gt;object&lt;/strong&gt; и возврашает \r\n&lt;strong&gt;true&lt;/strong&gt;, если оба объекта равны:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\npublic override bool Equals(object? obj) {......}\r\n&lt;/code&gt;\r\n&lt;p&gt;Например, реализуем данный метод в классе Person:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Person\r\n{\r\n    public string Name { get; set; } = &quot;&quot;;\r\n    public override bool Equals(object? obj)\r\n    {\r\n        // если параметр метода представляет тип Person\r\n        // то возвращаем true, если имена совпадают\r\n        if (obj is Person person) return Name == person.Name;\r\n        return false;\r\n    }\r\n    // вместе с методом Equals следует реализовать метод GetHashCode\r\n    public override int GetHashCode() =&gt; Name.GetHashCode();\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Метод Equals принимает в качестве параметра объект любого типа, который мы затем приводим к текущему классу - классу Person.&lt;/p&gt;\r\n&lt;p&gt;Если переданный объект представляет тип Person, то возвращаем результат сравнения имен двух объектов Person. Если же объект представляет другой тип, то возвращается false.&lt;/p&gt;\r\n&lt;p&gt;В данном случае для примера применяется довольно простой алгоритм сравнения, однако при необходимости \r\nреализацию метода можно сделать более сложной, например, сравнивать по нескольким свойствам при их наличии.&lt;/p&gt;\r\n&lt;p&gt;Стоит отметить, что вместе с методом Equals следует реализовать метод GetHashCode.&lt;/p&gt;\r\n&lt;p&gt;Применение метода:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar person1 = new Person { Name = &quot;Tom&quot; };\r\nvar person2 = new Person { Name = &quot;Bob&quot; };\r\nvar person3 = new Person { Name = &quot;Tom&quot; };\r\n \r\nbool person1EqualsPerson2 = person1.Equals(person2);   // false\r\nbool person1EqualsPerson3 = person1.Equals(person3);   // true\r\n \r\nConsole.WriteLine(person1EqualsPerson2);    // false\r\nConsole.WriteLine(person1EqualsPerson3);    // true\r\n&lt;/code&gt;\r\n&lt;p&gt;И если следует сравнивать два сложных объекта, как в данном случае, то лучше использовать метод Equals, а не стандартную операцию ==.&lt;/p&gt;');
INSERT INTO `lectures` (`IDLecture`, `Name`, `IDChapter`, `SerialNumber`, `IDStatus`, `Content`) VALUES
(32, 'Конструкция try..catch..finally', 14, 1, 2, '&lt;p&gt;Иногда при выполнении программы возникают ошибки, которые трудно предусмотреть или предвидеть, а  иногда и вовсе невозможно. Например, при передачи файла по сети может неожиданно оборваться сетевое подключение. \r\nтакие ситуации называются &lt;strong&gt;исключениями&lt;/strong&gt;. Язык C# предоставляет разработчикам возможности для обработки таких ситуаций. Для этого \r\nв C# предназначена конструкция &lt;strong&gt;try...catch...finally&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ntry\r\n{\r\n     \r\n}\r\ncatch\r\n{\r\n     \r\n}\r\nfinally\r\n{\r\n     \r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;При использовании блока &lt;strong&gt;try...catch..finally&lt;/strong&gt; вначале выполняются все инструкции в блоке &lt;strong&gt;try&lt;/strong&gt;. Если в \r\nэтом блоке не возникло исключений, то после его выполнения начинает выполняться блок &lt;strong&gt;finally&lt;/strong&gt;. И затем конструкция try..catch..finally \r\nзавершает свою работу.&lt;/p&gt;\r\n&lt;p&gt;Если же в блоке try вдруг возникает исключение, то обычный порядок выполнения останавливается, и среда CLR \r\nначинает искать блок &lt;strong&gt;catch&lt;/strong&gt;, который может обработать данное исключение. Если нужный блок \r\ncatch найден, то он выполняется, и после его завершения выполняется блок finally.&lt;/p&gt;\r\n&lt;p&gt;Если нужный блок catch не найден, то при возникновении исключения программа аварийно завершает свое выполнение.&lt;/p&gt;\r\n&lt;p&gt;Рассмотрим следующий пример:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint x = 5;\r\nint y = x / 0;\r\nConsole.WriteLine($&quot;Результат: {y}&quot;);\r\nConsole.WriteLine(&quot;Конец программы&quot;);\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае происходит деление числа на 0, что приведет к генерации исключения. И при запуске приложения в \r\nрежиме отладки мы увидим в Visual Studio окошко, которое информирует об исключении:&lt;/p&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/2.10.png&quot; alt=&quot;Исключения в C#&quot;&gt;\r\n&lt;p&gt;В этом окошке мы видим, что возникло исключение, которое представляет тип &lt;strong&gt;System.DivideByZeroException&lt;/strong&gt;, \r\nто есть попытка деления на ноль. С помощью пункта &lt;strong&gt;View Details&lt;/strong&gt; можно посмотреть более детальную информацию об исключении.&lt;/p&gt;\r\n&lt;p&gt;И в этом случае единственное, что нам остается, это завершить выполнение программы.&lt;/p&gt;\r\n&lt;p&gt;Чтобы избежать подобного аварийного завершения программы, следует использовать для обработки исключений конструкцию \r\n&lt;strong&gt;try...catch...finally&lt;/strong&gt;. Так, перепишем пример следующим образом:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ntry\r\n{\r\n    int x = 5;\r\n    int y = x / 0;\r\n    Console.WriteLine($&quot;Результат: {y}&quot;);\r\n}\r\ncatch\r\n{\r\n    Console.WriteLine(&quot;Возникло исключение!&quot;);\r\n}\r\nfinally\r\n{\r\n    Console.WriteLine(&quot;Блок finally&quot;);\r\n}\r\nConsole.WriteLine(&quot;Конец программы&quot;);\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае у нас опять же возникнет исключение в блоке try, так как мы пытаемся разделить на ноль. \r\nИ дойдя до строки&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint y = x / 0;\r\n&lt;/code&gt;\r\n&lt;p&gt;выполнение программы остановится. CLR найдет блок &lt;strong&gt;catch&lt;/strong&gt; и передаст управление этому блоку.&lt;/p&gt;\r\n&lt;p&gt;После блока catch будет выполняться блок finally.&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Возникло исключение!\r\nБлок finally\r\nКонец программы\r\n&lt;/pre&gt;\r\n\r\n&lt;p&gt;Таким образом, программа по-прежнему не будет выполнять деление на ноль и соответственно не будет выводить результат этого деления, \r\nно теперь она не будет аварийно завершаться, а исключение будет обрабатываться в блоке catch.&lt;/p&gt;\r\n&lt;p&gt;Следует отметить, что в этой конструкции обязателен блок &lt;strong&gt;try&lt;/strong&gt;. При наличии блока catch мы можем опустить блок finally:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ntry\r\n{\r\n    int x = 5;\r\n    int y = x / 0;\r\n    Console.WriteLine($&quot;Результат: {y}&quot;);\r\n}\r\ncatch\r\n{\r\n    Console.WriteLine(&quot;Возникло исключение!&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;И, наоборот, при наличии блока finally мы можем опустить блок catch и не обрабатывать исключение:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ntry\r\n{\r\n    int x = 5;\r\n    int y = x / 0;\r\n    Console.WriteLine($&quot;Результат: {y}&quot;);\r\n}\r\nfinally\r\n{\r\n    Console.WriteLine(&quot;Блок finally&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Однако, хотя с точки зрения синтаксиса C# такая конструкция вполне корректна, тем не менее, поскольку CLR не сможет найти нужный блок \r\ncatch, то исключение не будет обработано, и программа аварийно завершится.&lt;/p&gt;\r\n&lt;h3&gt;Обработка исключений и условные конструкции&lt;/h3&gt;\r\n&lt;p&gt;Ряд исключительных ситуаций может быть предвиден разработчиком. Например, пусть в программе есть метод, который принимает строку, конвертирует ее в число \r\nи вычисляет квадрат этого числа:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nSquare(&quot;12&quot;); // Квадрат числа 12: 144\r\nSquare(&quot;ab&quot;); // !Исключение\r\n \r\nvoid Square(string data)\r\n{\r\n    int x = int.Parse(data);\r\n    Console.WriteLine($&quot;Квадрат числа {x}: {x * x}&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Если пользователь передаст в метод не число, а строку, которая содежит нецифровые символы, то программа выпадет в ошибку. С одной стороны, \r\nздесь как раз та ситуация, когда можно применить блок \r\n&lt;strong&gt;try..catch&lt;/strong&gt;, чтобы обработать возможную ошибку. Однако гораздо оптимальнее было бы проверить допустимость преобразования:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nSquare(&quot;12&quot;); // Квадрат числа 12: 144\r\nSquare(&quot;ab&quot;); // Некорректный ввод\r\n \r\nvoid Square(string data)\r\n{\r\n    if (int.TryParse(data, out var x))\r\n    {\r\n        Console.WriteLine($&quot;Квадрат числа {x}: {x * x}&quot;);\r\n    }\r\n    else\r\n    {\r\n        Console.WriteLine(&quot;Некорректный ввод&quot;);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Метод &lt;strong&gt;int.TryParse()&lt;/strong&gt; возвращает &lt;strong&gt;true&lt;/strong&gt;, если преобразование можно осуществить, и &lt;strong&gt;false&lt;/strong&gt; - если нельзя. При допустимости преобразования переменная x \r\nбудет содержать введенное число. Так, не используя &lt;strong&gt;try...catch&lt;/strong&gt; можно обработать возможную исключительную ситуацию.&lt;/p&gt;\r\n&lt;p&gt;С точки зрения производительности использование блоков &lt;strong&gt;try..catch&lt;/strong&gt; более накладно, чем применение условных конструкций. Поэтому по возможности \r\nвместо try..catch лучше использовать условные конструкции на проверку исключительных ситуаций.&lt;/p&gt;'),
(33, 'Блок catch и фильтры исключений', 14, 2, 2, '&lt;p&gt;За обработку исключения отвечает блок &lt;strong&gt;catch&lt;/strong&gt;, который может иметь следующие формы:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;code&gt;\r\n\r\ncatch\r\n{\r\n    // выполняемые инструкции\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Обрабатывает любое исключение, которое возникло в блоке try. Выше уже был продемонстрирован пример подобного блока.&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;code&gt;\r\n\r\ncatch (тип_исключения)\r\n{\r\n    // выполняемые инструкции\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Обрабатывает только те исключения, которые соответствуют типу, указаному в скобках после оператора catch.&lt;/p&gt;\r\n&lt;p&gt;Например, обработаем только исключения типа DivideByZeroException:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ntry\r\n{\r\n    int x = 5;\r\n    int y = x / 0;\r\n    Console.WriteLine($&quot;Результат: {y}&quot;);\r\n}\r\ncatch(DivideByZeroException)\r\n{\r\n    Console.WriteLine(&quot;Возникло исключение DivideByZeroException&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Однако если в блоке try возникнут исключения каких-то других типов, отличных от DivideByZeroException, то они не будут обработаны.&lt;/p&gt;\r\n&lt;/li&gt;\r\n&lt;li&gt;&lt;code&gt;\r\n\r\ncatch (тип_исключения имя_переменной)\r\n{\r\n    // выполняемые инструкции\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Обрабатывает только те исключения, которые соответствуют типу, указаному в скобках после оператора catch. А вся информация \r\nоб исключении помещается в переменную данного типа. Например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ntry\r\n{\r\n    int x = 5;\r\n    int y = x / 0;\r\n    Console.WriteLine($&quot;Результат: {y}&quot;);\r\n}\r\ncatch(DivideByZeroException ex)\r\n{\r\n    Console.WriteLine($&quot;Возникло исключение {ex.Message}&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Фактически этот случай аналогичен предыдущему за тем исключением, что здесь используется переменная. В данном случае в переменную &lt;strong&gt;ex&lt;/strong&gt;, которая представляет тип DivideByZeroException, помещается \r\nинформация о возникшем исключени. И с помощью свойства &lt;strong&gt;Message&lt;/strong&gt; мы можем получить сообщение об ошибке.&lt;/p&gt;\r\n&lt;p&gt;Если нам не нужна информация об исключении, то переменную можно не использовать как в предыдущем случае.&lt;/p&gt;\r\n&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;h3&gt;Фильтры исключений&lt;/h3&gt;\r\n&lt;p&gt;Фильтры исключений позволяют обрабатывать исключения в зависимости от определенных условий. Для их применения \r\nпосле выражения catch идет выражение &lt;strong&gt;when&lt;/strong&gt;, после которого в скобках указывается \r\nусловие:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ncatch when(условие)\r\n{\r\n     \r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В этом случае обработка исключения в блоке catch производится только в том случае, если условие в выражении when истинно. \r\nНапример:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint x = 1;\r\nint y = 0;\r\n \r\ntry\r\n{\r\n    int result1 = x / y;\r\n    int result2 = y / x;\r\n}\r\ncatch (DivideByZeroException) when (y == 0)\r\n{\r\n    Console.WriteLine(&quot;y не должен быть равен 0&quot;);\r\n}\r\ncatch(DivideByZeroException ex)\r\n{\r\n    Console.WriteLine(ex.Message);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае будет выброшено исключение, так как y=0. Здесь два блока catch, и оба они обрабатывают исключения типа \r\nDivideByZeroException, то есть по сути все исключения, генерируемые при делении на ноль. Но поскольку для первого блока указано условие \r\n&lt;strong&gt;y == 0&lt;/strong&gt;, то именно этот блок будет обрабатывать данное исключение - условие, указанное после оператора &lt;strong&gt;when&lt;/strong&gt; \r\nвозвращает true.&lt;/p&gt;\r\n&lt;p&gt;Противоположная ситуация:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint x = 0;\r\nint y = 1;\r\n \r\ntry\r\n{\r\n    int result1 = x / y;\r\n    int result2 = y / x;\r\n}\r\ncatch (DivideByZeroException) when (y == 0)\r\n{\r\n    Console.WriteLine(&quot;y не должен быть равен 0&quot;);\r\n}\r\ncatch(DivideByZeroException ex)\r\n{\r\n    Console.WriteLine(ex.Message);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае будет выброшено исключение, так как x=0. Условие первого блока catch - &lt;strong&gt;y == 0&lt;/strong&gt; \r\nтеперь возвращает  false. Поэтому CLR будет дальше искать соответствующие блоки catch далее и для обработки исключения \r\nвыберет второй блок catch. В итоге если мы уберем второй блок catch, то исключение вобще не будет обрабатываться.&lt;/p&gt;'),
(34, 'Типы исключений. Класс Exception', 14, 3, 2, '&lt;p&gt;Базовым для всех типов исключений является тип &lt;strong&gt;Exception&lt;/strong&gt;. Этот тип определяет ряд свойств, с помощью которых можно получить информацию об исключении.&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;InnerException&lt;/strong&gt;: хранит информацию об исключении, которое послужило причиной текущего исключения&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Message&lt;/strong&gt;: хранит сообщение об исключении, текст ошибки&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Source&lt;/strong&gt;: хранит имя объекта или сборки, которое вызвало исключение&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;StackTrace&lt;/strong&gt;: возвращает строковое представление стека вызывов, которые привели к возникновению исключения&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;TargetSite&lt;/strong&gt;: возвращает метод, в котором и было вызвано исключение&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Например, обработаем исключения типа Exception:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ntry\r\n{\r\n    int x = 5;\r\n    int y = x / 0;\r\n    Console.WriteLine($&quot;Результат: {y}&quot;);\r\n}\r\ncatch (Exception ex)\r\n{\r\n    Console.WriteLine($&quot;Исключение: {ex.Message}&quot;);\r\n    Console.WriteLine($&quot;Метод: {ex.TargetSite}&quot;);\r\n    Console.WriteLine($&quot;Трассировка стека: {ex.StackTrace}&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/2.11.png&quot; alt=&quot;Обработка исключений и класс Exception в C#&quot;&gt;\r\n&lt;p&gt;Однако так как тип Exception является базовым типом для всех исключений, то выражение &lt;strong&gt;catch (Exception ex)&lt;/strong&gt; \r\nбудет обрабатывать все исключения, которые могут возникнуть.&lt;/p&gt;\r\n&lt;p&gt;Но также есть более специализированные типы исключений, которые предназначены для обработки каких-то определенных видов исключений. \r\nИх довольно много, я приведу лишь некоторые:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;DivideByZeroException&lt;/strong&gt;: представляет исключение, которое генерируется при делении на ноль&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;ArgumentOutOfRangeException&lt;/strong&gt;: генерируется, если значение аргумента находится вне диапазона \r\nдопустимых значений&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;ArgumentException&lt;/strong&gt;: генерируется, если в метод для параметра передается некорректное значение&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;IndexOutOfRangeException&lt;/strong&gt;: генерируется, если индекс элемента массива или коллекции находится вне диапазона \r\nдопустимых значений&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;InvalidCastException&lt;/strong&gt;: генерируется при попытке произвести недопустимые преобразования типов&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;NullReferenceException&lt;/strong&gt;: генерируется при попытке обращения к объекту, который равен null (то есть по сути неопределен)&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;И при необходимости мы можем разграничить обработку различных типов исключений, включив дополнительные блоки catch:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nstatic void Main(string[] args)\r\n{\r\n    try\r\n    {\r\n        int[] numbers = new int[4];\r\n        numbers[7] = 9;     // IndexOutOfRangeException\r\n \r\n        int x = 5;\r\n        int y = x / 0;  // DivideByZeroException\r\n        Console.WriteLine($&quot;Результат: {y}&quot;);\r\n    }\r\n    catch (DivideByZeroException)\r\n    {\r\n        Console.WriteLine(&quot;Возникло исключение DivideByZeroException&quot;);\r\n    }\r\n    catch (IndexOutOfRangeException ex)\r\n    {\r\n        Console.WriteLine(ex.Message);\r\n    }\r\n             \r\n    Console.Read();\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае блоки catch обрабатывают исключения типов IndexOutOfRangeException, DivideByZeroException и Exception. Когда в блоке try возникнет исключение, \r\nто CLR будет искать нужный блок catch для обработки исключения. Так, в данном случае на строке&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nnumbers[7] = 9;\r\n&lt;/code&gt;\r\n&lt;p&gt;происходит обращение к 7-му элементу массива. Однако поскольку в массиве только 4 элемента, то мы получим исключение типа \r\nIndexOutOfRangeException. CLR найдет блок catch, который обрабатывает данное исключение, и передаст ему управление.&lt;/p&gt;\r\n&lt;p&gt;Следует отметить, что в данном случае в блоке try есть ситуация для генерации второго исключения - деление на ноль. \r\nОднако поскольку после генерации IndexOutOfRangeException управление переходит в соответствующий блок catch, то деление на ноль &lt;strong&gt;int y = x / 0&lt;/strong&gt; \r\nв принципе не будет выполняться, поэтому исключение типа DivideByZeroException никогда не будет сгенерировано.&lt;/p&gt;\r\n&lt;p&gt;Однако рассмотрим другую ситуацию:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ntry\r\n{\r\n    object obj = &quot;you&quot;;\r\n    int num = (int)obj;     // System.InvalidCastException\r\n    Console.WriteLine($&quot;Результат: {num}&quot;);\r\n}\r\ncatch (DivideByZeroException)\r\n{\r\n    Console.WriteLine(&quot;Возникло исключение DivideByZeroException&quot;);\r\n}\r\ncatch (IndexOutOfRangeException)\r\n{\r\n    Console.WriteLine(&quot;Возникло исключение IndexOutOfRangeException&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае в блоке try генерируется исключение типа InvalidCastException, однако соответствующего блока catch для \r\nобработки данного исключения нет. Поэтому программа аварийно завершит свое выполнение.&lt;/p&gt;\r\n&lt;p&gt;Мы также можем определить для InvalidCastException свой блок catch, однако суть в том, что теоретически в коде \r\nмогут быть сгенерированы самыи разные типы исключений. А определять для всех типов исключений блоки catch, \r\nесли обработка исключений однотипна, не имеет смысла. И в этом случае мы можем определить блок catch для базового типа Exception:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ntry\r\n{\r\n    object obj = &quot;you&quot;;\r\n    int num = (int)obj;     // System.InvalidCastException\r\n    Console.WriteLine($&quot;Результат: {num}&quot;);\r\n}\r\ncatch (DivideByZeroException)\r\n{\r\n    Console.WriteLine(&quot;Возникло исключение DivideByZeroException&quot;);\r\n}\r\ncatch (IndexOutOfRangeException)\r\n{\r\n    Console.WriteLine(&quot;Возникло исключение IndexOutOfRangeException&quot;);\r\n}\r\ncatch (Exception ex)\r\n{\r\n    Console.WriteLine($&quot;Исключение: {ex.Message}&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;И в данном случае блок &lt;strong&gt;catch (Exception ex){}&lt;/strong&gt; будет обрабатывать все исключения кроме DivideByZeroException \r\nи IndexOutOfRangeException. При этом блоки catch для более общих, более базовых исключений следует помещать \r\nв конце - после блоков catch для более конкретный, специализированных типов. Так как CLR выбирает для обработки исключения \r\nпервый блок catch, который соответствует типу сгенерированного исключения. \r\nПоэтому в данном случае сначала обрабатывается исключение DivideByZeroException и IndexOutOfRangeException, и только потом \r\nException (так как DivideByZeroException и IndexOutOfRangeException наследуется от класса Exception).&lt;/p&gt;'),
(35, 'Генерация исключения и оператор throw', 14, 4, 2, '&lt;p&gt;Обычно система сама генерирует исключения при определенных ситуациях, например, при делении числа на ноль. Но язык C# \r\nтакже позволяет генерировать исключения вручную с помощью оператора &lt;strong&gt;throw&lt;/strong&gt;. То есть с помощью \r\nэтого оператора мы сами можем создать исключение и вызвать его в процессе выполнения.&lt;/p&gt;\r\n&lt;p&gt;Например, в нашей программе происходит ввод имени пользователя, и мы хотим, чтобы, если длина имени меньше 2 символов, то \r\nвозникало исключение:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ntry\r\n{\r\n    Console.Write(&quot;Введите имя: &quot;);\r\n    string? name = Console.ReadLine();\r\n    if (name== null || name.Length &lt; 2)\r\n    {\r\n        throw new Exception(&quot;Длина имени меньше 2 символов&quot;);\r\n    }\r\n    else\r\n    {\r\n        Console.WriteLine($&quot;Ваше имя: {name}&quot;);\r\n    }\r\n}\r\ncatch (Exception e)\r\n{\r\n    Console.WriteLine($&quot;Ошибка: {e.Message}&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;После оператора &lt;strong&gt;throw&lt;/strong&gt; указывается объект исключения, через конструктор которого мы можем передать сообщение \r\nоб ошибке. Естественно вместо типа Exception мы можем использовать объект любого другого типа исключений.&lt;/p&gt;\r\n&lt;p&gt;Затем в блоке catch сгенерированное нами исключение будет обработано.&lt;/p&gt;\r\n&lt;p&gt;Подобным образом мы можем генерировать исключения в любом месте программы. Но существует также и другая форма \r\nиспользования оператора throw, когда после данного оператора не указывается объект исключения. В подобном виде оператор throw \r\nможет использоваться только в блоке catch:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ntry\r\n{\r\n    try\r\n    {\r\n        Console.Write(&quot;Введите имя: &quot;);\r\n        string? name = Console.ReadLine();\r\n        if (name == null || name.Length &lt; 2)\r\n        {\r\n            throw new Exception(&quot;Длина имени меньше 2 символов&quot;);\r\n        }\r\n        else\r\n        {\r\n            Console.WriteLine($&quot;Ваше имя: {name}&quot;);\r\n        }\r\n    }\r\n    catch (Exception e)\r\n    {\r\n        Console.WriteLine($&quot;Ошибка: {e.Message}&quot;);\r\n        throw;\r\n    }\r\n}\r\ncatch (Exception ex)\r\n{\r\n    Console.WriteLine(ex.Message);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае при вводе имени с длиной меньше 2 символов возникнет исключение, которое будет обработано внутренним блоком catch. \r\nОднако поскольку в этом блоке используется оператор throw, то исключение будет передано дальше внешнему блоку catch, который получит то же смое исключение и выведет то же самое сообщение на консоль.&lt;/p&gt;'),
(36, 'Создание классов исключений', 14, 5, 2, '&lt;p&gt;Если нас не устраивают встроенные типы исключений, то мы можем создать свои типы. Базовым классом \r\nдля всех исключений является класс Exception, соответственно для создания своих типов мы можем унаследовать данный класс.&lt;/p&gt;\r\n&lt;p&gt;Допустим, у нас в программе будет ограничение по возрасту:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ntry\r\n{\r\n    Person person = new Person { Name = &quot;Tom&quot;, Age = 17 };\r\n}\r\ncatch (Exception ex)\r\n{\r\n    Console.WriteLine($&quot;Ошибка: {ex.Message}&quot;);\r\n}\r\n \r\nclass Person\r\n{\r\n    private int age;\r\n    public string Name { get; set; } = &quot;&quot;;\r\n    public int Age\r\n    {\r\n        get =&gt; age;\r\n        set\r\n        {\r\n            if (value &lt; 18)\r\n                throw new Exception(&quot;Лицам до 18 регистрация запрещена&quot;);\r\n            else\r\n                age = value;\r\n        }\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В классе Person при установке возраста происходит проверка, и если возраст меньше 18, то выбрасывается исключение. Класс Exception принимает \r\nв конструкторе в качестве параметра строку, которое затем передается в его свойство Message.&lt;/p&gt;\r\n&lt;p&gt;Но иногда удобнее использовать свои классы исключений. Например, в какой-то ситуации мы хотим обработать определенным образом только те исключения, \r\nкоторые относятся к классу Person. Для этих целей мы можем сделать специальный класс PersonException:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass PersonException : Exception\r\n{\r\n    public PersonException(string message)\r\n        : base(message) { }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;По сути класс кроме пустого конструктора ничего не имеет, и то в конструкторе мы просто обращаемся к конструктору базового класса \r\nException, передавая в него строку message. Но теперь мы можем изменить класс Person, чтобы он выбрасывал исключение именно этого типа и \r\nсоответственно в основной программе обрабатывать это исключение:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ntry\r\n{\r\n    Person person = new Person { Name = &quot;Tom&quot;, Age = 17 };\r\n}\r\ncatch (PersonException ex)\r\n{\r\n    Console.WriteLine($&quot;Ошибка: {ex.Message}&quot;);\r\n}\r\n \r\nclass Person\r\n{\r\n    private int age;\r\n    public string Name { get; set; } = &quot;&quot;;\r\n    public int Age\r\n    {\r\n        get =&gt; age;\r\n        set\r\n        {\r\n            if (value &lt; 18)\r\n                throw new PersonException(&quot;Лицам до 18 регистрация запрещена&quot;);\r\n            else\r\n                age = value;\r\n        }\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Однако необязательно наследовать свой класс исключений именно от типа Exception, можно взять какой-нибудь другой \r\nпроизводный тип. Например, в данном случае мы можем взять тип ArgumentException, который представляет исключение, \r\nгенерируемое в результате передачи аргументу метода некорректного значения:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass PersonException : ArgumentException\r\n{\r\n    public PersonException(string message)\r\n        : base(message)\r\n    { }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Каждый тип исключений может определять какие-то свои свойства. Например, в данном случае мы можем определить в классе свойство для хранения устанавливаемого значения:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass PersonException : ArgumentException\r\n{\r\n    public int Value { get;}\r\n    public PersonException(string message, int val)\r\n        : base(message)\r\n    {\r\n        Value = val;\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В конструкторе класса мы устанавливаем это свойство и при обработке исключения мы его можем получить:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ntry\r\n{\r\n    Person person = new Person { Name = &quot;Tom&quot;, Age = 17 };\r\n}\r\ncatch (PersonException ex)\r\n{\r\n    Console.WriteLine($&quot;Ошибка: {ex.Message}&quot;);\r\n    Console.WriteLine($&quot;Некорректное значение: {ex.Value}&quot;);\r\n}\r\n \r\nclass Person\r\n{\r\n    private int age;\r\n    public string Name { get; set; } = &quot;&quot;;\r\n    public int Age\r\n    {\r\n        get =&gt; age;\r\n        set\r\n        {\r\n            if (value &lt; 18)\r\n                throw new PersonException(&quot;Лицам до 18 регистрация запрещена&quot;, value);\r\n            else\r\n                age = value;\r\n        }\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;И в данном случае мы получим следующий консольный вывод:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Ошибка: Лицам до 18 регистрация запрещена\r\nНекорректное значение: 17\r\n&lt;/pre&gt;\r\n\r\n'),
(37, 'Поиск блока catch при обработке исключений', 14, 6, 2, '&lt;p&gt;Если код, который вызывает исключение, не размещен в блоке try или помещен в конструкцию try..catch, которая не \r\nсодержит соответствующего блока catch для обработки возникшего исключения, то система производит поиск соответствующего обработчика исключения в стеке вызовов.&lt;/p&gt;\r\n&lt;p&gt;Например, рассмотрим следующую программу:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ntry\r\n{\r\n    TestClass.Method1();\r\n}\r\ncatch (DivideByZeroException ex)\r\n{\r\n    Console.WriteLine($&quot;Catch в Main : {ex.Message}&quot;);\r\n}\r\nfinally\r\n{\r\n    Console.WriteLine(&quot;Блок finally в Main&quot;);\r\n}\r\nConsole.WriteLine(&quot;Конец метода Main&quot;);\r\n \r\nclass TestClass\r\n{\r\n    public static void Method1()\r\n    {\r\n        try\r\n        {\r\n            Method2();\r\n        }\r\n        catch (IndexOutOfRangeException ex)\r\n        {\r\n            Console.WriteLine($&quot;Catch в Method1 : {ex.Message}&quot;);\r\n        }\r\n        finally\r\n        {\r\n            Console.WriteLine(&quot;Блок finally в Method1&quot;);\r\n        }\r\n        Console.WriteLine(&quot;Конец метода Method1&quot;);\r\n    }\r\n    static void Method2()\r\n    {\r\n        try\r\n        {\r\n            int x = 8;\r\n            int y = x / 0;\r\n        }\r\n        finally\r\n        {\r\n            Console.WriteLine(&quot;Блок finally в Method2&quot;);\r\n        }\r\n        Console.WriteLine(&quot;Конец метода Method2&quot;);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае стек вызовов выглядит следующим образом: метод Main вызывает метод Method1, который, в свою очередь, вызывает метод Method2. И в методе \r\nMethod2 генерируется исключение DivideByZeroException. Визуально стек вызовов можно представить следующим образом:&lt;/p&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/2.12.png&quot; alt=&quot;Поиск блока catch при обработке исключения в C#&quot;&gt;\r\n&lt;p&gt;Внизу стека метод Main, с которого началось выполнение, и на самом верху метод Method2.&lt;/p&gt;\r\n&lt;p&gt;Что будет происходить в данном случае при генерации исключения?&lt;/p&gt;\r\n&lt;ol&gt;\r\n&lt;li&gt;&lt;p&gt;Метод Main вызывает метод Method1, а тот вызывает метод Method2, в котором генерируется исключение DivideByZeroException.&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Система видит, что код, который вызывал исключение, помещен в конструкцию try..catch&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ntry\r\n{\r\n    int x = 8;\r\n    int y = x / 0;\r\n}\r\nfinally\r\n{\r\n    Console.WriteLine(&quot;Блок finally в Method2&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Система ищет в этой конструкции блок catch, который обрабатывает исключение DivideByZeroException. Однако такого блока catch нет.&lt;/p&gt;&lt;/li&gt;\r\n\r\n&lt;li&gt;&lt;p&gt;Система опускается в стеке вызовов в метод Method1, который вызывал Method2. Здесь вызов Method2 помещен в \r\nконструкцию try..catch&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ntry\r\n{\r\n    Method2();\r\n}\r\ncatch (IndexOutOfRangeException ex)\r\n{\r\n    Console.WriteLine($&quot;Catch в Method1 : {ex.Message}&quot;);\r\n}\r\nfinally\r\n{\r\n    Console.WriteLine(&quot;Блок finally в Method1&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Система также ищет в этой конструкции блок catch, который обрабатывает исключение DivideByZeroException. Однако \r\nздесь также подобный блок catch отсутствует.&lt;/p&gt;\r\n&lt;/li&gt;\r\n\r\n\r\n&lt;li&gt;&lt;p&gt;Система далее опускается в стеке вызовов в метод Main, который вызывал Method1. Здесь вызов Method1 помещен в \r\nконструкцию try..catch&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ntry\r\n{\r\n    TestClass.Method1();\r\n}\r\ncatch (DivideByZeroException ex)\r\n{\r\n    Console.WriteLine($&quot;Catch в Main : {ex.Message}&quot;);\r\n}\r\nfinally\r\n{\r\n    Console.WriteLine(&quot;Блок finally в Main&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Система снова ищет в этой конструкции блок catch, который обрабатывает исключение DivideByZeroException. И в \r\nданном случае такой блок найден.&lt;/p&gt;\r\n&lt;/li&gt;\r\n\r\n&lt;li&gt;&lt;p&gt;Система наконец нашла нужный блок catch в методе Main, для обработки исключения, которое возникло \r\nв методе Method2 - то есть к начальному методу, где непосредственно возникло исключение. Но пока данный блок catch НЕ выполняется. Система поднимается обратно по стеку вызовов в самый верх в метод \r\nMethod2 и выполняет в нем блок finally:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nfinally\r\n{\r\n    Console.WriteLine(&quot;Блок finally в Method2&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;/li&gt;\r\n\r\n&lt;li&gt;&lt;p&gt;Далее система возвращается по стеку вызовов вниз в метод Method1 и выполняет в нем блок finally:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nfinally\r\n{\r\n    Console.WriteLine(&quot;Блок finally в Method1&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;/li&gt;\r\n\r\n&lt;li&gt;&lt;p&gt;Затем система переходит по стеку вызовов вниз в метод Main и выполняет в нем найденный блок catch и последующий блок finally:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ncatch (DivideByZeroException ex)\r\n{\r\n    Console.WriteLine($&quot;Catch в Main : {ex.Message}&quot;);\r\n}\r\nfinally\r\n{\r\n    Console.WriteLine(&quot;Блок finally в Main&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;/li&gt;\r\n\r\n&lt;li&gt;&lt;p&gt;Далее выполняется код, который идет в методе Main после конструкции try..catch:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nConsole.WriteLine(&quot;Конец метода Main&quot;);\r\n&lt;/code&gt;\r\n&lt;p&gt;Стоит отметить, что код, который идет после конструкции try...catch в методах Method1 и Method2, не выполняется, потому что обработчик исключения найден именно в методе Main.&lt;/p&gt;\r\n&lt;/li&gt;\r\n&lt;/ol&gt;\r\n&lt;p&gt;Консольный вывод программы:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Блок finally в Method2\r\nБлок finally в Method1\r\nCatch в Main: Attempted to divide by zero\r\nБлок finally в Main\r\nКонец метода Main\r\n&lt;/pre&gt;\r\n');
INSERT INTO `lectures` (`IDLecture`, `Name`, `IDChapter`, `SerialNumber`, `IDStatus`, `Content`) VALUES
(38, 'Делегаты', 15, 1, 2, '&lt;p&gt;Делегаты представляют такие объекты, которые указывают на методы. То есть делегаты - это указатели на методы и с \r\nпомощью делегатов мы можем вызвать данные методы.&lt;/p&gt; \r\n&lt;h3&gt;Определение делегатов&lt;/h3&gt;\r\n&lt;p&gt;Для объявления делегата используется ключевое слово &lt;strong&gt;delegate&lt;/strong&gt;, после которого идет возвращаемый тип, название и параметры. Например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ndelegate void Message();\r\n&lt;/code&gt;\r\n&lt;p&gt;Делегат Message в качестве возвращаемого типа имеет тип void (то есть ничего не возвращает) и не принимает никаких параметров. \r\nЭто значит, что этот делегат может указывать на любой метод, который не принимает никаких параметров и ничего не возвращает.&lt;/p&gt;\r\n&lt;p&gt;Рассмотрим примение этого делегата:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nMessage mes;            // 2. Создаем переменную делегата\r\nmes = Hello;            // 3. Присваиваем этой переменной адрес метода\r\nmes();                  // 4. Вызываем метод\r\n \r\nvoid Hello() =&gt; Console.WriteLine(&quot;Hello METANIT.COM&quot;);\r\n \r\ndelegate void Message(); // 1. Объявляем делегат\r\n&lt;/code&gt;\r\n&lt;p&gt;Прежде всего сначала необходимо определить сам делегат:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ndelegate void Message(); // 1. Объявляем делегат\r\n&lt;/code&gt;\r\n&lt;p&gt;Для использования делегата объявляется переменная этого делегата:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nMessage mes; // 2. Создаем переменную делегата\r\n&lt;/code&gt;\r\n&lt;p&gt;Далее в делегат передается адрес определенного метода (в нашем случае метода Hello). Обратите внимание, что данный метод имеет тот же \r\nвозвращаемый тип и тот же набор параметров (в данном случае отсутствие параметров), что и делегат.&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nmes = Hello; // 3. Присваиваем этой переменной адрес метода\r\n&lt;/code&gt;\r\n&lt;p&gt;Затем через делегат вызываем метод, на который ссылается данный делегат:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nmes(); // 4. Вызываем метод\r\n&lt;/code&gt;\r\n&lt;p&gt;Вызов делегата производится подобно вызову метода.&lt;/p&gt;\r\n&lt;p&gt;При этом делегаты необязательно могут указывать только на методы, которые определены в том же классе, где определена переменная делегата. \r\nЭто могут быть также методы из других классов и структур.&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nMessage message1 = Welcome.Print;\r\nMessage message2 = new Hello().Display;\r\n \r\nmessage1(); // Welcome\r\nmessage2(); // Привет\r\n \r\ndelegate void Message();\r\n \r\nclass Welcome\r\n{\r\n    public static void Print() =&gt; Console.WriteLine(&quot;Welcome&quot;);\r\n}\r\nclass Hello\r\n{\r\n    public void Display() =&gt; Console.WriteLine(&quot;Привет&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;h3&gt;Место определения делегата&lt;/h3&gt;\r\n&lt;p&gt;Если мы определяем делегат в прогаммах верхнего уровня (top-level program), которую по умолчанию представляет файл Program.cs начиная с версии C# 10, как в примере выше,\r\nто, как и другие типы, делегат определяется в конце кода. Но в принцие делегат можно определять внутри класса:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Program\r\n{\r\n    delegate void Message(); // 1. Объявляем делегат\r\n    static void Main()\r\n    {\r\n        Message mes;            // 2. Создаем переменную делегата\r\n        mes = Hello;            // 3. Присваиваем этой переменной адрес метода\r\n        mes();                  // 4. Вызываем метод\r\n \r\n        void Hello() =&gt; Console.WriteLine(&quot;Hello METANIT.COM&quot;);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Либо вне класса:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ndelegate void Message(); // 1. Объявляем делегат\r\nclass Program\r\n{\r\n    static void Main()\r\n    {\r\n        Message mes;            // 2. Создаем переменную делегата\r\n        mes = Hello;            // 3. Присваиваем этой переменной адрес метода\r\n        mes();                  // 4. Вызываем метод\r\n \r\n        void Hello() =&gt; Console.WriteLine(&quot;Hello METANIT.COM&quot;);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;h3&gt;Параметры и результат делегата&lt;/h3&gt;\r\n&lt;p&gt;Рассмотрим определение и применение делегата, который принимает параметры и возвращает результат:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nOperation operation = Add;      // делегат указывает на метод Add\r\nint result = operation(4, 5);   // фактически Add(4, 5)\r\nConsole.WriteLine(result);      // 9\r\n     \r\noperation = Multiply;           // теперь делегат указывает на метод Multiply\r\nresult = operation(4, 5);       // фактически Multiply(4, 5)\r\nConsole.WriteLine(result);      // 20\r\n \r\nint Add(int x, int y) =&gt; x + y;\r\n \r\nint Multiply(int x, int y) =&gt; x * y;\r\n \r\ndelegate int Operation(int x, int y);\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае делегат Operation возвращает значение типа int и имеет два параметра типа int. Поэтому этому делегату \r\nсоответствует любой метод, который возвращает значение типа int и принимает два параметра типа int. В данном случае это методы Add и Multiply. \r\nТо есть мы можем присвоить переменной делегата любой из этих методов и вызывать.&lt;/p&gt;\r\n&lt;p&gt;Поскольку делегат принимает два параметра типа int, то при его вызове необходимо передать значения для этих параметров: &lt;strong&gt;operation(4,5)&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;h3&gt;Присвоение ссылки на метод&lt;/h3&gt;\r\n&lt;p&gt;Выше переменной делегата напрямую присваивался метод. Есть еще один способ - создание объекта делегата с помощью конструктора, \r\nв который передается нужный метод:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nOperation operation1 = Add;\r\nOperation operation2 = new Operation(Add);\r\n \r\nint Add(int x, int y) =&gt; x + y;\r\n \r\ndelegate int Operation(int x, int y);\r\n&lt;/code&gt;\r\n&lt;p&gt;Оба способа равноценны.&lt;/p&gt;\r\n&lt;h3&gt;Соответствие методов делегату&lt;/h3&gt;\r\n&lt;p&gt;Как было написано выше, методы соответствуют делегату, если они имеют один и тот же возвращаемый тип и один и тот же набор параметров. \r\nНо надо учитывать, что во внимание также принимаются модификаторы &lt;strong&gt;ref&lt;/strong&gt;, &lt;strong&gt;in&lt;/strong&gt; и &lt;strong&gt;out&lt;/strong&gt;. Например, пусть у нас есть делегат:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ndelegate void SomeDel(int a, double b);\r\n&lt;/code&gt;\r\n&lt;p&gt;Этому делегату соответствует, например, следующий метод:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvoid SomeMethod1(int g, double n) { }\r\n&lt;/code&gt;\r\n&lt;p&gt;А следующие методы НЕ соответствуют:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ndouble SomeMethod2(int g, double n) { return g + n; }\r\nvoid SomeMethod3(double n, int g) { }\r\nvoid SomeMethod4(ref int g, double n) { }\r\nvoid SomeMethod5(out int g, double n) { g = 6; }\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь метод SomeMethod2 имеет другой возвращаемый тип, отличный от типа делегата. SomeMethod3 имеет другой набор параметров. \r\nПараметры SomeMethod4 и SomeMethod5 также отличаются от параметров делегата, поскольку имеют модификаторы ref и out.&lt;/p&gt;\r\n&lt;h3&gt;Добавление методов в делегат&lt;/h3&gt;\r\n&lt;p&gt;В примерах выше переменная делегата указывала на один метод. В реальности же делегат может указывать на множество методов, \r\nкоторые имеют ту же сигнатуру и возвращаемые тип. Все методы в делегате попадают в специальный список - список вызова или invocation list. И при вызове делегата \r\nвсе методы из этого списка последовательно вызываются. И мы можем добавлять в этот список не один, а несколько методов. Для добавления методов в делегат применяется операция &lt;strong&gt;+=&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nMessage message = Hello;\r\nmessage += HowAreYou;  // теперь message указывает на два метода\r\nmessage();              // вызываются оба метода - Hello и HowAreYou\r\n \r\nvoid Hello() =&gt; Console.WriteLine(&quot;Hello&quot;);\r\nvoid HowAreYou() =&gt; Console.WriteLine(&quot;How are you?&quot;);\r\n \r\ndelegate void Message();\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае в список вызова делегата message добавляются два метода - Hello и HowAreYou. И при вызове message вызываются сразу оба этих метода.&lt;/p&gt;\r\n&lt;p&gt;Однако стоит отметить, что в реальности будет происходить создание нового объекта \r\nделегата, который получит методы старой копии делегата и новый метод, и новый созданный объект делегата будет присвоен переменной message.&lt;/p&gt;\r\n&lt;p&gt;При добавлении делегатов следует учитывать, что мы можем добавить ссылку на один и тот же метод несколько раз, и в списке вызова делегата тогда будет несколько ссылок на один и то же метод. \r\nСоответственно при вызове делегата добавленный метод будет вызываться столько раз, сколько он был добавлен:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nMessage message = Hello;\r\nmessage += HowAreYou;\r\nmessage += Hello;\r\nmessage += Hello;\r\n \r\nmessage();\r\n&lt;/code&gt;\r\n&lt;p&gt;Консольный вывод:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Hello\r\nHow are you?\r\nHello\r\nHello\r\n&lt;/pre&gt;\r\n\r\n&lt;p&gt;Подобным образом мы можем удалять методы из делегата с помощью операций &lt;strong&gt;-=&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nMessage? message = Hello; \r\nmessage += HowAreYou;\r\nmessage();  // вызываются все методы из message\r\nmessage -= HowAreYou;   // удаляем метод HowAreYou\r\nif (message != null) message(); // вызывается метод Hello\r\n&lt;/code&gt;\r\n&lt;p&gt;При удалении методов из делегата фактически будет создаватья новый делегат, который в списке вызова методов будет содержать на один метод меньше.&lt;/p&gt;\r\n&lt;p&gt;Стоит отметить, что при удалении метода может сложиться ситуация, что в делегате не будет методов, и тогда переменная будет иметь значение null. Поэтому в данном случае переменная определена \r\nне просто как переменная типа &lt;strong&gt;Message&lt;/strong&gt;, а именно &lt;strong&gt;Message?&lt;/strong&gt;, то есть типа, который может представлять как делегат Message, так и значение null.&lt;/p&gt;\r\n&lt;p&gt;Кроме того, перед вторым вызовом мы проверяем переменную на значение null.&lt;/p&gt;\r\n&lt;p&gt;При удалении следует учитывать, что если делегат содержит несколько ссылок на один и тот же метод, то операция -= начинает \r\nпоиск с конца списка вызова делегата и удаляет только первое найденное вхождение. Если подобного метода в списке вызова делегата нет, \r\nто операция -= не имеет никакого эффекта.&lt;/p&gt;\r\n&lt;h4&gt;Объединение делегатов&lt;/h4&gt;\r\n&lt;p&gt;Делегаты можно объединять в другие делегаты. Например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nMessage mes1 = Hello;\r\nMessage mes2 = HowAreYou;\r\nMessage mes3 = mes1 + mes2; // объединяем делегаты\r\nmes3(); // вызываются все методы из mes1 и mes2\r\n \r\nvoid Hello() =&gt; Console.WriteLine(&quot;Hello&quot;);\r\nvoid HowAreYou() =&gt; Console.WriteLine(&quot;How are you?&quot;);\r\n \r\ndelegate void Message();\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае объект mes3 представляет объединение делегатов mes1 и mes2. Объединение делегатов значит, что в список вызова \r\nделегата mes3 попадут все методы из делегатов mes1 и mes2. И при вызове делегата mes3 все эти методы одновременно будут вызваны.&lt;/p&gt;\r\n&lt;h3&gt;Вызов делегата&lt;/h3&gt;\r\n&lt;p&gt;В примерах выше делегат вызывался как обычный метод. Если делегат принимал параметры, то при его вызове для параметров передавались \r\nнеобходимые значения:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nMessage mes = Hello;\r\nmes();\r\nOperation op = Add;\r\nint n = op(3, 4);\r\nConsole.WriteLine(n);\r\n \r\nvoid Hello() =&gt; Console.WriteLine(&quot;Hello&quot;);\r\nint Add(int x, int y) =&gt; x + y;\r\n \r\ndelegate int Operation(int x, int y);\r\ndelegate void Message();\r\n&lt;/code&gt;\r\n&lt;p&gt;Другой способ вызова делегата представляет метод &lt;strong&gt;Invoke()&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nMessage mes = Hello;\r\nmes.Invoke(); // Hello\r\nOperation op = Add;\r\nint n = op.Invoke(3, 4);\r\nConsole.WriteLine(n);   // 7\r\n \r\nvoid Hello() =&gt; Console.WriteLine(&quot;Hello&quot;);\r\nint Add(int x, int y) =&gt; x + y;\r\n \r\ndelegate int Operation(int x, int y);\r\ndelegate void Message();\r\n&lt;/code&gt;\r\n&lt;p&gt;Если делегат принимает параметры, то в метод Invoke передаются значения для этих параметров.&lt;/p&gt;\r\n&lt;p&gt;Следует учитывать, что если делегат пуст, то есть в его списке вызова нет ссылок ни на один из методов (то есть делегат равен Null), то при вызове \r\nтакого делегата мы получим исключение, как, например, в следующем случае:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nMessage? mes;\r\n//mes();        // ! Ошибка: делегат равен null\r\n \r\nOperation? op = Add;\r\nop -= Add;      // делегат op пуст\r\nint n = op(3, 4);       // !Ошибка: делегат равен null\r\n&lt;/code&gt;\r\n&lt;p&gt;Поэтому при вызове делегата всегда лучше проверять, не равен ли он null. Либо можно использовать метод Invoke и оператор \r\nусловного null:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nMessage? mes = null;\r\nmes?.Invoke();        // ошибки нет, делегат просто не вызывается\r\n \r\nOperation? op = Add;\r\nop -= Add;          // делегат op пуст\r\nint? n = op?.Invoke(3, 4);   // ошибки нет, делегат просто не вызывается, а n = null\r\n&lt;/code&gt;\r\n&lt;p&gt;Если делегат возвращает некоторое значение, то возвращается значение последнего метода из списка вызова (если в списке вызова несколько методов). Например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nOperation op = Subtract;\r\nop += Multiply;\r\nop += Add;\r\nConsole.WriteLine(op(7, 2));    // Add(7,2) = 9\r\n \r\nint Add(int x, int y) =&gt; x + y;\r\nint Subtract(int x, int y) =&gt; x - y;\r\nint Multiply(int x, int y) =&gt; x * y;\r\n \r\ndelegate int Operation(int x, int y);\r\n&lt;/code&gt;\r\n&lt;h3&gt;Обобщенные делегаты&lt;/h3&gt;\r\n&lt;p&gt;Делегаты, как и другие типы, могут быть обобщенными, например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nOperation&lt;decimal, int&gt; squareOperation = Square;\r\ndecimal result1 = squareOperation(5);\r\nConsole.WriteLine(result1);  // 25\r\n \r\nOperation&lt;int, int&gt; doubleOperation = Double;\r\nint result2 = doubleOperation(5);\r\nConsole.WriteLine(result2);  // 10\r\n \r\ndecimal Square(int n) =&gt; n * n;\r\nint Double(int n) =&gt; n + n;\r\n \r\ndelegate T Operation&lt;T, K&gt;(K val);\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь делегат Operation типизируется двумя параметрами типов. Параметр T представляет тип возвращаемого значения. А параметр K представляет \r\nтип передаваемого в делегат параметра. Таким образом, этому делегату соответствует метод, который принимает параметр любого типа и возвращает значение любого типа.&lt;/p&gt;\r\n&lt;p&gt;В прогамме мы можем определить переменные делегата под определенный метод. Например, делегату &lt;strong&gt;Operation&lt;decimal, int&gt;&lt;/strong&gt; \r\nсоответствует метод, который принимает число int и возвращает число типа decimal. А делегату &lt;strong&gt;Operation&lt;int, int&gt;&lt;/strong&gt; \r\nсоответствует метод, который принимает и возвращает число типа int.&lt;/p&gt;\r\n&lt;h3&gt;Делегаты как параметры методов&lt;/h3&gt;\r\n&lt;p&gt;Также делегаты могут быть параметрами методов. Благодаря этому один метод в качестве параметров может получать действия - другие методы. Например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nDoOperation(5, 4, Add);         // 9\r\nDoOperation(5, 4, Subtract);    // 1\r\nDoOperation(5, 4, Multiply);    // 20\r\n \r\nvoid DoOperation(int a, int b, Operation op)\r\n{\r\n    Console.WriteLine(op(a,b));\r\n}\r\nint Add(int x, int y) =&gt; x + y;\r\nint Subtract(int x, int y) =&gt; x - y;\r\nint Multiply(int x, int y) =&gt; x * y;\r\n \r\ndelegate int Operation(int x, int y);\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь метод &lt;strong&gt;DoOperation&lt;/strong&gt; в качестве параметров принимает два числа и некоторое действие в виде делегата Operation. В внутри метода \r\nвызываем делегат Operation, передавая ему числа из первых двух параметров.&lt;/p&gt;\r\n&lt;p&gt;При вызове метода DoOperation мы можем передать в него в качестве третьего параметра метод, который соответствует делегату Operation.&lt;/p&gt;\r\n&lt;h3&gt;Возвращение делегатов из метода&lt;/h3&gt;\r\n&lt;p&gt;Также делегаты можно возвращать из методов. То есть мы можем возвращать из метода какое-то действие в виде другого метода. Например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nOperation operation = SelectOperation(OperationType.Add);\r\nConsole.WriteLine(operation(10, 4));    // 14\r\n \r\noperation = SelectOperation(OperationType.Subtract);\r\nConsole.WriteLine(operation(10, 4));    // 6\r\n \r\noperation = SelectOperation(OperationType.Multiply);\r\nConsole.WriteLine(operation(10, 4));    // 40\r\n \r\nOperation SelectOperation(OperationType opType)\r\n{\r\n    switch (opType)\r\n    {\r\n        case OperationType.Add: return Add;\r\n        case OperationType.Subtract: return Subtract;\r\n        default: return Multiply;\r\n    }\r\n}\r\n \r\nint Add(int x, int y) =&gt; x + y;\r\nint Subtract(int x, int y) =&gt; x - y;\r\nint Multiply(int x, int y) =&gt; x * y;\r\n \r\nenum OperationType\r\n{\r\n    Add, Subtract, Multiply\r\n}\r\ndelegate int Operation(int x, int y);\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае метод &lt;strong&gt;SelectOperation()&lt;/strong&gt; в качестве параметра принимает перечисление типа OperationType. Это перечисление хранит три константы, \r\nкаждая из которых соответствует определенной арифметической операции. И в самом методе в зависимости от значения параметра возвращаем определенный метод. \r\nПричем поскольку возвращаемый тип метода - делегат Operation, то метод должен возвратить метод, который соответствует этому делегату - в нашем случае это методы \r\nAdd, Subtract, Multiply. То есть если параметр метода SelectOperation равен &lt;strong&gt;OperationType.Add&lt;/strong&gt;, то возвращается метод Add, который выолняет сложение двух чисел:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ncase OperationType.Add: return Add;\r\n&lt;/code&gt;\r\n&lt;p&gt;При вызове метода SelectOperation мы можем получить из него нужное действие в переменную operation:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nOperation operation = SelectOperation(OperationType.Add);\r\n&lt;/code&gt;\r\n&lt;p&gt;И при вызове переменной operation фактически будет вызываться полученный из SelectOperation метод:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nOperation operation = SelectOperation(OperationType.Add);   // Здесь operation = Add\r\nConsole.WriteLine(operation(10, 4));    // 14\r\n&lt;/code&gt;'),
(39, 'Применение делегатов', 15, 2, 2, '&lt;p&gt;В прошлой теме подробно были рассмотрены делегаты. Однако данные примеры, возможно, не показывают истинной силы делегатов, так как нужные нам методы в данном случае мы можем вызвать и напрямую \r\nбез всяких делегатов. Однако наиболее сильная сторона делегатов состоит в том, что они позволяют &lt;strong&gt;делегировать&lt;/strong&gt; выполнение \r\nнекоторому коду извне. И на момент написания программы мы можем не знать, что за код будет выполняться. \r\nМы просто вызываем делегат. А какой метод будет непосредственно выполняться при вызове делегата, будет решаться потом.&lt;/p&gt;\r\n&lt;p&gt;Рассмотрим подробный пример. Пусть у нас есть класс, описывающий счет в банке:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\npublic class Account\r\n{\r\n    int sum; // Переменная для хранения суммы\r\n    // через конструктор устанавливается начальная сумма на счете\r\n    public Account(int sum) =&gt; this.sum = sum;\r\n    // добавить средства на счет\r\n    public void Add(int sum) =&gt; this.sum += sum;\r\n    // взять деньги с счета\r\n    public void Take(int sum)\r\n    {\r\n        // берем деньги, если на счете достаточно средств\r\n        if (this.sum &gt;=sum) this.sum -= sum;\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В переменной sum хранится сумма на счете. С помощью конструктора устанавливается начальная сумма на счете. Метод &lt;strong&gt;Add()&lt;/strong&gt; служит для добавления на счет, \r\nа метод &lt;strong&gt;Take&lt;/strong&gt; - для снятия денег со счета.&lt;/p&gt;\r\n&lt;p&gt;Допустим, в случае вывода денег с помощью метода &lt;strong&gt;Take&lt;/strong&gt; нам надо как-то уведомлять об этом самого владельца счета и, может \r\nбыть, другие объекты. Если речь идет о консольной программе, и класс будет применяться в том же проекте, где он создан, то мы можем написать просто:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\npublic class Account\r\n{\r\n    int sum;\r\n    public Account(int sum) =&gt; this.sum = sum;\r\n    public void Add(int sum) =&gt; this.sum += sum;\r\n    public void Take(int sum)\r\n    {\r\n        if (this.sum &gt;= sum)\r\n        {\r\n            this.sum -= sum;\r\n            Console.WriteLine($&quot;Со счета списано {sum} у.е.&quot;);\r\n        }\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Но что если наш класс планируется использовать в других проектах, например, в графическом приложении на Windows Forms или WPF, в мобильном приложении, в веб-приложении. Там строка уведомления&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nConsole.WriteLine($&quot;Со счета списано {sum} у.е.&quot;);\r\n&lt;/code&gt;\r\n&lt;p&gt;не будет иметь большого смысла.&lt;/p&gt;\r\n&lt;p&gt;Более того, наш класс Account будет использоваться другими разработчиками в виде отдельной библиотеки классов. И эти разработчики захотят уведомлять о снятии средств каким-то другим образом, о которых мы даже можем не догадываться на \r\nмомент написания класса. Поэтому примитивое уведомление в виде строки кода&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nConsole.WriteLine($&quot;Со счета списано {sum} у.е.&quot;);\r\n&lt;/code&gt;\r\n&lt;p&gt;не самое лучшее решение в данном случае. И делегаты позволяют делегировать определение действия из класса во внешний код, который будет использовать этот класс.&lt;/p&gt;\r\n&lt;p&gt;Изменим класс, применив делегаты:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\n// Объявляем делегат\r\npublic delegate void AccountHandler(string message);\r\npublic class Account\r\n{\r\n    int sum;\r\n    // Создаем переменную делегата\r\n    AccountHandler? taken;\r\n    public Account(int sum) =&gt; this.sum = sum;\r\n    // Регистрируем делегат\r\n    public void RegisterHandler(AccountHandler del)\r\n    {\r\n        taken = del;\r\n    }\r\n    public void Add(int sum) =&gt; this.sum += sum;\r\n    public void Take(int sum)\r\n    {\r\n        if (this.sum &gt;= sum)\r\n        {\r\n            this.sum -= sum;\r\n            // вызываем делегат, передавая ему сообщение\r\n            taken?.Invoke($&quot;Со счета списано {sum} у.е.&quot;);\r\n        }\r\n        else\r\n        {\r\n            taken?.Invoke($&quot;Недостаточно средств. Баланс: {this.sum} у.е.&quot;);\r\n        }\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Для делегирования действия здесь определен делегат &lt;strong&gt;AccountHandler&lt;/strong&gt;. Этот делегат соответствует любым методам, которые имеют \r\nтип &lt;strong&gt;void&lt;/strong&gt; и принимают параметр типа &lt;strong&gt;string&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\npublic delegate void AccountHandler(string message);\r\n&lt;/code&gt;\r\n&lt;p&gt;В классе Account определяем переменную &lt;strong&gt;taken&lt;/strong&gt;, которая представляет этот делегат:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nAccountHandler? taken;\r\n&lt;/code&gt;\r\n&lt;p&gt;Теперь надо связать эту переменную с конкретным действием, которое будет выполняться. Мы можем использовать разные способы для передачи делегата в \r\nкласс. В данном случае определяется специальный метод RegisterHandler, который передается в переменную taken реальное действие:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\npublic void RegisterHandler(AccountHandler del)\r\n{\r\n    taken = del;\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Таким образом, делегат установлен, и теперь его можно вызывать. Вызов делегата производится в методе Take:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\npublic void Take(int sum)\r\n{\r\n    if (this.sum &gt;= sum)\r\n    {\r\n        this.sum -= sum;\r\n        // вызываем делегат, передавая ему сообщение\r\n        taken?.Invoke($&quot;Со счета списано {sum} у.е.&quot;);\r\n    }\r\n    else\r\n    {\r\n        taken?.Invoke($&quot;Недостаточно средств. Баланс: {this.sum} у.е.&quot;);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Поскольку делегат AccountHandler в качестве параметра принимает строку, то при вызове переменной &lt;strong&gt;taken()&lt;/strong&gt; мы можем передать в этот вызов \r\nконкретное сообщение. В зависимости от того, произошло снятие денег или нет, в вызов делегата передаются разные сообщения.&lt;/p&gt;\r\n&lt;p&gt;То есть фактически вместо делегата будут выполняться действия, которые переданы делегату в методе RegisterHandler. \r\nПричем опять же подчеркну, при вызове делегата мы не значем, что это будут действия. Здесь мы только передаем в эти действия сообщение об успешно или неудачном снятии.&lt;/p&gt;\r\n&lt;p&gt;Теперь протестируем класс в основной программе:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\n// создаем банковский счет\r\nAccount account = new Account(200);\r\n// Добавляем в делегат ссылку на метод PrintSimpleMessage\r\naccount.RegisterHandler(PrintSimpleMessage);\r\n// Два раза подряд пытаемся снять деньги\r\naccount.Take(100);\r\naccount.Take(150);\r\n \r\nvoid PrintSimpleMessage(string message) =&gt; Console.WriteLine(message);\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь через метод RegisterHandler переменной taken в классе Account передается ссылка на метод &lt;strong&gt;PrintSimpleMessage&lt;/strong&gt;. Этот метод \r\nсоответствует делегату AccountHandler. Соответственно там, где вызывается делегат taken в методе Account, в реальности будет выполняться метод \r\nPrintSimpleMessage.&lt;/p&gt;\r\n&lt;p&gt;Через параметр &lt;strong&gt;message&lt;/strong&gt; метод PrintSimpleMessage получит переданное из делегата сообщение и выведет его на консоль:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Со счета списано 100 у.е.\r\nНедостаточно средств. Баланс: 100 у.е.\r\n&lt;/pre&gt;\r\n\r\n&lt;p&gt;Таким образом, мы создали механизм обратного вызова для класса Account, который срабатывает в случае снятия денег. \r\nЗдесь мы выводим сообщение на консоль. Да, мы могли бы просто выводить сообщение на консоль и без делегатов. Однако с делегатом для класса Account не важно, как это сообщение выводится. Классу Account даже не известно, что вообще будет делаться в результате списания денег. Он просто посылает уведомление об этом через делегат.&lt;/p&gt;\r\n&lt;p&gt;В результате, если мы создаем консольное приложение, мы можем через делегат выводить сообщение на консоль. Если мы создаем графическое приложение \r\nWindows Forms или WPF, то можно выводить сообщение в виде графического окна. А можно не просто выводить сообщение. А, например, записать при списании информацию об этом действии в файл \r\nили отправить уведомление на электронную почту. В общем любыми способами обработать вызов делегата. И способ обработки не будет зависеть от класса Account.&lt;/p&gt;\r\n&lt;h3&gt;Добавление и удаление методов в делегате&lt;/h3&gt;\r\n&lt;p&gt;Хотя в примере наш делегат принимал адрес на один метод, в действительности он может указывать сразу на несколько методов. \r\nКроме того, при необходимости мы можем удалить ссылки на адреса определенных методов, чтобы они не вызывались при вызове делегата. \r\nИтак, изменим в классе Account метод RegisterHandler и добавим новый метод UnregisterHandler, который будет удалять методы из списка \r\nметодов делегата:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\npublic delegate void AccountHandler(string message);\r\npublic class Account\r\n{\r\n    int sum;\r\n    AccountHandler? taken;\r\n    public Account(int sum) =&gt; this.sum = sum;\r\n    // Регистрируем делегат\r\n    public void RegisterHandler(AccountHandler del)\r\n    {\r\n        taken += del;\r\n    }\r\n    // Отмена регистрации делегата\r\n    public void UnregisterHandler(AccountHandler del)\r\n    {\r\n        taken -= del; // удаляем делегат\r\n    }\r\n    public void Add(int sum) =&gt; this.sum += sum;\r\n    public void Take(int sum)\r\n    {\r\n        if (this.sum &gt;= sum)\r\n        {\r\n            this.sum -= sum;\r\n            taken?.Invoke($&quot;Со счета списано {sum} у.е.&quot;);\r\n        }\r\n        else\r\n            taken?.Invoke($&quot;Недостаточно средств. Баланс: {this.sum} у.е.&quot;);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В первом методе объединяет делегаты &lt;strong&gt;taken&lt;/strong&gt; и &lt;strong&gt;del&lt;/strong&gt; в один, который потом \r\nприсваивается переменной &lt;strong&gt;taken&lt;/strong&gt;. Во втором методе из переменной &lt;strong&gt;taken&lt;/strong&gt; удаляется делегат &lt;strong&gt;del&lt;/strong&gt;.&lt;/p&gt; \r\n&lt;p&gt;Применим новые методы:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nAccount account = new Account(200);\r\n// Добавляем в делегат ссылку на методы\r\naccount.RegisterHandler(PrintSimpleMessage);\r\naccount.RegisterHandler(PrintColorMessage);\r\n// Два раза подряд пытаемся снять деньги\r\naccount.Take(100);\r\naccount.Take(150);\r\n \r\n// Удаляем делегат\r\naccount.UnregisterHandler(PrintColorMessage);\r\n// снова пытаемся снять деньги\r\naccount.Take(50);\r\n \r\nvoid PrintSimpleMessage(string message) =&gt; Console.WriteLine(message);\r\nvoid PrintColorMessage(string message)\r\n{\r\n    // Устанавливаем красный цвет символов\r\n    Console.ForegroundColor = ConsoleColor.Red;\r\n    Console.WriteLine(message);\r\n    // Сбрасываем настройки цвета\r\n    Console.ResetColor();\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В целях тестирования мы создали еще один метод - PrintColorMessage, который выводит то же самое сообщение только красным цветом. Ссылка на этот метод также \r\nпередается в метод RegisterHandler, и таким образом ее получит переменная taken.&lt;/p&gt;\r\n&lt;p&gt;В строке &lt;strong&gt;account.UnregisterHandler(PrintColorMessage);&lt;/strong&gt; этот метод удаляется из списка вызовов делегата, поэтому этот метод \r\nбольше не будет срабатывать. Консольный вывод будет иметь следующую форму:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Со счета списано 100 у.е.\r\n&lt;span style=&quot;color:red;&quot;&gt;Со счета списано 100 у.е.&lt;/span&gt;\r\nНедостаточно средств. Баланс: 100 у.е.\r\n&lt;span style=&quot;color:red;&quot;&gt;Недостаточно средств. Баланс: 100 у.е.&lt;/span&gt;\r\nСо счета списано 50 у.е.\r\n&lt;/pre&gt;\r\n'),
(40, 'Анонимные методы', 15, 3, 2, '&lt;p&gt;С делегатами тесно связаны &lt;strong&gt;анонимные методы&lt;/strong&gt;. Анонимные методы используются для создания экземпляров делегатов.&lt;/p&gt;\r\n&lt;p&gt;Определение анонимных методов начинается с ключевого слова &lt;strong&gt;delegate&lt;/strong&gt;, после которого идет в скобках список параметров и тело метода \r\nв фигурных скобках:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ndelegate(параметры)\r\n{\r\n    // инструкции\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nMessageHandler handler = delegate (string mes)\r\n{\r\n    Console.WriteLine(mes);\r\n};\r\nhandler(&quot;hello world!&quot;);\r\n \r\ndelegate void MessageHandler(string message);\r\n&lt;/code&gt;\r\n&lt;p&gt;Анонимный метод не может существовать сам по себе, он используется для инициализации экземпляра делегата, как в данном случае переменная \r\nhandler представляет анонимный метод. И через эту переменную делегата можно вызвать данный анонимный метод.&lt;/p&gt;\r\n&lt;p&gt;Другой пример анонимных методов - передача в качестве аргумента для параметра, который представляет делегат:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nShowMessage(&quot;hello!&quot;, delegate (string mes)\r\n{\r\n    Console.WriteLine(mes);\r\n});\r\n \r\nstatic void ShowMessage(string message, MessageHandler handler)\r\n{\r\n    handler(message);\r\n}\r\n \r\ndelegate void MessageHandler(string message);\r\n&lt;/code&gt;\r\n&lt;p&gt;Если анонимный метод использует параметры, то они должны соответствовать параметрам делегата. \r\nЕсли для анонимного метода не требуется параметров, то скобки с параметрами опускаются. При этом даже если делегат принимает несколько параметров, \r\nто в анонимном методе можно вовсе опустить параметры:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nMessageHandler handler = delegate\r\n{\r\n    Console.WriteLine(&quot;анонимный метод&quot;);\r\n};\r\nhandler(&quot;hello world!&quot;);    // анонимный метод\r\n \r\ndelegate void MessageHandler(string message);\r\n&lt;/code&gt;\r\n&lt;p&gt;То есть если анонимный метод содержит параметры, они обязательно должны соответствовать параметрам делегата. Либо анонимный метод вообще может не содержать никаких параметров, тогда он соответствует любому делегату, \r\nкоторый имеет тот же тип возвращаемого значения.&lt;/p&gt;\r\n&lt;p&gt;При этом параметры анонимного метода не могут быть опущены, если один или несколько параметров определены с модификатором &lt;strong&gt;out&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;p&gt;Также, как и обычные методы, анонимные могут возвращать результат:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nOperation operation = delegate (int x, int y)\r\n{\r\n    return x + y;\r\n};\r\nint result = operation(4, 5);\r\nConsole.WriteLine(result);       // 9\r\n \r\ndelegate int Operation(int x, int y);\r\n&lt;/code&gt;\r\n&lt;p&gt;При этом анонимный метод имеет доступ ко всем переменным, определенным во внешнем коде:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint z = 8;\r\nOperation operation = delegate (int x, int y)\r\n{\r\n    return x + y + z;\r\n};\r\nint result = operation(4, 5);\r\nConsole.WriteLine(result);       // 17\r\n \r\ndelegate int Operation(int x, int y);\r\n&lt;/code&gt;\r\n&lt;p&gt;В каких ситуациях используются анонимные методы? Когда нам надо определить однократное действие, которое не имеет много инструкций и нигде больше не используется. В частности, их можно использовать для обработки событий, которые будут рассмотрены далее.&lt;/p&gt;'),
(41, 'Лямбды', 15, 4, 2, '&lt;p&gt;Лямбда-выражения представляют упрощенную запись анонимных методов. Лямбда-выражения позволяют создать емкие лаконичные методы, которые могут \r\nвозвращать некоторое значение и которые можно передать в качестве параметров в другие методы.&lt;/p&gt;\r\n&lt;p&gt;Ламбда-выражения имеют следующий синтаксис: слева от лямбда-оператора &lt;strong&gt;=&gt;&lt;/strong&gt; определяется список параметров, а справа блок выражений, использующий эти параметры:&lt;/p&gt; \r\n&lt;code&gt;\r\n\r\n(список_параметров) =&gt; выражение\r\n&lt;/code&gt;\r\n&lt;p&gt;С точки зрения типа данных лямбда-выражение представляет делегат. Например, определим простейшее лямбда-выражение:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nMessage hello = () =&gt; Console.WriteLine(&quot;Hello&quot;);\r\nhello();       // Hello\r\nhello();       // Hello\r\nhello();       // Hello\r\n \r\ndelegate void Message();\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае переменная hello представляет делегат Message - то есть некоторое действие, которое ничего не возвращает и не принимает никаких \r\nпараметров. В качестве значения этой переменной присваивается лямбда-выражение. Это лямбда-выражение должно соответствовать делегату Message - оно то же \r\nне принимает никаких параметров, поэтому слева от лямбда-оператора \r\nидут пустые скобки. А справа от лямбда-оператора идет выполняемое выражение - &lt;strong&gt;Console.WriteLine(&quot;Hello&quot;)&lt;/strong&gt;&lt;/p&gt;\r\n&lt;p&gt;Затем в программе можно вызывать эту переменную как метод.&lt;/p&gt;\r\n\r\n&lt;p&gt;Если лямбда-выражение содержит несколько действий, то они помещаются в фигурные скобки:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nMessage hello = () =&gt;\r\n{\r\n    Console.Write(&quot;Hello &quot;);\r\n    Console.WriteLine(&quot;World&quot;);\r\n};\r\nhello();       // Hello World\r\n&lt;/code&gt;\r\n&lt;p&gt;Выше мы определили переменную hello, которая представляет делегат Message. Но начиная с версии &lt;strong&gt;C# 10&lt;/strong&gt; мы можем применять неявную типизацию \r\n (определение переменной с помощью оператора &lt;strong&gt;var&lt;/strong&gt;) при определении лямбда-выражения:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar hello = () =&gt; Console.WriteLine(&quot;Hello&quot;);\r\nhello();       // Hello\r\nhello();       // Hello\r\nhello();       // Hello\r\n&lt;/code&gt;\r\n&lt;p&gt;Но какой тип в данном случае представляет переменная hello?  При неявной типизации \r\nкомпилятор сам пытается сопоставить лямбда-выражение на основе его опеределения с каким-нибудь делегатом. \r\nНапример, выше определенное лямбда-выражение hello по умолчанию компилятор будет рассматривать как переменную встроенного делегата &lt;strong&gt;Action&lt;/strong&gt;, который не принимает \r\nникаких параметров и ничего не возвращает.&lt;/p&gt;\r\n\r\n&lt;h3&gt;Параметры лямбды&lt;/h3&gt;\r\n&lt;p&gt;При определении списка параметров мы можем не указывать для них тип данных:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nOperation sum = (x, y) =&gt; Console.WriteLine($&quot;{x} + {y} = {x + y}&quot;);\r\nsum(1, 2);       // 1 + 2 = 3\r\nsum(22, 14);    // 22 + 14 = 36\r\n \r\ndelegate void Operation(int x, int y);\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае компилятор видит, что лямбда-выражение sum представляет тип Operation, а значит оба параметра лямбды представляют тип &lt;strong&gt;int&lt;/strong&gt;. \r\nПоэтому никак проблем не возникнет.&lt;/p&gt;\r\n&lt;p&gt;Однако если мы применяем неявную типизацию, то у компилятора могут возникнуть трудности, чтобы вывести тип делегата для лямбда-выражения, например, в следующем случае&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar sum = (x, y) =&gt; Console.WriteLine($&quot;{x} + {y} = {x + y}&quot;);   // ! Ошибка\r\n&lt;/code&gt;\r\n&lt;p&gt;В этом случае можно указать тип параметров&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar sum = (int x, int y) =&gt; Console.WriteLine($&quot;{x} + {y} = {x + y}&quot;);\r\nsum(1, 2);       // 1 + 2 = 3\r\nsum(22, 14);    // 22 + 14 = 36\r\n&lt;/code&gt;\r\n&lt;p&gt;Если лямбда имеет один параметр, для которого не требуется указывать тип данных, то скобки можно опустить:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPrintHandler print = message =&gt; Console.WriteLine(message);\r\nprint(&quot;Hello&quot;);         // Hello\r\nprint(&quot;Welcome&quot;);       // Welcome\r\n \r\ndelegate void PrintHandler(string message);\r\n&lt;/code&gt;\r\n&lt;h3&gt;Возвращение результата&lt;/h3&gt;\r\n&lt;p&gt;Лямбда-выражение может возвращать результат. Возвращаемый результат можно указать после лямбда-оператора:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar sum = (int x, int y) =&gt; x + y;\r\nint sumResult = sum(4, 5);                  // 9\r\nConsole.WriteLine(sumResult);               // 9\r\n \r\nOperation multiply = (x, y) =&gt; x * y;\r\nint multiplyResult = multiply(4, 5);        // 20\r\nConsole.WriteLine(multiplyResult);          // 20\r\n \r\ndelegate int Operation(int x, int y);\r\n&lt;/code&gt;\r\n&lt;p&gt;Если лямбда-выражение содержит несколько выражение, тогда нужно использовать оператор &lt;strong&gt;return&lt;/strong&gt;, как в обычных методах:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar subtract = (int x, int y) =&gt;\r\n{\r\n    if (x &gt; y) return x - y;\r\n    else return y - x;\r\n};\r\nint result1 = subtract(10, 6);  // 4 \r\nConsole.WriteLine(result1);     // 4\r\n \r\nint result2 = subtract(-10, 6);  // 16\r\nConsole.WriteLine(result2);      // 16\r\n&lt;/code&gt;\r\n&lt;h3&gt;Добавление и удаление действий в лямбда-выражении&lt;/h3&gt;\r\n&lt;p&gt;Поскольку лямбда-выражение представляет делегат, тот как и в делегат, в переменную, которая представляет лямбда-выражение \r\nможно добавлять методы и другие лямбды:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar hello = () =&gt; Console.WriteLine(&quot;METANIT.COM&quot;);\r\n \r\nvar message = () =&gt; Console.Write(&quot;Hello &quot;);\r\nmessage += () =&gt; Console.WriteLine(&quot;World&quot;); // добавляем анонимное лямбда-выражение\r\nmessage += hello;   // добавляем лямбда-выражение из переменной hello\r\nmessage += Print;   // добавляем метод\r\n \r\nmessage();\r\nConsole.WriteLine(&quot;--------------&quot;); // для разделения вывода\r\n \r\nmessage -= Print;   // удаляем метод\r\nmessage -= hello;   // удаляем лямбда-выражение из переменной hello\r\n \r\nmessage?.Invoke();  // на случай, если в message больше нет действий\r\n \r\nvoid Print() =&gt; Console.WriteLine(&quot;Welcome to C#&quot;);\r\n&lt;/code&gt;\r\n&lt;p&gt;&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Hello World\r\nMETANIT.COM\r\nWelcome to C#\r\n--------------\r\nHello World\r\n&lt;/pre&gt;\r\n\r\n&lt;h3&gt;Лямбда-выражение как аргумент метода&lt;/h3&gt;\r\n&lt;p&gt;Как и делегаты, лямбда-выражения можно передавать параметрам метода, которые представляют делегат:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint[] integers = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\r\n \r\n// найдем сумму чисел больше 5\r\nint result1 = Sum(integers, x =&gt; x &gt; 5);\r\nConsole.WriteLine(result1); // 30\r\n \r\n// найдем сумму четных чисел\r\nint result2 = Sum(integers, x =&gt; x % 2 == 0);\r\nConsole.WriteLine(result2);  //20\r\n \r\nint Sum(int[] numbers, IsEqual func)\r\n{\r\n    int result = 0;\r\n    foreach (int i in numbers)\r\n    {\r\n        if (func(i))\r\n            result += i;\r\n    }\r\n    return result;\r\n}\r\n \r\ndelegate bool IsEqual(int x);\r\n&lt;/code&gt;\r\n&lt;p&gt;Метод Sum принимает в качестве параметра массив чисел и делегат IsEqual и возвращает сумму чисел массива в виде объекта int. \r\nВ цикле проходим по всем числам и складываем их. Причем складываем только те числа, для которых делегат &lt;strong&gt;IsEqual func&lt;/strong&gt; \r\nвозвращает true. То есть делегат IsEqual здесь фактически задает условие, которому должны соответствовать значения массива. Но на момент написания метода \r\nSum нам неизвестно, что это за условие.&lt;/p&gt;\r\n&lt;p&gt;При вызове метода Sum ему передается массив и лямбда-выражение:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint result1 = Sum(integers, x =&gt; x &gt; 5);\r\n&lt;/code&gt;\r\n&lt;p&gt;То есть параметр x здесь будет представлять число, которое передается в делегат:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nif (func(i))\r\n&lt;/code&gt;\r\n&lt;p&gt;А выражение &lt;strong&gt;x &gt; 5&lt;/strong&gt; представляет условие, которому должно соответствовать число. Если число соответствует этому условию, то \r\nлямбда-выражение возвращает true, а переданное число складывается с другими числами.&lt;/p&gt;\r\n&lt;p&gt;Подобным образом работает второй вызов метода Sum, только здесь уже идет проверка числа на четность, то есть если остаток от деления на 2 равен нулю:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint result2 = Sum(integers, x =&gt; x % 2 == 0);\r\n&lt;/code&gt;\r\n&lt;h3&gt;Лямбда-выражение как результат метода&lt;/h3&gt;\r\n&lt;p&gt;Метод также может возвращать лямбда-выражение. В этом случае возвращаемым типом метода выступает делегат, которому соответствует возвращаемое лямбда-выражение. \r\nНапример:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nOperation operation = SelectOperation(OperationType.Add);\r\nConsole.WriteLine(operation(10, 4));    // 14\r\n \r\noperation = SelectOperation(OperationType.Subtract);\r\nConsole.WriteLine(operation(10, 4));    // 6\r\n \r\noperation = SelectOperation(OperationType.Multiply);\r\nConsole.WriteLine(operation(10, 4));    // 40\r\n \r\nOperation SelectOperation(OperationType opType)\r\n{\r\n    switch (opType)\r\n    {\r\n        case OperationType.Add: return (x, y) =&gt; x + y;\r\n        case OperationType.Subtract: return (x, y) =&gt; x - y;\r\n        default: return (x, y) =&gt; x * y;\r\n    }\r\n}\r\nenum OperationType\r\n{\r\n    Add, Subtract, Multiply\r\n}\r\ndelegate int Operation(int x, int y);\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае метод SelectOperation() в качестве параметра принимает перечисление типа OperationType. Это перечисление хранит три константы, \r\nкаждая из которых соответствует определенной арифметической операции. И в самом методе в зависимости от значения параметра возвращаем \r\nопределенное лямбда-выражение.&lt;/p&gt;');
INSERT INTO `lectures` (`IDLecture`, `Name`, `IDChapter`, `SerialNumber`, `IDStatus`, `Content`) VALUES
(42, 'События', 15, 5, 2, '&lt;p&gt;&lt;strong&gt;События&lt;/strong&gt; сигнализируют системе о том, что произошло определенное \r\nдействие. И если нам надо отследить эти действия, то как раз мы можем применять события.&lt;/p&gt;\r\n&lt;p&gt;Например, возьмем следующий класс, который описывает банковский счет:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Account\r\n{\r\n    // сумма на счете\r\n    public int Sum { get; private set; }\r\n    // в конструкторе устанавливаем начальную сумму на счете\r\n    public Account(int sum) =&gt; Sum = sum;\r\n    // добавление средств на счет\r\n    public void Put(int sum) =&gt; Sum += sum;\r\n    // списание средств со счета\r\n    public void Take(int sum)\r\n    {\r\n        if (Sum &gt;= sum)\r\n        {\r\n            Sum -= sum;\r\n        }\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В конструкторе устанавливаем начальную сумму, которая хранится в свойстве Sum. С помощью метода Put мы можем добавить средства на счет, а с помощью метода Take, \r\nнаоборот, снять деньги со счета. Попробуем использовать класс в программе - создать счет, положить и снять с него деньги:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nAccount account = new Account(100);\r\naccount.Put(20);    // добавляем на счет 20\r\nConsole.WriteLine($&quot;Сумма на счете: {account.Sum}&quot;);\r\naccount.Take(70);   // пытаемся снять со счета 70\r\nConsole.WriteLine($&quot;Сумма на счете: {account.Sum}&quot;);\r\naccount.Take(180);  // пытаемся снять со счета 180\r\nConsole.WriteLine($&quot;Сумма на счете: {account.Sum}&quot;);\r\n&lt;/code&gt;\r\n&lt;p&gt;Консольный вывод:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Сумма на счете: 120\r\nСумма на счете: 50\r\nСумма на счете: 50\r\n&lt;/pre&gt;\r\n\r\n&lt;p&gt;Все операции работают как и положено. Но что если мы хотим уведомлять пользователя о результатах его операций. Мы могли бы, например, для этого изменить метод \r\nPut следующим образом:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\npublic void Put(int sum)    \r\n{\r\n    Sum += sum;\r\n    Console.WriteLine($&quot;На счет поступило: {sum}&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Казалось, теперь мы будем извещены об операции, увидев соответствующее сообщение на консоли. Но тут есть ряд замечаний. На момент определения класса \r\nмы можем точно не знать, какое действие мы хотим произвести в методе Put в ответ на добавление денег. Это может вывод на консоль, а может быть мы захотим \r\nуведомить пользователя по email или sms. Более того мы можем создать отдельную библиотеку классов, которая будет содержать этот класс, и \r\nдобавлять ее в другие проекты. И уже из этих проектов решать, какое действие должно выполняться. Возможно, мы захотим использовать класс Account в \r\nграфическом приложении и выводить при добавлении на счет в графическом сообщении, а не консоль. Или нашу библиотеку классов будет использовать другой разработчик, у которого \r\nсвое мнение, что именно делать при добавлении на счет. И все эти вопросы мы можем решить, используя события.&lt;/p&gt;\r\n&lt;h3&gt;Определение и вызов событий&lt;/h3&gt;\r\n&lt;p&gt;События объявляются в классе с помощью ключевого слова &lt;strong&gt;event&lt;/strong&gt;, после которого указывается тип делегата, который представляет событие:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ndelegate void AccountHandler(string message);\r\nevent AccountHandler Notify;\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае вначале определяется делегат AccountHandler, который принимает один параметр типа string. Затем с помощью ключевого слова &lt;strong&gt;event&lt;/strong&gt; \r\nопределяется событие с именем Notify, которое представляет делегат AccountHandler. Название для события может быть произвольным, но в любом случае оно должно представлять некоторый делегат.&lt;/p&gt;\r\n&lt;p&gt;Определив событие, мы можем его вызвать в программе как метод, используя имя события:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nNotify(&quot;Произошло действие&quot;);\r\n&lt;/code&gt;\r\n&lt;p&gt;Поскольку событие Notify представляет делегат AccountHandler, который принимает один параметр типа string - строку, то при вызове события нам надо передать в \r\nнего строку.&lt;/p&gt;\r\n&lt;p&gt;Однако при вызове событий мы можем столкнуться с тем, что событие равно null в случае, если для его не определен обработчик. Поэтому при вызове события лучше его всегда \r\nпроверять на null. Например, так:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nif(Notify !=null) Notify(&quot;Произошло действие&quot;);\r\n&lt;/code&gt;\r\n&lt;p&gt;Или так:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nNotify?.Invoke(&quot;Произошло действие&quot;);\r\n&lt;/code&gt;\r\n&lt;p&gt;В этом случае поскольку событие представляет делегат, то мы можем его вызвать с помощью метода &lt;strong&gt;Invoke()&lt;/strong&gt;, передав в него необходимые значения \r\nдля параметров.&lt;/p&gt;\r\n&lt;p&gt;Объединим все вместе и создадим и вызовем событие:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Account\r\n{\r\n    public delegate void AccountHandler(string message);\r\n    public event AccountHandler? Notify;              // 1.Определение события\r\n    public Account(int sum) =&gt; Sum = sum;\r\n    public int Sum { get; private set; }\r\n    public void Put(int sum)\r\n    {\r\n        Sum += sum;\r\n        Notify?.Invoke($&quot;На счет поступило: {sum}&quot;);   // 2.Вызов события \r\n    }\r\n    public void Take(int sum)\r\n    {\r\n        if (Sum &gt;= sum)\r\n        {\r\n            Sum -= sum;\r\n            Notify?.Invoke($&quot;Со счета снято: {sum}&quot;);   // 2.Вызов события\r\n        }\r\n        else\r\n        {\r\n            Notify?.Invoke($&quot;Недостаточно денег на счете. Текущий баланс: {Sum}&quot;); ;\r\n        }\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Теперь с помощью события Notify мы уведомляем систему о том, что были добавлены средства и о том, что средства сняты со счета или на счете недостаточно средств.&lt;/p&gt;\r\n&lt;h3&gt;Добавление обработчика события&lt;/h3&gt;\r\n&lt;p&gt;С событием может быть связан один или несколько обработчиков. Обработчики событий - это именно то, что выполняется при вызове событий. Нередко в качестве обработчиков событий применяются \r\nметоды. Каждый обработчик событий по списку параметров и возвращаемому типу должен соответствовать делегату, который представляет событие. Для добавления обработчика \r\nсобытия применяется операция &lt;strong&gt;+=&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nNotify += обработчик события;\r\n&lt;/code&gt;\r\n&lt;p&gt;Определим обработчики для события Notify, чтобы получить в программе нужные уведомления:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nAccount account = new Account(100);\r\naccount.Notify += DisplayMessage;   // Добавляем обработчик для события Notify\r\naccount.Put(20);    // добавляем на счет 20\r\nConsole.WriteLine($&quot;Сумма на счете: {account.Sum}&quot;);\r\naccount.Take(70);   // пытаемся снять со счета 70\r\nConsole.WriteLine($&quot;Сумма на счете: {account.Sum}&quot;);\r\naccount.Take(180);  // пытаемся снять со счета 180\r\nConsole.WriteLine($&quot;Сумма на счете: {account.Sum}&quot;);\r\n \r\nvoid DisplayMessage(string message) =&gt; Console.WriteLine(message);\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае в качестве обработчика используется метод DisplayMessage, который соответствует по списку параметров и возвращаемому типу делегату AccountHandler. \r\nВ итоге при вызове события &lt;strong&gt;Notify?.Invoke()&lt;/strong&gt; будет вызываться метод DisplayMessage, которому для параметра message будет передаваться строка, которая передается \r\nв &lt;strong&gt;Notify?.Invoke()&lt;/strong&gt;. В DisplayMessage просто выводим полученное от события сообщение, но можно было бы определить любую логику.&lt;/p&gt;\r\n&lt;p&gt;Если бы в данном случае обработчик не был бы установлен, то при вызове события &lt;strong&gt;Notify?.Invoke()&lt;/strong&gt; ничего не происходило, так как событие Notify было бы равно null.&lt;/p&gt;\r\n&lt;p&gt;Консольный вывод программы:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;На счет поступило: 20\r\nСумма на счете: 120\r\nСо счета снято: 70\r\nСумма на счете: 50\r\nНедостаточно денег на счете. Текущий баланс: 50\r\nСумма на счете: 50\r\n&lt;/pre&gt;\r\n\r\n&lt;p&gt;Теперь мы можем выделить класс Account в отдельную библиотеку классов и добавлять в любой проект.&lt;/p&gt;\r\n&lt;h3&gt;Добавление и удаление обработчиков&lt;/h3&gt;\r\n&lt;p&gt;Для одного события можно установить несколько обработчиков и потом в любой момент времени их удалить. Для удаления обработчиков применяется операция \r\n&lt;strong&gt;-=&lt;/strong&gt;. Например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nAccount account = new Account(100);\r\naccount.Notify += DisplayMessage;       // добавляем обработчик DisplayMessage\r\naccount.Notify += DisplayRedMessage;    // добавляем обработчик DisplayMessage\r\naccount.Put(20);    // добавляем на счет 20\r\naccount.Notify -= DisplayRedMessage;     // удаляем обработчик DisplayRedMessage\r\naccount.Put(50);    // добавляем на счет 50\r\n \r\nvoid DisplayMessage(string message) =&gt; Console.WriteLine(message);\r\nvoid DisplayRedMessage(string message)\r\n{\r\n    // Устанавливаем красный цвет символов\r\n    Console.ForegroundColor = ConsoleColor.Red;\r\n    Console.WriteLine(message);\r\n    // Сбрасываем настройки цвета\r\n    Console.ResetColor();\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Консольный вывод:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;На счет поступило: 20\r\n&lt;span style=&quot;color:red;&quot;&gt;На счет поступило: 20&lt;/span&gt;\r\nНа счет поступило: 50\r\n&lt;/pre&gt;\r\n\r\n&lt;p&gt;В качестве обработчиков могут использоваться не только обычные методы, но также делегаты, анонимные методы и лямбда-выражения. \r\nИспользование делегатов и методов:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nAccount acc = new Account(100);\r\n// установка делегата, который указывает на метод DisplayMessage\r\nacc.Notify += new Account.AccountHandler(DisplayMessage);\r\n// установка в качестве обработчика метода DisplayMessage\r\nacc.Notify += DisplayMessage;       // добавляем обработчик DisplayMessage\r\n \r\nacc.Put(20);    // добавляем на счет 20\r\n \r\nvoid DisplayMessage(string message) =&gt; Console.WriteLine(message);\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае разницы между двумя обработчиками никакой не будет.&lt;/p&gt;\r\n&lt;p&gt;Установка в качестве обработчика анонимного метода:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nAccount acc = new Account(100);\r\nacc.Notify += delegate (string mes)\r\n{\r\n    Console.WriteLine(mes);\r\n};\r\nacc.Put(20);\r\n&lt;/code&gt;\r\n&lt;p&gt;Установка в качестве обработчика лямбда-выражения:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nAccount account = new Account(100);\r\naccount.Notify += message =&gt; Console.WriteLine(message);\r\naccount.Put(20);\r\n&lt;/code&gt;\r\n&lt;h3&gt;Управление обработчиками&lt;/h3&gt;\r\n&lt;p&gt;С помощью специальных акссесоров &lt;strong&gt;add/remove&lt;/strong&gt; мы можем управлять добавлением и удалением обработчиков. Как правило, подобная функциональность \r\nредко требуется, но тем не менее мы ее можем использовать. Например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Account\r\n{\r\n    public delegate void AccountHandler(string message);\r\n    AccountHandler? notify;\r\n    public event AccountHandler Notify\r\n    {\r\n        add\r\n        {\r\n            notify += value;\r\n            Console.WriteLine($&quot;{value.Method.Name} добавлен&quot;);\r\n        }\r\n        remove\r\n        {\r\n            notify -= value;\r\n            Console.WriteLine($&quot;{value.Method.Name} удален&quot;);\r\n        }\r\n    }\r\n    public Account(int sum) =&gt; Sum = sum;\r\n    public int Sum { get; private set; }\r\n    public void Put(int sum)\r\n    {\r\n        Sum += sum;\r\n        notify?.Invoke($&quot;На счет поступило: {sum}&quot;);   // 2.Вызов события \r\n    }\r\n    public void Take(int sum)\r\n    {\r\n        if (Sum &gt;= sum)\r\n        {\r\n            Sum -= sum;\r\n            notify?.Invoke($&quot;Со счета снято: {sum}&quot;);   // 2.Вызов события\r\n        }\r\n        else\r\n        {\r\n            notify?.Invoke($&quot;Недостаточно денег на счете. Текущий баланс: {Sum}&quot;); ;\r\n        }\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Теперь опредление события разбивается на две части. Вначале просто определяется переменная делегата, через которую мы можем вызывать связанные обработчики:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nAccountHandler notify;\r\n&lt;/code&gt;\r\n&lt;p&gt;Во второй части определяем акссесоры add и remove. Аксессор &lt;strong&gt;add&lt;/strong&gt; вызывается при добавлении обработчика, то есть при операции +=. \r\nДобавляемый обработчик доступен через ключевое слово &lt;strong&gt;value&lt;/strong&gt;. Здесь мы можем получить информацию об обработчике (например, \r\nимя метода через value.Method.Name) и определить некоторую логику. В данном случае для простоты просто выводится сообщение на консоль:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nadd\r\n{\r\n    notify += value;\r\n    Console.WriteLine($&quot;{value.Method.Name} добавлен&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Блок remove вызывается при удалении обработчика. Аналогично здесь можно задать некоторую дополнительную логику:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nremove\r\n{\r\n    notify -= value;\r\n    Console.WriteLine($&quot;{value.Method.Name} удален&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Внутри класса событие вызывается также через переменную notify. Но для добавления и удаления обработчиков в программе используется как раз Notify:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nAccount acc = new Account(100);\r\nacc.Notify += DisplayMessage;       // добавляем обработчик DisplayMessage\r\nacc.Put(20);    // добавляем на счет 20\r\nacc.Notify -= DisplayMessage;     // удаляем обработчик DisplayRedMessage\r\nacc.Put(20);    // добавляем на счет 20\r\n \r\nvoid DisplayMessage(string message) =&gt; Console.WriteLine(message);\r\n&lt;/code&gt;\r\n&lt;p&gt;Консольный вывод программы:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;DisplayMessage добавлен\r\nНа счет поступило: 20\r\nDisplayMessage удален\r\n&lt;/pre&gt;\r\n\r\n&lt;h3&gt;Передача данных события&lt;/h3&gt;\r\n&lt;p&gt;Нередко при возникновении события обработчику события требуется передать некоторую информацию о событии. Например, добавим и в нашу программу \r\nновый класс &lt;strong&gt;AccountEventArgs&lt;/strong&gt; со следующим кодом:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass AccountEventArgs\r\n{\r\n    // Сообщение\r\n    public string Message{get;}\r\n    // Сумма, на которую изменился счет\r\n    public int Sum {get;}\r\n    public AccountEventArgs(string message, int sum)\r\n    {\r\n        Message = message;\r\n        Sum = sum;\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Данный класс имеет два свойства: Message - для хранения выводимого сообщения и Sum - для хранения суммы, на которую изменился счет.&lt;/p&gt;\r\n&lt;p&gt;Теперь применим класс AccoutEventArgs, изменив класс Account следующим образом:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Account\r\n{\r\n    public delegate void AccountHandler(Account sender, AccountEventArgs e);\r\n    public event AccountHandler? Notify;\r\n     \r\n    public int Sum { get; private set; }\r\n     \r\n    public Account(int sum) =&gt; Sum = sum;\r\n     \r\n    public void Put(int sum)\r\n    {\r\n        Sum += sum;\r\n        Notify?.Invoke(this, new AccountEventArgs($&quot;На счет поступило {sum}&quot;, sum));\r\n    }\r\n    public void Take(int sum)\r\n    {\r\n        if (Sum &gt;= sum)\r\n        {\r\n            Sum -= sum;\r\n            Notify?.Invoke(this, new AccountEventArgs($&quot;Сумма {sum} снята со счета&quot;, sum));\r\n        }\r\n        else\r\n        {\r\n            Notify?.Invoke(this, new AccountEventArgs(&quot;Недостаточно денег на счете&quot;, sum));\r\n        }\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;По сравнению с предыдущей версией класса Account здесь изменилось только количество параметров у делегата и соответственно количество параметров \r\nпри вызове события. Теперь делегат AccountHandler в качестве первого параметра принимает объект, который вызвал событие, то есть текущий объект Account. \r\nА в качестве второго параметра принимает объект AccountEventArgs, который хранит информацию о событии, получаемую через конструктор.&lt;/p&gt;\r\n&lt;p&gt;Теперь изменим основную программу:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nAccount acc = new Account(100);\r\nacc.Notify += DisplayMessage;\r\nacc.Put(20);\r\nacc.Take(70);\r\nacc.Take(150);\r\n \r\nvoid DisplayMessage(Account sender, AccountEventArgs e)\r\n{\r\n    Console.WriteLine($&quot;Сумма транзакции: {e.Sum}&quot;);\r\n    Console.WriteLine(e.Message);\r\n    Console.WriteLine($&quot;Текущая сумма на счете: {sender.Sum}&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;По сравнению с предыдущим вариантом здесь мы только изменяем количество параметров и их использования в обработчике DisplayMessage. Благодаря первому параметру в методе \r\nможно получить информацию об отправителе события - счете, с которым производится операция. А через второй параметр можно получить инфомацию о состоянии операции.&lt;/p&gt;'),
(43, 'Определение интерфейсов', 16, 1, 2, '&lt;p&gt;Интерфейс представляет ссылочный тип, который может определять некоторый функционал - набор методов и свойств без реализации. \r\nЗатем этот функционал реализуют классы и структуры, которые применяют данные интерфейсы.&lt;/p&gt;\r\n&lt;h3&gt;Определение интерфейса&lt;/h3&gt;\r\n&lt;p&gt;Для определения интерфейса используется ключевое слово &lt;strong&gt;interface&lt;/strong&gt;. Как правило, названия интерфейсов в C# начинаются с заглавной буквы \r\n&lt;strong&gt;I&lt;/strong&gt;, например, IComparable, IEnumerable (так называемая венгерская нотация), однако это не обязательное требование, а больше стиль программирования.&lt;/p&gt;\r\n&lt;p&gt;Что может определять интерфейс? В целом интерфейсы могут определять следующие сущности:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;Методы&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Свойства&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Индексаторы&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;События&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Статические поля и константы (начиная с версии C# 8.0)&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Однако интерфейсы не могут определять нестатические переменные. Например, простейший интерфейс, который определяет все эти компоненты:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ninterface IMovable\r\n{\r\n    // константа\r\n    const int minSpeed = 0;     // минимальная скорость\r\n    // статическая переменная\r\n    static int maxSpeed = 60;   // максимальная скорость\r\n    // метод\r\n    void Move();                // движение\r\n    // свойство\r\n    string Name { get; set; }   // название\r\n     \r\n    delegate void MoveHandler(string message);  // определение делегата для события\r\n    // событие\r\n    event MoveHandler MoveEvent;    // событие движения\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае определен интерфейс IMovable, который представляет некоторый движущийся объект. Данный интерфейс содержит различные компоненты, \r\nкоторые описывают возможности движущегося объекта. То есть интерфейс описывает некоторый функционал, который должен быть у движущегося объекта.&lt;/p&gt;\r\n&lt;p&gt;Методы и свойства интерфейса могут не иметь реализации, в этом они сближаются с абстрактными методами и свойствами абстрактных классов. \r\nВ данном случае интерфейс определяет метод Move, который будет представлять некоторое передвижение. Он не имеет реализации, не принимает никаких параметров и ничего не возвращает.&lt;/p&gt;\r\n&lt;p&gt;То же самое в данном случае касается свойства Name. На первый взгляд оно похоже на автоматическое свойство. Но в реальности это определение свойства в интерфейсе, которое не имеет реализации, а не автосвойство.&lt;/p&gt;\r\n&lt;h3&gt;Модификаторы доступа&lt;/h3&gt;\r\n&lt;p&gt;Еще один момент в объявлении интерфейса: если его члены - методы и свойства не имеют модификаторов доступа, то фактически по умолчанию доступ \r\n&lt;strong&gt;public&lt;/strong&gt;, так как цель интерфейса - определение функционала для реализации его классом. Это касается также и констант и \r\nстатических переменных, которые в классах и структурах по умолчанию имееют модификатор private. В интерфейсах же они имеют по умолчанию модификатор \r\npublic. И например, мы могли бы обратиться к константе minSpeed и переменной maxSpeed интерфейса IMovable:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nConsole.WriteLine(IMovable.maxSpeed);   // 60\r\nConsole.WriteLine(IMovable.minSpeed);   // 0\r\n&lt;/code&gt;\r\n&lt;p&gt;Но также, начиная с версии C# 8.0, мы можем явно указывать модификаторы доступа у компонентов интерфейса:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ninterface IMovable\r\n{\r\n    public const int minSpeed = 0;     // минимальная скорость\r\n    private static int maxSpeed = 60;   // максимальная скорость\r\n    public void Move();\r\n    protected internal string Name { get; set; }    // название\r\n    public delegate void MoveHandler(string message);  // определение делегата для события\r\n    public event MoveHandler MoveEvent;    // событие движения\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Как и классы, интерфейсы по умолчанию имеют уровень доступа &lt;strong&gt;internal&lt;/strong&gt;, то есть такой интерфейс доступен только \r\nв рамках текущего проекта. Но с помощью модификатора public мы можем сделать интерфейс общедоступным:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\npublic interface IMovable\r\n{\r\n    void Move();\r\n}\r\n&lt;/code&gt;\r\n&lt;h3&gt;Реализация по умолчанию&lt;/h3&gt;\r\n&lt;p&gt;Также начиная с версии C# 8.0 интерфейсы поддерживают реализацию методов и свойств по умолчанию. Это значит, что мы можем определить в интерфейсах полноценные методы и свойства, которые \r\nимеют реализацию как в обычных классах и структурах. Например, определим реализацию метода Move по умолчанию:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ninterface IMovable\r\n{\r\n    // реализация метода по умолчанию\r\n    void Move()\r\n    {\r\n        Console.WriteLine(&quot;Walking&quot;);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;С реализацией свойств по умолчанию в интерфейсах дело обстоит несколько сложнее, поскольку мы не можем определять в интерфейсах нестатические \r\nпеременные, соответственно в свойствах интерфейса мы не можем манипулировать состоянием объекта. Тем не менее реализацию по умолчанию для свойств мы тоже можем определять:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ninterface IMovable\r\n{\r\n    // реализация метода по умолчанию\r\n    void Move() =&gt; Console.WriteLine(&quot;Walking&quot;);\r\n    // реализация свойства по умолчанию\r\n    // свойство только для чтения\r\n    int MaxSpeed { get { return 0; } }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Стоит отметить, что если интерфейс имеет приватные методы и свойства (то есть с модификатором private), то они должны иметь реализацию по умолчанию. \r\nТо же самое относится к любым статическим методам и свойствам (не обязательно приватным):&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nConsole.WriteLine(IMovable.MaxSpeed);   // 60\r\nIMovable.MaxSpeed = 65;\r\nConsole.WriteLine(IMovable.MaxSpeed);   // 65\r\ndouble time = IMovable.GetTime(500, 10);\r\nConsole.WriteLine(time);    // 50\r\n \r\ninterface IMovable\r\n{\r\n    public const int minSpeed = 0;     // минимальная скорость\r\n    private static int maxSpeed = 60;   // максимальная скорость\r\n    // находим время, за которое надо пройти расстояние distance со скоростью speed\r\n    static double GetTime(double distance, double speed) =&gt; distance / speed;\r\n    static int MaxSpeed\r\n    {\r\n        get =&gt; maxSpeed;\r\n        set\r\n        {\r\n            if (value &gt; 0) maxSpeed = value;\r\n        }\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;h3&gt;Добавление интерфейса&lt;/h3&gt;\r\n&lt;p&gt;Стоит отметить, что в Visual Studio есть специальный компонент для добавления нового интерфейса в отдельном файле. \r\nДля добавления интерфейса в проект можно нажать правой кнопкой мыши на проект и в появившемся контекстном меню выбрать &lt;strong&gt;Add&lt;/strong&gt;-&gt;&lt;strong&gt;\r\nNew Item...&lt;/strong&gt; и в диалоговом окне добавления нового компонента выбрать пункт &lt;strong&gt;Interface&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/3.2.png&quot; alt=&quot;Интерфейсы в C#&quot;&gt;\r\n&lt;p&gt;Хотя мы также может добавить стандартный файл класса или любой другой файл кода C# и в нем определить интерфейс.&lt;/p&gt;'),
(44, 'Применение интерфейсов', 16, 2, 2, '&lt;p&gt;Интерфейс представляет некое описание типа, набор компонентов, который должен иметь тип данных. И, собственно, мы не можем создавать объекты интерфейса напрямую с \r\nпомощью конструктора, как например, в классах:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nIMovable m = new IMovable(); // ! Ошибка, так сделать нельзя\r\n \r\ninterface IMovable\r\n{\r\n    void Move();\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В конечном счете интерфейс предназначен для реализации в классах и структурах. Например, реализуем выше определенный интерфейс IMovable:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\n// применение интерфейса в классе\r\nclass Person : IMovable\r\n{\r\n    public void Move()\r\n    {\r\n        Console.WriteLine(&quot;Человек идет&quot;);\r\n    }\r\n}\r\n// применение интерфейса в структуре\r\nstruct Car : IMovable\r\n{\r\n    public void Move()\r\n    {\r\n        Console.WriteLine(&quot;Машина едет&quot;);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;При применении интерфейса, как и при наследовании после имени класса или структуры указывается двоеточие и затем идут названия применяемых интерфейсов. \r\nПри этом класс должен реализовать все методы и свойства применяемых интерфейсов, если эти методы и свойства не имеют реализации по умолчанию.&lt;/p&gt; \r\n&lt;p&gt;Если методы и свойства интерфейса не имеют модификатора доступа, то по умолчанию они являются публичными, при реализации этих методов и свойств в \r\nклассе и структуре к ним можно применять только модификатор &lt;strong&gt;public&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;p&gt;Применение интерфейса в программе:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson person = new Person();\r\nCar car = new Car();\r\nDoAction(person);\r\nDoAction(car);\r\n \r\nvoid DoAction(IMovable movable) =&gt; movable.Move();\r\n \r\ninterface IMovable\r\n{\r\n    void Move();\r\n}\r\nclass Person : IMovable\r\n{\r\n    public void Move() =&gt; Console.WriteLine(&quot;Человек идет&quot;);\r\n}\r\nstruct Car : IMovable\r\n{\r\n    public void Move() =&gt; Console.WriteLine(&quot;Машина едет&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В данной программе определен метод &lt;strong&gt;DoAction()&lt;/strong&gt;, который в качестве параметра принимает объект интерфейса \r\nIMovable. На момент написания кода мы можем не знать, что это будет за объект - какой-то класс или структура. Единственное, \r\nв чем мы можем быть уверены, что этот объект обязательно реализует метод Move и мы можем вызвать этот метод.&lt;/p&gt;\r\n&lt;p&gt;Иными словами, интерфейс - это контракт, что какой-то определенный тип обязательно реализует некоторый функционал.&lt;/p&gt;\r\n&lt;p&gt;Консольный вывод данной программы:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Человек идет\r\nМашина едет\r\n&lt;/pre&gt;\r\n\r\n&lt;h3&gt;Реализация интерфейсов по умолчанию&lt;/h3&gt;\r\n&lt;p&gt;Начиная с версии C# 8.0 интерфейсы поддерживают реализацию методов и свойств по умолчанию. Зачем это нужно? Допустим, у нас есть куча классов, которые реализуют некоторый интерфейс. Если мы добавим в этот интерфейс новый метод, \r\nто мы будем обязаны реализовать этот метод во всех классах, применяющих данный интерфейс. Иначе подобные классы просто не будут компилироваться. Теперь вместо реализации метода во \r\nвсех классах нам достаточно определить его реализацию по умолчанию в интерфейсе. Если класс не реализует метод, будет применяться реализация по умолчанию.&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nIMovable tom = new Person();\r\nCar tesla = new Car();\r\ntom.Move();     // Walking\r\ntesla.Move();   // Driving\r\ninterface IMovable\r\n{\r\n    void Move() =&gt; Console.WriteLine(&quot;Walking&quot;);\r\n}\r\nclass Person : IMovable { }\r\nclass Car : IMovable\r\n{\r\n    public void Move() =&gt; Console.WriteLine(&quot;Driving&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае интерфейс &lt;strong&gt;IMovable&lt;/strong&gt; определяет реализацию по умолчанию для метода &lt;strong&gt;Move&lt;/strong&gt;. Класс Person не реализует этот метод, поэтому он применяет \r\nреализацию по умолчанию в отличие от класса &lt;strong&gt;Car&lt;/strong&gt;, который определяет свою реализацию для метода Move.&lt;/p&gt;\r\n&lt;p&gt;Стоит отметить, что хотя для объекта класса &lt;strong&gt;Person&lt;/strong&gt; мы можем вызвать метод &lt;strong&gt;Move&lt;/strong&gt; - ведь класс &lt;strong&gt;Person&lt;/strong&gt; применяет интерфейс &lt;strong&gt;IMovable&lt;/strong&gt;, тем не менее мы не можем написать так:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson tom = new Person();\r\ntom.Move();     // Ошибка - метод Move не определен в классе Person\r\n&lt;/code&gt;\r\n&lt;h3&gt;Множественная реализация интерфейсов&lt;/h3&gt;\r\n&lt;p&gt;Интерфейсы имеют еще одну важную функцию: в C# не поддерживается множественное наследование, то есть мы можем унаследовать класс \r\nтолько от одного класса, в отличие, скажем, от языка С++, где множественное наследование можно использовать. Интерфейсы \r\nпозволяют частично обойти это ограничение, поскольку в C# классы и структуры могут реализовать сразу несколько интерфейсов. Все реализуемые интерфейсы \r\nуказываются через запятую:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass myClass: myInterface1, myInterface2, myInterface3, ...\r\n{\r\n     \r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Рассмотрим на примере:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nMessage hello = new Message(&quot;Hello World&quot;);\r\nhello.Print();  // Hello World\r\n \r\ninterface IMessage\r\n{\r\n    string Text { get; set; }\r\n}\r\ninterface IPrintable\r\n{\r\n    void Print();\r\n}\r\nclass Message : IMessage, IPrintable\r\n{\r\n    public string Text { get; set; }\r\n    public Message(string text) =&gt; Text = text;\r\n    public void Print()=&gt; Console.WriteLine(Text);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае определены два интерфейса. Интерфейс IMessage определяет свойство Text, которое представляет текст сообщения. А интерфейс IPrintable \r\nопределяет метод Print.&lt;/p&gt;\r\n&lt;p&gt;Класс Message реализует оба интерфейса и затем применяется в программе.&lt;/p&gt;\r\n&lt;h3&gt;Интерфейсы в преобразованиях типов&lt;/h3&gt;\r\n&lt;p&gt;Все сказанное в отношении преобразования типов характерно и для интерфейсов. Поскольку класс Message реализует интерфейс IMessage, \r\nто переменная типа IMessage может хранить ссылку на объект типа Message:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\n// Все объекты Message являются объектами IMessage\r\nIMessage hello = new Message(&quot;Hello METANIT.COM&quot;);\r\nConsole.WriteLine(hello.Text); // Hello METANIT.COM\r\n \r\n// Не все объекты IMessage являются объектами Message, необходимо явное приведение\r\n// Message someMessage = hello; // ! Ошибка\r\n \r\n// Интерфейс IMessage не имеет свойства Print, необходимо явное приведение\r\n// hello.Print();  // ! Ошибка\r\n \r\n// если hello представляет класс Message, выполняем преобразование\r\nif (hello is Message someMessage) someMessage.Print();\r\n&lt;/code&gt;\r\n&lt;p&gt;Преобразование от класса к его интерфейсу, как и преобразование от производного типа к базовому, выполняется автоматически. Так как любой объект Message \r\nреализует интерфейс IMessage.&lt;/p&gt;\r\n&lt;p&gt;Обратное преобразование - от интерфейса к реализующему его классу будет аналогично преобразованию от базового класса к производному. \r\nТак как не каждый объект IMessage является объектом Message (ведь интерфейс IMessage могут реализовать и другие классы), \r\nто для подобного преобразования необходима операция приведения типов. И если мы хотим обратиться к методам класса Message, которые не определены в интерфейсе IMessage, но являются частью класса Message, \r\nто нам надо явным образом выполнить преобразование типов:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nif (hello is Message someMessage) someMessage.Print();\r\n&lt;/code&gt;'),
(45, 'Явная реализация интерфейсов', 16, 3, 2, '&lt;p&gt;Кроме неявного применения интерфейсов, которое было рассмотрено в прошлой статье, сушествует также явная реализация интерфейса. При явной реализации \r\nуказывается название метода или свойства вместе с названием интерфейса, при этом мы не можем использовать модификатор public, то есть \r\nметоды являются закрытыми:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ninterface IAction\r\n{\r\n    void Move();\r\n}\r\nclass BaseAction : IAction\r\n{\r\n    void IAction.Move() =&gt; Console.WriteLine(&quot;Move in Base Class&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Следует учитывать, что при явной реализации интерфейса его методы и свойства &lt;strong&gt;не являются&lt;/strong&gt; частью интерфейса класса. \r\nПоэтому напрямую через объект класса мы к ним обратиться не сможем:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nBaseAction baseAction1 = new BaseAction();\r\n \r\n// baseAction1.Move();  // ! Ошибка - в BaseAction нет метода Move\r\n// необходимо приведение к типу IAction\r\n// небезопасное приведение\r\n((IAction)baseAction1).Move();   \r\n// безопасное приведение \r\nif (baseAction1 is IAction action) action.Move();\r\n// или так\r\nIAction baseAction2 = new BaseAction();\r\nbaseAction2.Move();\r\n&lt;/code&gt;\r\n&lt;p&gt;В какой ситуации может действительно понадобиться явная реализация интерфейса? Например, когда класс применяет несколько интерфейсов, но \r\nони имеют один и тот же метод с одним и тем же возвращаемым результатом и одним и тем же набором параметров:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Person : ISchool, IUniversity\r\n{\r\n    public void Study() =&gt; Console.WriteLine(&quot;Учеба в школе или в университете&quot;);\r\n}\r\ninterface ISchool\r\n{\r\n    void Study();\r\n}\r\ninterface IUniversity\r\n{\r\n    void Study();\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Класс Person определяет один метод &lt;strong&gt;Study()&lt;/strong&gt;, создавая одну общую реализацию для обоих примененных интерфейсов. И вне зависимости от того, \r\nбудем ли мы рассматривать объект Person как объект типа ISchool или IUniversity, результат метода будет один и тот же.&lt;/p&gt;\r\n&lt;p&gt;Чтобы разграничить реализуемые интерфейсы, надо явным образом применить интерфейс:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Person : ISchool, IUniversity\r\n{\r\n    void ISchool.Study() =&gt; Console.WriteLine(&quot;Учеба в школе&quot;);\r\n    void IUniversity.Study() =&gt; Console.WriteLine(&quot;Учеба в университете&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Использование:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson person = new Person();\r\n \r\n((ISchool)person).Study();\r\n((IUniversity)person).Study();\r\n&lt;/code&gt;\r\n&lt;p&gt;Другая ситуация, когда в базовом классе уже реализован интерфейс, но необходимо в производном классе по-своему реализовать интерфейс:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ninterface IAction\r\n{\r\n    void Move();\r\n}\r\nclass BaseAction : IAction\r\n{\r\n    public void Move() =&gt;Console.WriteLine(&quot;Move in BaseAction&quot;);\r\n}\r\nclass HeroAction : BaseAction, IAction\r\n{\r\n    void IAction.Move() =&gt; Console.WriteLine(&quot;Move in HeroAction&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Несмотря на то, что базовый класс BaseAction уже реализовал интерфейс IAction, но производный класс по-своему реализует его. \r\nПрименение классов:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nHeroAction action1 = new HeroAction();\r\naction1.Move();            // Move in BaseAction\r\n((IAction)action1).Move(); // Move in HeroAction\r\n \r\nIAction action2 = new HeroAction();\r\naction2.Move();             // Move in HeroAction\r\n&lt;/code&gt;\r\n&lt;h3&gt;Модификаторы доступа&lt;/h3&gt;\r\n&lt;p&gt;Члены интерфейса могут иметь разные модификаторы доступа. Если модификатор доступа не public, а какой-то другой, то для реализации метода, свойства или события интерфейса \r\nв классах и структурах также необходимо использовать явную реализацию интерфейса.&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nIMovable tom = new Person(&quot;Tom&quot;);\r\n// подписываемся на событие\r\ntom.MoveEvent += () =&gt; Console.WriteLine($&quot;{tom.Name} is moving&quot;);\r\ntom.Move();\r\n \r\ninterface IMovable\r\n{\r\n    protected internal void Move();\r\n    protected internal string Name { get;}\r\n    delegate void MoveHandler();\r\n    protected internal event MoveHandler MoveEvent;\r\n}\r\nclass Person : IMovable\r\n{\r\n    string name;\r\n    // явная реализация события - дополнительно создается переменная\r\n    IMovable.MoveHandler? moveEvent;\r\n    event IMovable.MoveHandler IMovable.MoveEvent\r\n    {\r\n        add =&gt; moveEvent += value;\r\n        remove =&gt; moveEvent -= value;\r\n    }\r\n    // явная реализация свойства - в виде автосвойства\r\n    string IMovable.Name { get =&gt; name; }\r\n    public Person(string name) =&gt; this.name = name;\r\n    // явная реализация метода\r\n    void IMovable.Move()\r\n    {\r\n        Console.WriteLine($&quot;{name} is walking&quot;);\r\n        moveEvent?.Invoke();\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае опять же надо учитывать, что напрямую мы можем обратиться к подобным методам, свойствам и событиям через переменную интерфейса, но не переменную класса.&lt;/p&gt;'),
(46, 'Наследование интерфейсов', 16, 4, 2, '&lt;p&gt;Интерфейсы, как и классы, могут наследоваться:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ninterface IAction\r\n{\r\n    void Move();\r\n}\r\ninterface IRunAction : IAction\r\n{\r\n    void Run();\r\n}\r\nclass BaseAction : IRunAction\r\n{\r\n    public void Move()\r\n    {\r\n        Console.WriteLine(&quot;Move&quot;);\r\n    }\r\n    public void Run()\r\n    {\r\n        Console.WriteLine(&quot;Run&quot;);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;При применении этого интерфейса класс BaseAction должен будет реализовать как методы и свойства интерфейса IRunAction, так и методы и \r\nсвойства базового интерфейса IAction, если эти методы и свойства не имеют реализации по умолчанию.&lt;/p&gt;\r\n&lt;p&gt;Однако в отличие от классов мы не можем применять к интерфейсам модификатор &lt;strong&gt;sealed&lt;/strong&gt;, чтобы запретить наследование интерфейсов.&lt;/p&gt;\r\n&lt;p&gt;Также мы не можем применять к интерфейсам модификатор &lt;strong&gt;abstract&lt;/strong&gt;, поскольку интерфейс фактически итак, как правило, предоставляет абстрактный функционал, \r\nкоторый должен быть реализован в классе или структуре (за исключением методов и свойств с реализацией по умолчанию).&lt;/p&gt;\r\n&lt;p&gt;Однако методы интерфейсов могут использовать ключевое слово &lt;strong&gt;new&lt;/strong&gt; для скрытия методов из базового интерфейса:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nIAction action1 = new RunAction();\r\naction1.Move(); // I am moving\r\n \r\nIRunAction action2 = new RunAction();\r\naction2.Move(); // I am running\r\n \r\ninterface IAction\r\n{\r\n    void Move() =&gt; Console.WriteLine(&quot;I am moving&quot;);\r\n}\r\ninterface IRunAction : IAction\r\n{\r\n    // скрываем реализацию из IAction\r\n    new void Move() =&gt; Console.WriteLine(&quot;I am running&quot;);\r\n}\r\nclass RunAction : IRunAction { }\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь метод Move из IRunAction скрывает метод Move из базового интерфейса IAction. Это имеет смысл, если в базовом интерфейсе определена \r\nреализация по умолчанию, как в случае выше, которую нужно переопределить. И в случае выше, если переменная представляет тип IRunAction, то для метода Move \r\nвызывается реализация этого интерфейса:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nIRunAction action2 = new RunAction();\r\naction2.Move(); // I am running\r\n&lt;/code&gt;\r\n&lt;p&gt;Иначе если переменная представляет тип IAction, то для метода Move применяется реализация этого интерфейса:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nIAction action1 = new RunAction();\r\naction1.Move(); // I am moving\r\n&lt;/code&gt;\r\n&lt;p&gt;Но класс RunAction может переопределить метод Move сразу для обоих интерфейсов.&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nIAction action1 = new RunAction();\r\naction1.Move(); // I am tired\r\n \r\nIRunAction action2 = new RunAction();\r\naction2.Move(); // I am tired\r\n \r\ninterface IAction\r\n{\r\n    void Move() =&gt; Console.WriteLine(&quot;I am moving&quot;);\r\n}\r\ninterface IRunAction : IAction\r\n{\r\n    new void Move() =&gt; Console.WriteLine(&quot;I am running&quot;);\r\n}\r\nclass RunAction : IRunAction\r\n{\r\n    public void Move() =&gt; Console.WriteLine(&quot;I am tired&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;При наследовании интерфейсов следует учитывать, что, как и при наследовании классов, производный интерфейс должен иметь \r\nтот же уровень доступа или более строгий, чем базовый интерфейс. Например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\npublic interface IAction\r\n{\r\n    void Move();\r\n}\r\ninternal interface IRunAction : IAction\r\n{\r\n    void Run();\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Но не наоборот. Например, в следующем случае мы получим ошибку, и программа не скомпилируется, так как производный \r\nинтерфейс имеет менее строгий уровень доступа, нежели базовый:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ninternal interface IAction\r\n{\r\n    void Move();\r\n}\r\npublic interface IRunAction : IAction   // ошибка IRunAction может быть только internal\r\n{\r\n    void Run();\r\n}\r\n&lt;/code&gt;'),
(47, 'Копирование объектов. Интерфейс ICloneable', 16, 5, 2, '&lt;p&gt;Поскольку классы представляют ссылочные типы, то это накладывает некоторые ограничения на их использование. В частности, допустим, у нас есть \r\nследующий класс:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Person\r\n{\r\n    public string Name { get; set; }\r\n    public int Age { get; set; }\r\n    public Person(string name, int age)\r\n    {\r\n        Name = name;\r\n        Age = age;\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Создадим один объект Person и попробуем скопировать его данные в другой объект Person:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar tom = new Person(&quot;Tom&quot;, 23);\r\nvar bob = tom;\r\nbob.Name = &quot;Bob&quot;;\r\nConsole.WriteLine(tom.Name); // Bob\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае объекты tom и bob будут указывать на один и тот же объект в памяти, поэтому изменения свойств для переменной bob затронут также и переменную tom.&lt;/p&gt;\r\n&lt;p&gt;Чтобы переменная ищи указывала на новый объект, но со значениями из tom, мы можем применить клонирование с помощью реализации интерфейса &lt;strong&gt;ICloneable&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\npublic interface ICloneable\r\n{\r\n    object Clone();\r\n}\r\n&lt;/code&gt;\r\n&lt;h3&gt;Поверхностное копирование&lt;/h3&gt;\r\n&lt;p&gt;Реализация интерфейса в классе Person могла бы выглядеть следующим образом:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Person : ICloneable\r\n{\r\n    public string Name { get; set; }\r\n    public int Age { get; set; }\r\n    public Person(string name, int age)\r\n    {\r\n        Name = name;\r\n        Age = age;\r\n    }\r\n    public object Clone()\r\n    {\r\n        return new Person(Name, Age);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Использование:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar tom = new Person(&quot;Tom&quot;, 23);\r\nvar bob = (Person)tom.Clone();\r\nbob.Name = &quot;Bob&quot;;\r\nConsole.WriteLine(tom.Name); // Tom\r\n&lt;/code&gt;\r\n&lt;p&gt;Теперь все нормально копируется, изменения в свойствах переменной bob не сказываются на свойствах из переменной tom.&lt;/p&gt;\r\n&lt;p&gt;Для сокращения кода копирования мы можем использовать специальный метод &lt;strong&gt;MemberwiseClone()&lt;/strong&gt;, который возвращает копию объекта:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Person : ICloneable\r\n{\r\n    public string Name { get; set; }\r\n    public int Age { get; set; }\r\n    public Person(string name, int age)\r\n    {\r\n        Name = name;\r\n        Age = age;\r\n    }\r\n    public object Clone()\r\n    {\r\n        return MemberwiseClone();\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Этот метод реализует &lt;strong&gt;поверхностное (неглубокое) копирование&lt;/strong&gt;. Однако данного копирования может быть недостаточно. Например, \r\nпусть класс Person содержит ссылку на объект класса Company:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Person : ICloneable\r\n{\r\n    public string Name { get; set; }\r\n    public int Age { get; set; }\r\n    public Company Work { get; set; }\r\n    public Person(string name, int age, Company company)\r\n    {\r\n        Name = name;\r\n        Age = age;\r\n        Work = company;\r\n    }\r\n    public object Clone() =&gt; MemberwiseClone();\r\n}\r\nclass Company\r\n{\r\n    public string Name { get; set; }\r\n    public Company(string name) =&gt; Name = name;\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В этом случае при копировании новая копия будет указывать на тот же объект Company:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar tom = new Person(&quot;Tom&quot;, 23, new Company(&quot;Microsoft&quot;));\r\nvar bob = (Person)tom.Clone();\r\nbob.Work.Name = &quot;Google&quot;;\r\nConsole.WriteLine(tom.Work.Name); // Google - а должно быть Microsoft\r\n&lt;/code&gt;\r\n&lt;h3&gt;Глубокое копирование&lt;/h3&gt;\r\n&lt;p&gt;Поверхностное копирование работает только для свойств, представляющих примитивные типы, но не для сложных объектов. И в этом случае \r\nнадо применять &lt;strong&gt;глубокое копирование&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Person : ICloneable\r\n{\r\n    public string Name { get; set; }\r\n    public int Age { get; set; }\r\n    public Company Work { get; set; }\r\n    public Person(string name, int age, Company company)\r\n    {\r\n        Name = name;\r\n        Age = age;\r\n        Work = company;\r\n    }\r\n    public object Clone() =&gt; new Person(Name, Age, new Company(Work.Name));\r\n}\r\nclass Company\r\n{\r\n    public string Name { get; set; }\r\n    public Company(string name) =&gt; Name = name;\r\n}\r\n&lt;/code&gt;');
INSERT INTO `lectures` (`IDLecture`, `Name`, `IDChapter`, `SerialNumber`, `IDStatus`, `Content`) VALUES
(48, 'Список List&lt;T&gt;', 17, 1, 2, '&lt;p&gt;Хотя в языке C# есть массивы, которые хранят в себе наборы однотипных объектов, но работать с ними не всегда удобно. Например, массив хранит \r\nфиксированное количество объектов, однако что если мы заранее не знаем, сколько нам потребуется объектов. И в этом случае намного удобнее применять \r\nколлекции. Еще один плюс коллекций состоит в том, что некоторые из них реализует стандартные структуры данных, например, стек, очередь, словарь, которые \r\nмогут пригодиться для решения различных специальных задач. Большая часть классов коллекций содержится в пространстве имен \r\n&lt;strong&gt;System.Collections.Generic&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;p&gt;Класс List&lt;T&gt; из пространства имен &lt;strong&gt;System.Collections.Generic&lt;/strong&gt; представляет простейший список однотипных объектов. Класс List типизируется типом, объекты которого будут хранится в списке.&lt;/p&gt;\r\n&lt;p&gt;Мы можем создать пустой список:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nList&lt;string&gt; people = new List&lt;string&gt;();\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае объект List типизируется типом &lt;strong&gt;string&lt;/strong&gt;. А это значит, что хранить в этом списке мы можем только строки.&lt;/p&gt;\r\n&lt;p&gt;Можно сразу при создании списка инициализировать его начальными значениями. В этом случае элементы списка помещаются после вызова конструктора в фигурных скобках&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nList&lt;string&gt; people = new List&lt;string&gt;() { &quot;Tom&quot;, &quot;Bob&quot;, &quot;Sam&quot; };\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае в список помещаются три строки&lt;/p&gt;\r\n&lt;p&gt;Также можно при создании списка инициализировать его элементами из другой коллекции, например, другого списка:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar people = new List&lt;string&gt;() { &quot;Tom&quot;, &quot;Bob&quot;, &quot;Sam&quot; };\r\nvar employees = new List&lt;string&gt;(people);\r\n&lt;/code&gt;\r\n&lt;p&gt;Можно совместить оба способа:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar people = new List&lt;string&gt;() { &quot;Tom&quot;, &quot;Bob&quot;, &quot;Sam&quot; };\r\nvar employees = new List&lt;string&gt;(people){&quot;Mike&quot;};\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае в списке employees будет четыре элемента (&lt;strong&gt;{ &quot;Tom&quot;, &quot;Bob&quot;, &quot;Sam&quot;, &quot;Mike&quot; }&lt;/strong&gt;) - три добавляются из списка people и один элемент задается при инициализации.&lt;/p&gt;\r\n&lt;p&gt;Подобным образом можно работать со списками других типов, например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nList&lt;Person&gt; people = new List&lt;Person&gt;() \r\n{ \r\n    new Person(&quot;Tom&quot;),\r\n    new Person(&quot;Bob&quot;), \r\n    new Person(&quot;Sam&quot;) \r\n};\r\n \r\nclass Person\r\n{\r\n    public string Name { get;}\r\n    public Person(string name) =&gt; Name = name;\r\n}\r\n&lt;/code&gt;\r\n&lt;h3&gt;Установка начальной емкости списка&lt;/h3&gt;\r\n&lt;p&gt;Еще один конструктор класса List принимает в качестве параметра начальную емкость списка:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nList&lt;string&gt; people = new List&lt;string&gt;(16);\r\n&lt;/code&gt;\r\n&lt;p&gt;Указание начальной емкости списка позволяет в будущем увеличить производительность и уменьшить издержки на выделение памяти при \r\nдобавлении элементов. Поскольку динамическое добавление в список может приводить на низком уровне к дополнительному выделению памяти, что \r\nснижает производительность. Если же мы знаем, что список не будет превышать некоторый размер, то мы можем передать этот размер в качестве емкости списка и \r\nизбежать дополнительных выделений памяти.&lt;/p&gt;\r\n&lt;p&gt;Также начальную емкость можно установить с помощью свойства &lt;strong&gt;Capacity&lt;/strong&gt;, которое имеется у класса List.&lt;/p&gt;\r\n&lt;h3&gt;Обращение к элементам списка&lt;/h3&gt;\r\n&lt;p&gt;Как и массивы, списки поддерживают индексы, с помощью которых можно обратиться к определенным элементам:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar people = new List&lt;string&gt;() { &quot;Tom&quot;, &quot;Bob&quot;, &quot;Sam&quot; };\r\n \r\nstring firstPerson = people[0]; // получаем первый элемент\r\nConsole.WriteLine(firstPerson); // Tom\r\npeople[0] = &quot;Mike&quot;;     // изменяем первый элемент\r\nConsole.WriteLine(people[0]); // Mike\r\n&lt;/code&gt;\r\n&lt;h3&gt;Длина списка&lt;/h3&gt;\r\n&lt;p&gt;С помощью свойства &lt;strong&gt;Count&lt;/strong&gt; можно получить длину списка:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar people = new List&lt;string&gt;() { &quot;Tom&quot;, &quot;Bob&quot;, &quot;Sam&quot; };\r\nConsole.WriteLine(people.Count);    // 3\r\n&lt;/code&gt;\r\n&lt;h3&gt;Перебор списка&lt;/h3&gt;\r\n&lt;p&gt;C# позволяет осуществить перебор списка с помощью стандартного цикла &lt;strong&gt;foreach&lt;/strong&gt;:/p&gt;\r\n&lt;/p&gt;&lt;code&gt;\r\n\r\nvar people = new List&lt;string&gt;() { &quot;Tom&quot;, &quot;Bob&quot;, &quot;Sam&quot; };\r\n \r\nforeach (var person in people)\r\n{\r\n    Console.WriteLine(person);\r\n}\r\n// Вывод программы:\r\n// Tom\r\n// Bob\r\n// Sam\r\n&lt;/code&gt;\r\n&lt;p&gt;Также можно использовать другие типы циклов и в комбинации с индексами перебирать списки:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar people = new List&lt;string&gt;() { &quot;Tom&quot;, &quot;Bob&quot;, &quot;Sam&quot; };\r\n \r\nfor (int i = 0; i &lt; people.Count; i++)\r\n{\r\n    Console.WriteLine(people[i]);\r\n}\r\n&lt;/code&gt;\r\n&lt;h3&gt;Методы списка&lt;/h3&gt;\r\n&lt;p&gt;Среди его методов можно выделить следующие:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;void Add(T item)&lt;/strong&gt;: добавление нового элемента в список&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;void AddRange(IEnumerable&lt;T&gt; collection)&lt;/strong&gt;: добавление в список коллекции или массива&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;int BinarySearch(T item)&lt;/strong&gt;: бинарный поиск элемента в списке. Если элемент найден, то метод возвращает индекс этого элемента в коллекции. \r\nПри этом список должен быть отсортирован.&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;void CopyTo(T[] array)&lt;/strong&gt;: копирует список в массив array&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;void CopyTo(int index, T[] array, int arrayIndex, int count)&lt;/strong&gt;: копирует из списка начиная с индекса index элементы, \r\nколичество которых равно count, и вставляет их в массив array начиная с индекса arrayIndex&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;bool Contains(T item)&lt;/strong&gt;: возвращает &lt;strong&gt;true&lt;/strong&gt;, если элемент item есть в списке&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;void Clear()&lt;/strong&gt;: удаляет из списка все элементы&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;bool Exists(Predicate&lt;T&gt; match)&lt;/strong&gt;: возвращает &lt;strong&gt;true&lt;/strong&gt;, если в списке есть элемент, который \r\nсоответствует делегату match&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;T? Find(Predicate&lt;T&gt; match)&lt;/strong&gt;: возвращает первый элемент, который соответствует делегату match. Если элемент не найден, возвращается null&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;T? FindLast(Predicate&lt;T&gt; match)&lt;/strong&gt;: возвращает последний элемент, который соответствует делегату match. Если элемент не найден, возвращается null&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;List&lt;T&gt; FindAll(Predicate&lt;T&gt; match)&lt;/strong&gt;: возвращает список элементов, которые соответствуют делегату match&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;int IndexOf(T item)&lt;/strong&gt;: возвращает индекс первого вхождения элемента в списке&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;int LastIndexOf(T item)&lt;/strong&gt;: возвращает индекс последнего вхождения элемента в списке&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;List&lt;T&gt; GetRange(int index, int count)&lt;/strong&gt;: возвращает список элементов, количество которых равно count, начиная \r\nс индекса index.&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;void Insert(int index, T item)&lt;/strong&gt;: вставляет элемент item в список по индексу index. Если такого индекса в списке нет, то генерируется исключение&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;void InsertRange(int index, collection)&lt;/strong&gt;: вставляет коллекцию элементов collection в текущий список начиная с индекса index. Если такого индекса в списке нет, то генерируется исключение&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;bool Remove(T item)&lt;/strong&gt;: удаляет элемент item из списка, и если удаление прошло успешно, то возвращает true. Если в списке несколько одинаковых элементов, \r\nто удаляется только первый из них&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;void RemoveAt(int index)&lt;/strong&gt;: удаление элемента по указанному индексу index. Если такого индекса в списке нет, то генерируется исключение&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;void RemoveRange(int index, int count)&lt;/strong&gt;: параметр index задает индекс, с которого надо удалить элементы, а параметр \r\ncount задает количество удаляемых элементов.&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;int RemoveAll((Predicate&lt;T&gt; match))&lt;/strong&gt;: удаляет все элементы, которые соответствуют делегату match. Возвращает \r\nколичество удаленных элементов&lt;/p&gt;&lt;/li&gt;\r\n\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;void Reverse()&lt;/strong&gt;: изменяет порядок элементов&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;void Reverse(int index, int count)&lt;/strong&gt;: изменяет порядок на обратный для элементов, количество которых равно count, начиная с индекса index&lt;/p&gt;&lt;/li&gt;\r\n\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;void Sort()&lt;/strong&gt;: сортировка списка&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;void Sort(IComparer&lt;T&gt;? comparer)&lt;/strong&gt;: сортировка списка с помощью объекта comparer, который передается в качестве параметра&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;h3&gt;Добавление в список&lt;/h3&gt;\r\n&lt;code&gt;\r\n\r\nList&lt;string&gt; people = new List&lt;string&gt; () { &quot;Tom&quot; };\r\n \r\npeople.Add(&quot;Bob&quot;); // добавление элемента\r\n// people = { &quot;Tom&quot;, &quot;Bob&quot; };\r\n \r\npeople.AddRange(new[] { &quot;Sam&quot;, &quot;Alice&quot; });   // добавляем массив\r\n// people = { &quot;Tom&quot;, &quot;Bob&quot;, &quot;Sam&quot;, &quot;Alice&quot; };\r\n// также можно было бы добавить другой список\r\n// people.AddRange(new List&lt;string&gt;(){ &quot;Sam&quot;, &quot;Alice&quot; });\r\n \r\npeople.Insert(0, &quot;Eugene&quot;); // вставляем на первое место\r\n// people = { &quot;Eugene&quot;, &quot;Tom&quot;, &quot;Bob&quot;, &quot;Sam&quot;, &quot;Alice&quot; };\r\n \r\npeople.InsertRange(1, new string[] {&quot;Mike&quot;, &quot;Kate&quot;}); // вставляем массив с индекса 1\r\n// people = { &quot;Eugene&quot;, &quot;Mike&quot;, &quot;Kate&quot;, &quot;Tom&quot;, &quot;Bob&quot;, &quot;Sam&quot;, &quot;Alice&quot; };\r\n \r\n// также можно было бы добавить другой список\r\n// people.InsertRange(1, new List&lt;string&gt;(){ &quot;Mike&quot;, &quot;Kate&quot; });\r\n&lt;/string&gt;&lt;/string&gt;\r\n&lt;/code&gt;\r\n&lt;h3&gt;Удаление из списка&lt;/h3&gt;\r\n&lt;code&gt;\r\n\r\nvar people = new List&lt;string&gt; () { &quot;Eugene&quot;, &quot;Mike&quot;, &quot;Kate&quot;, &quot;Tom&quot;, &quot;Bob&quot;, &quot;Sam&quot;, &quot;Tom&quot;, &quot;Alice&quot; };\r\n \r\npeople.RemoveAt(1); //  удаляем второй элемент\r\n// people = { &quot;Eugene&quot;, &quot;Kate&quot;, &quot;Tom&quot;, &quot;Bob&quot;, &quot;Sam&quot;, &quot;Tom&quot;, &quot;Alice&quot; };\r\n \r\npeople.Remove(&quot;Tom&quot;); //  удаляем элемент &quot;Tom&quot;\r\n// people = { &quot;Eugene&quot;, &quot;Kate&quot;, &quot;Bob&quot;, &quot;Sam&quot;, &quot;Tom&quot;, &quot;Alice&quot; };\r\n \r\n// удаляем из списка все элементы, длина строки которых равна 3\r\npeople.RemoveAll(person =&gt; person.Length == 3);\r\n// people = { &quot;Eugene&quot;, &quot;Kate&quot;, &quot;Alice&quot; };\r\n \r\n// удаляем из списка 2 элемента начиная с индекса 1\r\npeople.RemoveRange(1, 2);\r\n// people = { &quot;Eugene&quot;};\r\n \r\n// полностью очищаем список\r\npeople.Clear();\r\n// people = {  };\r\n&lt;/code&gt;\r\n&lt;h3&gt;Поиск и проверка элемента&lt;/h3&gt;\r\n&lt;code&gt;\r\n\r\nvar people = new List&lt;string&gt; () { &quot;Eugene&quot;, &quot;Mike&quot;, &quot;Kate&quot;, &quot;Tom&quot;, &quot;Bob&quot;, &quot;Sam&quot; };\r\n \r\nvar containsBob = people.Contains(&quot;Bob&quot;);     //  true\r\nvar containsBill = people.Contains(&quot;Bill&quot;);    // false\r\n \r\n// проверяем, есть ли в списке строки с длиной 3 символа\r\nvar existsLength3 = people.Exists(p =&gt; p.Length == 3);  // true\r\n \r\n// проверяем, есть ли в списке строки с длиной 7 символов\r\nvar existsLength7 = people.Exists(p =&gt; p.Length == 7);  // false\r\n \r\n// получаем первый элемент с длиной в 3 символа\r\nvar firstWithLength3 = people.Find(p =&gt; p.Length == 3); // Tom\r\n \r\n// получаем последний элемент с длиной в 3 символа\r\nvar lastWithLength3 = people.FindLast(p =&gt; p.Length == 3);  // Sam\r\n \r\n// получаем все элементы с длиной в 3 символа в виде списка\r\nList&lt;string&gt; peopleWithLength3 = people.FindAll(p =&gt; p.Length == 3);\r\n// peopleWithLength3 { &quot;Tom&quot;, &quot;Bob&quot;, &quot;Sam&quot;}\r\n&lt;/code&gt;\r\n&lt;h3&gt;Получение диапазона и копирование в массив&lt;/h3&gt;\r\n&lt;code&gt;\r\n\r\nList&lt;string&gt; people = new List&lt;string&gt;() {&quot;Eugene&quot;, &quot;Tom&quot;, &quot;Mike&quot;, &quot;Sam&quot;, &quot;Bob&quot; };\r\n \r\n// получаем диапазон со второго по четвертый элемент\r\nvar range = people.GetRange(1, 3);\r\n// range = { &quot;Tom&quot;, &quot;Mike&quot;, &quot;Sam&quot;};\r\n \r\n// копируем в массив первые три элемента\r\nstring[] partOfPeople = new string[3];\r\npeople.CopyTo(0, partOfPeople, 0, 3);\r\n// partOfPeople = { &quot;Eugene&quot;, &quot;Tom&quot;, &quot;Mike&quot;};\r\n&lt;/code&gt;\r\n&lt;h3&gt;Расположение элементов в обратном порядке&lt;/h3&gt;\r\n&lt;code&gt;\r\n\r\nvar people = new List&lt;string&gt; () { &quot;Eugene&quot;, &quot;Tom&quot;, &quot;Mike&quot;, &quot;Sam&quot;, &quot;Bob&quot; };\r\n \r\n// переворачиваем весь список\r\npeople.Reverse();\r\n// people = { &quot;Bob&quot;,&quot;Sam&quot;, &quot;Mike&quot;, &quot;Tom&quot;, &quot;Eugene&quot;};\r\n \r\nvar people2 = new List&lt;string&gt;() { &quot;Eugene&quot;, &quot;Tom&quot;, &quot;Mike&quot;, &quot;Sam&quot;, &quot;Bob&quot; };\r\n// переворачиваем часть только 3 элемента с индекса 1\r\npeople2.Reverse(1, 3);\r\n// people2 = { &quot;Eugene&quot;,&quot;Sam&quot;, &quot;Mike&quot;, &quot;Tom&quot;, &quot;Bob&quot; };\r\n&lt;/code&gt;\r\n'),
(49, 'Двухсвязный список LinkedList&lt;T&gt;', 17, 2, 2, '&lt;p&gt;Класс &lt;strong&gt;LinkedList&lt;T&gt;&lt;/strong&gt; представляет двухсвязный список, в котором каждый элемент хранит ссылку одновременно на следующий и на предыдущий \r\nэлемент.&lt;/p&gt;\r\n&lt;h3&gt;Создание связанного списка&lt;/h3&gt;\r\n&lt;p&gt;Для создания связного списка можно принименять один из его конструктора. Например, создадим пустой связный список:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nLinkedList&lt;string&gt; people = new LinkedList&lt;string&gt;();\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае связанный список people предназначен для хранения строк.&lt;/p&gt;\r\n&lt;p&gt;Также можно в конструктор передать коллекцию элементов, например, список List, по которому будет создан связный список:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar employees = new List&lt;string&gt; { &quot;Tom&quot;, &quot;Sam&quot;, &quot;Bob&quot; };\r\n \r\nLinkedList&lt;string&gt; people = new LinkedList&lt;string&gt;(employees);\r\nforeach (string person in people)\r\n{\r\n    Console.WriteLine(person);\r\n}\r\n&lt;/code&gt;\r\n&lt;h3&gt;LinkedListNode&lt;/h3&gt;\r\n&lt;p&gt;Если в простом списке List&lt;T&gt; каждый элемент представляет объект типа T, то в LinkedList&lt;T&gt; каждый узел представляет \r\nобъект класса &lt;strong&gt;LinkedListNode&lt;T&gt;&lt;/strong&gt;. А добавляемые в связанный список элементы T фактически обертываются в объект LinkedListNode.&lt;/p&gt;\r\n&lt;p&gt;Класс LinkedListNode имеет следующие свойства:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Value&lt;/strong&gt;: возвращает или устанавливает само значение узла, представленное типом T&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Next&lt;/strong&gt;: возвращает ссылку на следующий элемент типа LinkedListNode&lt;T&gt; в списке. Если следующий элемент отсутствует, то имеет значение null&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Previous&lt;/strong&gt;: возвращает ссылку предыдущий элемент типа LinkedListNode&lt;T&gt; в списке. Если предыдущий элемент отсутствует, то имеет значение null&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;h3&gt;Свойства LinkedList&lt;/h3&gt;\r\n&lt;p&gt;Класс LinkedList определяет следующие свойства:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Count&lt;/strong&gt;: количество элементов в связанном списке&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;First&lt;/strong&gt;: первый узел в списке в виде объекта LinkedListNode&lt;T&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Last&lt;/strong&gt;: последний узел в списке в виде объекта LinkedListNode&lt;T&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Используем эти свойства:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar employees = new List&lt;string&gt; { &quot;Tom&quot;, &quot;Sam&quot;, &quot;Bob&quot; };\r\n \r\nLinkedList&lt;string&gt; people = new LinkedList&lt;string&gt;(employees);\r\nConsole.WriteLine(people.Count);            // 3\r\nConsole.WriteLine(people.First?.Value);    // Tom\r\nConsole.WriteLine(people.Last?.Value);    // Bob\r\n&lt;/code&gt;\r\n&lt;p&gt;Используя свойства LinkedList и LinkedListNode, можно пройтись по всем элементам списка в прямом или обратном порядке:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nLinkedList&lt;string&gt; people = new LinkedList&lt;string&gt;(new[] { &quot;Tom&quot;, &quot;Sam&quot;, &quot;Bob&quot; });\r\n \r\n// от начала до конца списка\r\nvar currentNode = people.First;\r\nwhile(currentNode != null)\r\n{\r\n    Console.WriteLine(currentNode.Value);\r\n    currentNode = currentNode.Next;\r\n}\r\n \r\n// с конца до начала списка\r\ncurrentNode = people.Last;\r\nwhile (currentNode != null)\r\n{\r\n    Console.WriteLine(currentNode.Value);\r\n    currentNode = currentNode.Previous;\r\n}\r\n&lt;/code&gt;\r\n&lt;h3&gt;Методы LinkedList&lt;/h3&gt;\r\n&lt;p&gt;Используя методы класса LinkedList&lt;T&gt;, можно обращаться к различным элементам, как в конце, так и в начале списка:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;AddAfter(LinkedListNode&lt;T&gt; node, LinkedListNode&lt;T&gt; newNode)&lt;/strong&gt;: вставляет узел newNode в список после узла \r\nnode.&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;AddAfter(LinkedListNode&lt;T&gt; node, T value)&lt;/strong&gt;: вставляет в список новый узел со значением value после узла node.&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;AddBefore(LinkedListNode&lt;T&gt; node, LinkedListNode&lt;T&gt; newNode)&lt;/strong&gt;: вставляет в список узел newNode перед узлом node.&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;AddBefore(LinkedListNode&lt;T&gt; node, T value)&lt;/strong&gt;: вставляет в список новый узел со значением value перед узлом node.&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;AddFirst(LinkedListNode&lt;T&gt; node)&lt;/strong&gt;: вставляет новый узел в начало списка&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;AddFirst(T value)&lt;/strong&gt;: вставляет новый узел со значением value в начало списка&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;AddLast(LinkedListNode&lt;T&gt; node)&lt;/strong&gt;: вставляет новый узел в конец списка&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;AddLast(T value)&lt;/strong&gt;: вставляет новый узел со значением value в конец списка&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;RemoveFirst()&lt;/strong&gt;: удаляет первый узел из списка. После этого новым первым узлом становится узел, следующий за удаленным&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;RemoveLast()&lt;/strong&gt;: удаляет последний узел из списка&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Применим некоторые из этих методов:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar people = new LinkedList&lt;string&gt;();\r\npeople.AddLast(&quot;Tom&quot;); // вставляем узел со значением Tom на последнее место\r\n                        //так как в списке нет узлов, то последнее будет также и первым\r\npeople.AddFirst(&quot;Bob&quot;); // вставляем узел со значением Bob на первое место\r\n \r\n// вставляем после первого узла новый узел со значением Mike\r\nif (people.First != null) people.AddAfter(people.First, &quot;Mike&quot;);\r\n \r\n// теперь у нас список имеет следующую последовательность: Bob Mike Tom\r\nforeach (var person in people) Console.WriteLine(person);\r\n&lt;/code&gt;\r\n&lt;p&gt;Подобным образом можно создавать связанные списки и других типов:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar company = new LinkedList&lt;Person&gt;();\r\n \r\ncompany.AddLast(new Person(&quot;Tom&quot;));\r\ncompany.AddLast(new Person(&quot;Sam&quot;));\r\ncompany.AddFirst(new Person(&quot;Bill&quot;));\r\n \r\nforeach (var person in company) Console.WriteLine(person.Name);\r\n \r\nclass Person\r\n{\r\n    public string Name { get; }\r\n    public Person(string name) =&gt; Name = name;\r\n}\r\n&lt;/code&gt;'),
(50, 'Коллекция Stack&lt;T&gt;', 17, 3, 2, '&lt;p&gt;Класс &lt;strong&gt;Stack&lt;T&gt;&lt;/strong&gt; представляет коллекцию, которая использует алгоритм LIFO (&quot;последний вошел - первый вышел&quot;). \r\nПри такой организации каждый следующий добавленный элемент помещается поверх предыдущего. Извлечение из коллекции происходит в обратном порядке - \r\nизвлекается тот элемент, который находится выше всех в стеке.&lt;/p&gt;\r\n&lt;p&gt;Стек - доволна часто встречаемая структура данных в реальной жизни. Банальные примеры стеков - стопка книг или тарелок, где каждую новую книгу или тарелку \r\nпомещают поверх предыдущей. А извлекают из этой стопки книги/тарелки в обратном порядке - сначала самую верхнюю и так далее. Другой пример - одежда: \r\nдопустим, человек выходит на улицу в зимнюю погоду и для этого сначала одевает майку, потом рубашку, затем свитер, и в конце куртку. Когда человек снимает с себя одежду - \r\nон делает это в обратном порядке: сначала снимает куртку, потом свитер и так далее.&lt;/p&gt;\r\n&lt;h3&gt;Создание стека&lt;/h3&gt;\r\n&lt;p&gt;Для создания стека можно использовать один из трех конструкторов. Прежде всего можно создать пустой стек:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nStack&lt;string&gt; people = new Stack&lt;string&gt;();\r\n&lt;/code&gt;\r\n&lt;p&gt;При создании пустого стека можно указать емкость стека:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nStack&lt;string&gt; people = new Stack&lt;string&gt;(16);\r\n&lt;/code&gt;\r\n&lt;p&gt;Также можно инициализировать стек элементами из другой коллекции или массивом:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar employees = new List&lt;string&gt; { &quot;Tom&quot;, &quot;Sam&quot;, &quot;Bob&quot; };\r\nStack&lt;string&gt; people = new Stack&lt;string&gt;(employees);\r\nforeach (var person in people) Console.WriteLine(person);\r\n \r\nConsole.WriteLine(people.Count); // 3\r\n&lt;/code&gt;\r\n&lt;p&gt;Для перебора стека можно использовать стандартный цикл &lt;strong&gt;foreach&lt;/strong&gt;. Причем в цикле в соответствии с аалгоритмом стека LIFO \r\nданные извлекаются в порядке, обратном их добавлению. Консольный вывод в данном случае:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Bob\r\nSam\r\nTom\r\n3\r\n&lt;/pre&gt;\r\n\r\n&lt;p&gt;Для получения количества элементов стека применяется свойство &lt;strong&gt;Count&lt;/strong&gt;.&lt;/p&gt;\r\n\r\n&lt;h3&gt;Методы Stack&lt;/h3&gt;\r\n&lt;p&gt;В классе Stack можно выделить следующие методы:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Clear&lt;/strong&gt;: очищает стек&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Contains&lt;/strong&gt;: проверяет наличие в стеке элемента и возвращает true при его наличии&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Push&lt;/strong&gt;: добавляет элемент в стек в верхушку стека&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Pop&lt;/strong&gt;: извлекает и возвращает первый элемент из стека&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Peek&lt;/strong&gt;: просто возвращает первый элемент из стека без его удаления&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Посмотрим на примере:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar people = new Stack&lt;string&gt;();\r\npeople.Push(&quot;Tom&quot;);\r\n// people = { Tom }\r\npeople.Push(&quot;Sam&quot;);\r\n// people = { Sam, Tom }\r\npeople.Push(&quot;Bob&quot;);\r\n// people = { Bob, Sam, Tom }\r\n \r\n// получаем первый элемент стека без его удаления \r\nstring headPerson = people.Peek();\r\nConsole.WriteLine(headPerson);  // Bob\r\n \r\nstring person1 = people.Pop();\r\n// people = { Sam, Tom }\r\nConsole.WriteLine(person1);  // Bob\r\n \r\nstring person2 = people.Pop();\r\n// people = { Tom }\r\nConsole.WriteLine(person2);  // Sam\r\n \r\nstring person3 = people.Pop();\r\n// people = { }\r\nConsole.WriteLine(person3);  // Tom\r\n&lt;/code&gt;\r\n&lt;p&gt;Работу стека можно представить следующей иллюстрацией:&lt;/p&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/4.1.png&quot; alt=&quot;Stack в C#&quot;&gt;\r\n&lt;p&gt;Стоит отметить, что если с помощью методов Peek или Pop мы попытаемся получить первый элемент стека, который пуст, \r\nто программа выдаст исключение. Соответственно перед получением элемента мы можем проверять количество элементов в стеке:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nif(people.Count &gt; 0)\r\n{\r\n    var person = people.Peek();\r\n    people.Pop();\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Либо можно использовать пару методов:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;bool TryPop(out T result)&lt;/strong&gt;: удаляет из стека первый элемент и передает его в переменную result, возвращает &lt;strong&gt;true&lt;/strong&gt;, если очередь не пуста и элемент успешно получен.&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;bool TryPeek(out T result)&lt;/strong&gt;: передает в переменную result первый элемент стека без его извлечения, \r\nвозвращает &lt;strong&gt;true&lt;/strong&gt;, если элемент успешно получен.&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Применение методов:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar people = new Stack&lt;string&gt;();\r\npeople.Push(&quot;Tom&quot;);\r\n// people = { Tom }\r\n \r\n// удаляем элементы\r\nvar success1 = people.TryPop(out var person1);  // success1 = true\r\nif (success1) Console.WriteLine(person1); // Tom\r\n \r\nvar success2 = people.TryPeek(out var person2);  // success2 = false\r\nif (success2) Console.WriteLine(person2);\r\n&lt;/code&gt;'),
(51, 'Коллекция Dictionary&lt;K, V&gt;', 17, 4, 2, '&lt;p&gt;Еще один распространенный тип коллекции представляют словари. Словарь хранит объекты, которые представляют пару ключ-значение. \r\nКласс словаря &lt;strong&gt;Dictionary&lt;K, V&gt;&lt;/strong&gt; типизируется двумя типами: параметр &lt;strong&gt;K&lt;/strong&gt; представляет тип ключей, \r\nа параметр &lt;strong&gt;V&lt;/strong&gt; предоставляет тип значений.&lt;/p&gt;\r\n&lt;h3&gt;Создания и инициализация словаря&lt;/h3&gt;\r\n&lt;p&gt;Класс Dictionary предоставляет ряд конструкторов для создания словаря. Например, мы можем создать пустой словарь:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nDictionary&lt;int, string&gt; people = new Dictionary&lt;int, string&gt;();\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь словарь &lt;strong&gt;people&lt;/strong&gt; в качестве ключей принимает значения типа int, а в качестве значений - строки.&lt;/p&gt;\r\n&lt;p&gt;При определении словаря его сразу  же можно инициализировать значениями:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar people = new Dictionary&lt;int, string&gt;()\r\n{\r\n    { 5, &quot;Tom&quot;},\r\n    { 3, &quot;Sam&quot;},\r\n    { 11, &quot;Bob&quot;}\r\n};\r\n&lt;/code&gt;\r\n&lt;p&gt;При инициализации применяется инициализитор - в фигурных скобках после вызова конструктора объекту передаются начальные данные. В \r\nслучае со словаем мы можем передать в инициализаторе набор элементов, где каждый элемент заключается в фигурные скобки, например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\n{ 5, &quot;Tom&quot;}\r\n&lt;/code&gt;\r\n&lt;p&gt;Каждый элемент представляет два значения: первое значение представляет ключ, а второе значение - собственно значение элемента. \r\nПоскольку при объявлении словаря people для ключей указан тип &lt;strong&gt;int&lt;/strong&gt;, а для значений - тип &lt;strong&gt;string&lt;/strong&gt;, то в элементе словаря \r\nсначала указывается число int, а затем строка. То есть в случае выше элемент имеет ключ 5, а значение - &quot;Tom&quot;. Затем по ключу элемента мы сможем получить его значение.&lt;/p&gt;\r\n&lt;p&gt;Также мы можем применять другой способ инициализации:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar people = new Dictionary&lt;int, string&gt;()\r\n{\r\n    [5] = &quot;Tom&quot;,\r\n    [6] = &quot;Sam&quot;,\r\n    [7] = &quot;Bob&quot;\r\n};  \r\n&lt;/code&gt;\r\n&lt;p&gt;При таком способе инициализации в квадратных скобках указывается ключ и ему присваивается значение элемента. Но в целом этот способ инициализации будет равноценен предыдущему.&lt;/p&gt;\r\n&lt;h3&gt;KeyValuePair&lt;/h3&gt;\r\n&lt;p&gt;Стоит отметить, что каждый элемент в словаре представляет структуру &lt;strong&gt;KeyValuePair&lt;TKey, TValue&gt;&lt;/strong&gt;, где параметр &lt;strong&gt;TKey&lt;/strong&gt; представляет тип ключа, \r\nа параметр &lt;strong&gt;TValue&lt;/strong&gt; - тип значений элементов. Эта структура предоставляет свойства &lt;strong&gt;Key&lt;/strong&gt; и &lt;strong&gt;Value&lt;/strong&gt;, \r\nс помощью которых можно получить соответственно ключ и значение элемента в словаре. И одна из версий конструктора Dictionary позволяет инициализировать \r\nсловарь коллекцией объектов KeyValuePair:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar mike = new KeyValuePair&lt;int, string&gt;(56, &quot;Mike&quot;); \r\nvar employees = new List&lt;KeyValuePair&lt;int, string&gt;&gt;() { mike};\r\nvar people = new Dictionary&lt;int, string&gt;(employees);\r\n&lt;/code&gt;\r\n&lt;p&gt;Конструктор типа &lt;strong&gt;KeyValuePair&lt;/strong&gt; принимает два параметра - ключ элемента и его значения. То есть в данном случае создается один такой \r\nэлемент  - &lt;strong&gt;mike&lt;/strong&gt; с ключом 56 и значением &quot;Mike&quot;. И этот элемент добавляется в список employees, которым затем инициализируется словарь.&lt;/p&gt;\r\n&lt;p&gt;Можно совместить оба способа инициализации:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar mike = new KeyValuePair&lt;int, string&gt;(56, &quot;Mike&quot;);\r\nvar employees = new List&lt;KeyValuePair&lt;int, string&gt;&gt;() { mike };\r\nvar people = new Dictionary&lt;int, string&gt;(employees)\r\n{\r\n    [5] = &quot;Tom&quot;,\r\n    [6] = &quot;Sam&quot;,\r\n    [7] = &quot;Bob&quot;,\r\n};\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае в словаре people будет четыре элемента.&lt;/p&gt;\r\n&lt;h3&gt;Перебор словаря&lt;/h3&gt;\r\n&lt;p&gt;Для перебора словаря можно применять цикл &lt;strong&gt;foreach&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar people = new Dictionary&lt;int, string&gt;()\r\n{\r\n    [5] = &quot;Tom&quot;,\r\n    [6] = &quot;Sam&quot;,\r\n    [7] = &quot;Bob&quot;\r\n};\r\nforeach(var person in people)\r\n{\r\n    Console.WriteLine($&quot;key: {person.Key}  value: {person.Value}&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;При переборе каждый элемент будет помещаться в переменную, которая представляет тип KeyValuePair, соответственно с помощью свойств Key и Value мы \r\nсможем получить ключ и значение элемента. Консольный вывод программы:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;key: 5  value: Tom\r\nkey: 6  value: Sam\r\nkey: 7  value: Bob\r\n&lt;/pre&gt;\r\n\r\n&lt;h3&gt;Получение элементов&lt;/h3&gt;\r\n&lt;p&gt;Для обращения к элементам из словаря применяется их ключ, который передается в квадратных скобках:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nсловарь[ключ]\r\n&lt;/code&gt;\r\n&lt;p&gt;Таким образом мы можем получить и изменить элементы словаря&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar people = new Dictionary&lt;int, string&gt;()\r\n{\r\n    [5] = &quot;Tom&quot;,\r\n    [6] = &quot;Sam&quot;,\r\n    [7] = &quot;Bob&quot;,\r\n};\r\n// получаем элемент по ключу 6\r\nstring sam = people[6];  // Sam\r\nConsole.WriteLine(sam);  // Sam\r\n// переустанавливаем значение по ключу 6\r\npeople[6] = &quot;Mike&quot;;\r\nConsole.WriteLine(people[6]);  // Mike\r\n \r\n// добавляем новый элемент по ключу 22\r\npeople[22] = &quot;Eugene&quot;;\r\nConsole.WriteLine(people[22]);  // Eugene\r\n&lt;/code&gt;\r\n&lt;p&gt;Более того, таким образом мы можем также добавить новый элемент в словарь. При установке значения по ключу, если элемент с таким ключом уже есть в словаре, \r\nто значение переустанавливается. Если же элемента с подобным ключом нет в словаре, то элемент добавляется.:&lt;/p&gt;\r\n&lt;h3&gt;Методы и свойства Dictionary&lt;/h3&gt;\r\n&lt;p&gt;Среди методов класса Dictionary можно выделить следующие:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;void Add(K key, V value)&lt;/strong&gt;: добавляет новый элемент в словарь&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;void Clear()&lt;/strong&gt;: очищает словарь&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;bool ContainsKey(K key)&lt;/strong&gt;: проверяет наличие элемента с определенным ключом и возвращает true при его наличии в словаре&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;bool ContainsValue(V value)&lt;/strong&gt;: проверяет наличие элемента с определенным значением и возвращает true при его наличии в словаре&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;bool Remove(K key)&lt;/strong&gt;: удаляет по ключу элемент из словаря&lt;/p&gt;\r\n&lt;p&gt;Другая версия этого метода позволяет получить удленный элемент в выходной параметр: &lt;strong&gt;bool Remove(K key, out V value)&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;bool TryGetValue(K key, out V value)&lt;/strong&gt;: получает из словаря элемент по ключу key. При успешном получении передает \r\nзначение элемента в выходной параметр value и возвращает true&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;bool TryAdd(K key, V value)&lt;/strong&gt;: добавляет в словарь элемент с ключом key и значением value. При успешном добавлении \r\nвозвращает true&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Из свойств следует отметить свойство &lt;strong&gt;Count&lt;/strong&gt;, которое возвращает количество элементов в словаре.&lt;/p&gt;\r\n&lt;p&gt;Применение методов:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\n// условная телефонная книга\r\nvar phoneBook = new Dictionary&lt;string, string&gt;();\r\n \r\n// добавляем элемент: ключ - номер телефона, значение - имя абонента\r\nphoneBook.Add(&quot;+123456&quot;, &quot;Tom&quot;);\r\n// альтернативное добавление\r\n// phoneBook[&quot;+123456&quot;] = &quot;Tom&quot;;\r\n \r\n// Проверка наличия\r\nvar phoneExists1 = phoneBook.ContainsKey(&quot;+123456&quot;);    // true\r\nConsole.WriteLine($&quot;+123456: {phoneExists1}&quot;);\r\nvar phoneExists2 = phoneBook.ContainsKey(&quot;+567456&quot;);    // false\r\nConsole.WriteLine($&quot;+567456: {phoneExists2}&quot;);\r\nvar abonentExists1 = phoneBook.ContainsValue(&quot;Tom&quot;);      // true\r\nConsole.WriteLine($&quot;Tom: {abonentExists1}&quot;);\r\nvar abonentExists2 = phoneBook.ContainsValue(&quot;Bob&quot;);      // false\r\nConsole.WriteLine($&quot;Bob: {abonentExists2}&quot;);\r\n \r\n// удаление элемента\r\nphoneBook.Remove(&quot;+123456&quot;);\r\n \r\n// проверяем количество элементов после удаления\r\nConsole.WriteLine($&quot;Count: {phoneBook.Count}&quot;); // Count: 0\r\n&lt;/code&gt;\r\n'),
(52, 'Интерфейсы IEnumerable и IEnumerator', 17, 6, 2, '&lt;p&gt;Как мы увидели, основной для большинства коллекций является реализация интерфейсов IEnumerable и IEnumerator. Благодаря такой реализации \r\nмы можем перебирать объекты в цикле &lt;strong&gt;foreach&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nforeach(var item in перечислимый_объект)\r\n{\r\n     \r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Перебираемая коллекция должна реализовать интерфейс IEnumerable.&lt;/p&gt;\r\n&lt;p&gt;Интерфейс IEnumerable имеет метод, возвращающий ссылку на другой интерфейс - перечислитель:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\npublic interface IEnumerable\r\n{\r\n    IEnumerator GetEnumerator();\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;А интерфейс IEnumerator определяет функционал для перебора внутренних объектов в контейнере:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\npublic interface IEnumerator\r\n{\r\n    bool MoveNext(); // перемещение на одну позицию вперед в контейнере элементов\r\n    object Current {get;}  // текущий элемент в контейнере\r\n    void Reset(); // перемещение в начало контейнера\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Метод &lt;strong&gt;MoveNext()&lt;/strong&gt; перемещает указатель на текущий элемент на следующую позицию в последовательности. Если последовательность еще не закончилась, то возвращает \r\ntrue. Если же последовательность закончилась, то возвращается false.&lt;/p&gt;\r\n&lt;p&gt;Свойство &lt;strong&gt;Current&lt;/strong&gt; возвращает объект в последовательности, на который указывает указатель.&lt;/p&gt;\r\n&lt;p&gt;Метод &lt;strong&gt;Reset()&lt;/strong&gt; сбрасывает указатель позиции в начальное положение.&lt;/p&gt;\r\n&lt;p&gt;Каким именно образом будет осуществляться перемещение указателя и получение элементов зависит от реализации интерфейса. В различных реализациях \r\nлогика может быть построена различным образом. &lt;/p&gt;\r\n&lt;p&gt;Например, без использования цикла foreach перебирем массив с помощью интерфейса IEnumerator:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nusing System.Collections;\r\n \r\nstring[] people = {&quot;Tom&quot;, &quot;Sam&quot;, &quot;Bob&quot;};\r\n \r\nIEnumerator peopleEnumerator = people.GetEnumerator(); // получаем IEnumerator\r\nwhile (peopleEnumerator.MoveNext())   // пока не будет возвращено false\r\n{\r\n    string item = (string)peopleEnumerator.Current; // получаем элемент на текущей позиции\r\n    Console.WriteLine(item);\r\n}\r\npeopleEnumerator.Reset(); // сбрасываем указатель в начало массива\r\n&lt;/code&gt;\r\n&lt;h3&gt;Реализация IEnumerable и IEnumerator&lt;/h3&gt;\r\n&lt;p&gt;Рассмотрим простешую реализацию &lt;strong&gt;IEnumerable&lt;/strong&gt; на примере:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nusing System.Collections;\r\n \r\nWeek week = new Week();\r\nforeach (var day in week)\r\n{\r\n    Console.WriteLine(day);\r\n}\r\n \r\nclass Week : IEnumerable\r\n{\r\n    string[] days = { &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;,\r\n                         &quot;Friday&quot;, &quot;Saturday&quot;, &quot;Sunday&quot; };\r\n    public IEnumerator GetEnumerator() =&gt; days.GetEnumerator();\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае класс Week, который представляет неделю и хранит все дни недели, реализует интерфейс IEnumerable. Однако в данном \r\nслучае мы поступили очень просто - вместо реализации IEnumerator мы просто возвращаем в методе GetEnumerator объект IEnumerator для \r\nмассива.&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\npublic IEnumerator GetEnumerator() =&gt; days.GetEnumerator();\r\n&lt;/code&gt;\r\n&lt;p&gt;Благодаря этому мы можем перебрать все дни недели в цикле foreach.&lt;/p&gt;\r\n&lt;p&gt;В то же время стоит отметить, что для перебора коллекции через foreach в принципе необязательно реализовать интерфейс IEnumerable. Достаточно \r\nв классе определить публичный метод &lt;strong&gt;GetEnumerator&lt;/strong&gt;, который бы возвращал объект IEnumerator. Например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Week\r\n{\r\n    string[] days = { &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, \r\n                        &quot;Friday&quot;, &quot;Saturday&quot;, &quot;Sunday&quot; };\r\n    public IEnumerator GetEnumerator() =&gt;days.GetEnumerator();\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Однако это было довольно просто - мы просто используем уже готовый перчислитель массива. Однако, возможно, потребуется задать свою собственную \r\nлогику перебора объектов. Для этого реализуем интерфейс &lt;strong&gt;IEnumerator&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nusing System.Collections;\r\n \r\nclass WeekEnumerator : IEnumerator\r\n{\r\n    string[] days;\r\n    int position = -1;\r\n    public WeekEnumerator(string[] days) =&gt; this.days = days;\r\n    public object Current\r\n    {\r\n        get\r\n        {\r\n            if (position == -1 || position &gt;= days.Length)\r\n                throw new ArgumentException();\r\n            return days[position];\r\n        }\r\n    }\r\n    public bool MoveNext()\r\n    {\r\n        if (position &lt; days.Length - 1)\r\n        {\r\n            position++;\r\n            return true;\r\n        }\r\n        else\r\n            return false;\r\n    }\r\n    public void Reset() =&gt; position = -1;\r\n}\r\nclass Week\r\n{\r\n    string[] days = { &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;,\r\n                            &quot;Friday&quot;, &quot;Saturday&quot;, &quot;Sunday&quot; };\r\n    public IEnumerator GetEnumerator() =&gt; new WeekEnumerator(days);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь теперь класс Week использует не встроенный перечислитель, а WeekEnumerator, который реализует IEnumerator.&lt;/p&gt;\r\n&lt;p&gt;Ключевой момент при реализации перечислителя - перемещения указателя на элемент. В классе WeekEnumerator для хранения текущей позиции \r\nопределена переменная position. Следует учитывать, что в самом начале (в исходном состоянии) указатель должен указывать на позицию условно перед первым элементом. \r\nКогда будет производиться цикл foreach, то данный цикл вначале вызывает метод MoveNext и фактически перемещает указатель на одну позицию в перед и только \r\nзатем обращается к свойству Current для получения элемента в текущей позиции.&lt;/p&gt;\r\n&lt;p&gt;Затем в программе мы можем аналогичным образом перебирать объект Week с помощью цикла foreach:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nWeek week = new Week();\r\nforeach(var day in week)\r\n{\r\n    Console.WriteLine(day);\r\n}\r\n&lt;/code&gt;\r\n&lt;h3&gt;Обобщенная версия IEnumerator&lt;/h3&gt;\r\n&lt;p&gt;В примерах выше использовались необобщенные версии интерфейсов, однако мы также можем использовать их обобщенные двойники:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nusing System.Collections;\r\n \r\nclass WeekEnumerator : IEnumerator&lt;string&gt;\r\n{\r\n    string[] days;\r\n    int position = -1;\r\n    public WeekEnumerator(string[] days) =&gt; this.days = days;\r\n    public string Current\r\n    {\r\n        get\r\n        {\r\n            if (position == -1 || position &gt;= days.Length)\r\n                throw new ArgumentException();\r\n            return days[position];\r\n        }\r\n    }\r\n    object IEnumerator.Current =&gt; throw new NotImplementedException();\r\n    public bool MoveNext()\r\n    {\r\n        if (position &lt; days.Length - 1)\r\n        {\r\n            position++;\r\n            return true;\r\n        }\r\n        else\r\n            return false;\r\n    }\r\n    public void Reset() =&gt; position = -1;\r\n    public void Dispose() { }\r\n}\r\nclass Week\r\n{\r\n    string[] days = { &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;,\r\n                            &quot;Friday&quot;, &quot;Saturday&quot;, &quot;Sunday&quot; };\r\n    public IEnumerator&lt;string&gt; GetEnumerator() =&gt; new WeekEnumerator(days);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае реализуем интерфейс &lt;strong&gt;IEnumerator&lt;string&gt;&lt;/strong&gt;, соответственно в свойстве Current нам надо возвратить объект string. В этом случае при \r\nпереборе в цикле foreach перебираемые объекты будут автоматически представлять тип &lt;strong&gt;string&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nWeek week = new Week();\r\nforeach (string day in week)\r\n{\r\n    Console.WriteLine(day);\r\n}\r\n&lt;/code&gt;');
INSERT INTO `lectures` (`IDLecture`, `Name`, `IDChapter`, `SerialNumber`, `IDStatus`, `Content`) VALUES
(53, 'Класс ObservableCollection', 17, 5, 2, '&lt;p&gt;Кроме стандартных классов коллекций типа списков, очередей, словарей, стеков .NET также предоставляет специальный класс &lt;strong&gt;ObservableCollection&lt;T&gt;&lt;/strong&gt;. \r\nВ отличие от ранее рассмотренных коллекций данный класс определен в пространстве имен &lt;strong&gt;System.Collections.ObjectModel&lt;/strong&gt;. \r\nПо функциональности коллекция ObservableCollection похожа на список List за тем исключением, что позволяет известить внешние объекты о том, что коллекция была изменена.&lt;/p&gt;\r\n&lt;h3&gt;Создание и инициализация ObservableCollection&lt;/h3&gt;\r\n&lt;p&gt;Для создания объекта класс ObservableCollection предоставляет ряд конструкторов. Прежде всего мы можем создать пустую коллекцию:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nusing System.Collections.ObjectModel;\r\n \r\nObservableCollection&lt;string&gt; people = new ObservableCollection&lt;string&gt;();\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае коллекция people типизируется типом &lt;strong&gt;string&lt;/strong&gt;, поэтому может хранить только строки.&lt;/p&gt;\r\n&lt;p&gt;Другая версия конструктора позволяет передать в ObservableCollection объекты из другой коллекции или массива:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar people = new ObservableCollection&lt;string&gt;( new string[] {&quot;Tom&quot;, &quot;Bob&quot;, &quot;Sam&quot;});\r\n&lt;/code&gt;\r\n&lt;p&gt;Для инициализации можно через инициализатор в фигурных скобках передать значения&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar people = new ObservableCollection&lt;string&gt;\r\n{\r\n    &quot;Tom&quot;, &quot;Bob&quot;, &quot;Sam&quot;\r\n};\r\n&lt;/code&gt;\r\n&lt;p&gt;Также можно сочетать предыдущие два способа:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar people = new ObservableCollection&lt;string&gt;( new string[] {&quot;Mike&quot;, &quot;Alice&quot;, &quot;Kate&quot; })\r\n{\r\n    &quot;Tom&quot;, &quot;Bob&quot;, &quot;Sam&quot;\r\n};\r\n&lt;/code&gt;\r\n&lt;h3&gt;Обращение к элементам коллекции&lt;/h3&gt;\r\n&lt;p&gt;Для обращения к элементам ObservableCollection можно применять индексы на манер массивов или списков List:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar people = new ObservableCollection&lt;string&gt;\r\n{\r\n    &quot;Tom&quot;, &quot;Bob&quot;, &quot;Sam&quot;\r\n};\r\n \r\n// получаем первый элемент\r\nConsole.WriteLine(people[0]);   // Tom\r\n// изменяем первый элемент\r\npeople[0] = &quot;Tomas&quot;;\r\nConsole.WriteLine(people[0]);   // Tomas\r\n&lt;/code&gt;\r\n&lt;h3&gt;Перебор коллекции&lt;/h3&gt;\r\n&lt;p&gt;Для перебора коллекции можно применять стандартные циклы:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nusing System.Collections.ObjectModel;\r\n \r\nvar people = new ObservableCollection&lt;string&gt;\r\n{\r\n    &quot;Tom&quot;, &quot;Bob&quot;, &quot;Sam&quot;\r\n};\r\n \r\nforeach(var person in people)\r\n{\r\n    Console.WriteLine(person);\r\n}\r\nfor (int i =0; i &lt; people.Count; i++)\r\n{\r\n    Console.WriteLine(people[i]);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;С помощью свойства &lt;strong&gt;Count&lt;/strong&gt; можно получить количество элементов в коллекции.&lt;/p&gt;\r\n&lt;h3&gt;Методы ObservableCollection&lt;/h3&gt;\r\n&lt;p&gt;Среди методов класса ObservableCollection можно отметить следующие:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;void Add(T item)&lt;/strong&gt;: добавление нового элемента в коллекцию&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;void CopyTo(T[] array, int index,)&lt;/strong&gt;: копирует в массив array элементы из коллекции начиная с индекса index&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;bool Contains(T item)&lt;/strong&gt;: возвращает &lt;strong&gt;true&lt;/strong&gt;, если элемент item есть в коллекции&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;void Clear()&lt;/strong&gt;: удаляет из коллекции все элементы&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;int IndexOf(T item)&lt;/strong&gt;: возвращает индекс первого вхождения элемента в коллекции&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;void Insert(int index, T item)&lt;/strong&gt;: вставляет элемент item в коллекцию по индексу index. \r\nЕсли такого индекса в коллекции нет, то генерируется исключение&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;bool Remove(T item)&lt;/strong&gt;: удаляет элемент item из коллекции, и если удаление прошло успешно, то возвращает true. \r\nЕсли в коллекции несколько одинаковых элементов, то удаляется только первый из них&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;void RemoveAt(int index)&lt;/strong&gt;: удаление элемента по указанному индексу index. Если такого индекса в коллекции нет, то \r\nгенерируется исключение&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;void Move(int oldIndex, int newIndex)&lt;/strong&gt;:  перемещает элемент с индекса oldIndex на позицию по индексу newIndex&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Применение методов:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nusing System.Collections.ObjectModel;\r\n \r\nvar people = new ObservableCollection&lt;string&gt;();\r\n \r\n// добавляем элемент\r\npeople.Add(&quot;Bob&quot;);\r\n// вставляем элемент по индексу 0\r\npeople.Insert(0, &quot;Tom&quot;);\r\n \r\n// проверка наличия элемента \r\nbool bobExists = people.Contains(&quot;Bob&quot;);     // true\r\nConsole.WriteLine($&quot;Bob exists: {bobExists}&quot;);\r\nbool mikeExists = people.Contains(&quot;Mike&quot;);   // false\r\nConsole.WriteLine($&quot;Mike exists: {mikeExists}&quot;);\r\n \r\n// удаляем элемент\r\npeople.Remove(&quot;Tom&quot;);\r\n// удаляем элемент по индексу 0\r\npeople.RemoveAt(0);\r\n&lt;/code&gt;\r\n&lt;h3&gt;Уведомление об измении коллекции&lt;/h3&gt;\r\n&lt;p&gt;Класс ObservableCollection определяет событие &lt;strong&gt;CollectionChanged&lt;/strong&gt;, подписавшись на которое, мы можем обработать любые изменения коллекции. \r\nДанное событие представляет делегат &lt;strong&gt;NotifyCollectionChangedEventHandler&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvoid NotifyCollectionChangedEventHandler(object? sender, NotifyCollectionChangedEventArgs e);\r\n&lt;/code&gt;\r\n&lt;p&gt;Второй параметр делегата - объект &lt;strong&gt;NotifyCollectionChangedEventArgs&lt;/strong&gt; хранит всю информацию о событии. В частности, его \r\nсвойство &lt;strong&gt;Action&lt;/strong&gt; позволяет узнать характер изменений. Оно хранит одно из значений \r\nиз перечисления &lt;span class=&quot;bb&quot;&gt;NotifyCollectionChangedAction&lt;/span&gt;:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;NotifyCollectionChangedAction.Add&lt;/strong&gt;: добавление&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;NotifyCollectionChangedAction.Remove&lt;/strong&gt;: удаление&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;NotifyCollectionChangedAction.Replace&lt;/strong&gt;: замена&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;NotifyCollectionChangedAction.Move&lt;/strong&gt;: перемещение объекта внутри коллекции на новую позицию&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;NotifyCollectionChangedAction.Reset&lt;/strong&gt;: сброс содержимого коллекции (например, при ее очистке с помощью метода &lt;strong&gt;Clear()&lt;/strong&gt;)&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Кроме того, свойства &lt;strong&gt;NewItems&lt;/strong&gt; и &lt;strong&gt;OldItems&lt;/strong&gt; позволяют получить соответственно добавленные и удаленные объекты. Таким образом, мы получаем полный \r\nконтроль над обработкой добавления, удаления и замены объектов в коллекции.&lt;/p&gt;\r\n&lt;p&gt;Допустим, у нас будет следующий класс Person, который представляет пользователя:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Person\r\n{\r\n    public string Name { get; }\r\n    public Person(string name) =&gt; Name = name;\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Для управления коллекцией объектов Person определим следующую программу:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nusing System.Collections.ObjectModel;\r\nusing System.Collections.Specialized;\r\n \r\nvar people = new ObservableCollection&lt;Person&gt;() \r\n{ \r\n    new Person(&quot;Tom&quot;), \r\n    new Person(&quot;Sam&quot;) \r\n};\r\n// подписываемся на событие изменения коллекции\r\npeople.CollectionChanged += People_CollectionChanged;\r\n \r\npeople.Add(new Person(&quot;Bob&quot;));  // добавляем новый элемент\r\n \r\npeople.RemoveAt(1);                 // удаляем элемент\r\npeople[0] = new Person(&quot;Eugene&quot;);   // заменяем элемент\r\n \r\nConsole.WriteLine(&quot;\\nСписок пользователей:&quot;);\r\nforeach (var person in people)\r\n{\r\n    Console.WriteLine(person.Name);\r\n}\r\n// обработчик изменения коллекции\r\nvoid People_CollectionChanged(object? sender, NotifyCollectionChangedEventArgs e)\r\n{\r\n    switch (e.Action)\r\n    {\r\n        case NotifyCollectionChangedAction.Add: // если добавление\r\n            if(e.NewItems?[0] is Person newPerson)\r\n                Console.WriteLine($&quot;Добавлен новый объект: {newPerson.Name}&quot;);\r\n            break;\r\n        case NotifyCollectionChangedAction.Remove: // если удаление\r\n            if (e.OldItems?[0] is Person oldPerson)\r\n                Console.WriteLine($&quot;Удален объект: {oldPerson.Name}&quot;);\r\n            break;\r\n        case NotifyCollectionChangedAction.Replace: // если замена\r\n            if ((e.NewItems?[0] is Person replacingPerson)  &amp;amp;&amp;amp; \r\n                (e.OldItems?[0] is Person replacedPerson))\r\n                Console.WriteLine($&quot;Объект {replacedPerson.Name} заменен объектом {replacingPerson.Name}&quot;);\r\n            break;\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь в качестве обработчика изменений коллекции выступает метод &lt;strong&gt;People_CollectionChanged&lt;/strong&gt;, в котором с помощью параметра NotifyCollectionChangedEventArgs \r\nполучаем информацию об изменении. Консольный вывод программы:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Добавлен новый объект: Bob\r\nУдален объект: Sam\r\nОбъект Tom заменен объектом Eugene\r\n\r\nСписок пользователей:\r\nEugene\r\nBob\r\n&lt;/pre&gt;\r\n'),
(54, 'Введение в многопоточность. Класс Thread', 18, 1, 2, '&lt;p&gt;Одним из ключевых аспектов в современном программировании является &lt;strong&gt;многопоточность&lt;/strong&gt;. Ключевым понятием при работе с многоопоточностью является поток. \r\nПоток предствляет некоторую часть кода программы. При выполнении программы каждому потоку выделяется определенный квант времени. И при помощи \r\nмногопоточности мы можем выделить в приложении несколько потоков, которые будут выполнять различные задачи одновременно. Если у нас, допустим, графическое приложение, которое посылает запрос к какому-нибудь \r\nсерверу или считывает и обрабатывает огромный файл, то без многопоточности у нас бы блокировался графический интерфейс на время выполнения задачи. \r\nА благодаря потокам мы можем выделить отправку запроса или любую другую задачу, которая может долго обрабатываться, в отдельный поток. Поэтому, \r\nк примеру, клиент-серверные приложения (и не только они) практически не мыслимы без многопоточности.&lt;/p&gt;\r\n&lt;p&gt;Основной функционал для использования потоков в приложении сосредоточен в пространстве имен &lt;strong&gt;System.Threading&lt;/strong&gt;. В нем определен \r\nкласс, представляющий отдельный поток - класс &lt;strong&gt;Thread&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;p&gt;Класс Thread определяет ряд методов и свойств, которые позволяют управлять потоком и получать информацию о нем. Основные свойства класса:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;ExecutionContext&lt;/strong&gt;: позволяет получить контекст, в котором выполняется поток&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;IsAlive&lt;/strong&gt;: указывает, работает ли поток в текущий момент&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;IsBackground&lt;/strong&gt;: указывает, является ли поток фоновым&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Name&lt;/strong&gt;: содержит имя потока&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;ManagedThreadId&lt;/strong&gt;: возвращает числовой идентификатор текущего потока&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Priority&lt;/strong&gt;: хранит приоритет потока - значение перечисления &lt;strong&gt;ThreadPriority&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Lowest&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;BelowNormal&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Normal&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;AboveNormal&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Highest&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;По умолчанию потоку задается значение Normal. Однако мы можем изменить приоритет в процессе работы программы. Например, повысить важность потока, \r\nустановив приоритет Highest. Среда CLR будет считывать и анализировать значения приоритета и на их основании выделять данному потоку \r\nто или иное количество времени.&lt;/p&gt;\r\n&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;ThreadState&lt;/strong&gt; возвращает состояние потока - одно из значений перечисления &lt;strong&gt;ThreadState&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Aborted&lt;/strong&gt;: поток остановлен, но пока еще окончательно не завершен&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;AbortRequested&lt;/strong&gt;: для потока вызван метод Abort, но остановка потока еще не произошла&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Background&lt;/strong&gt;: поток выполняется в фоновом режиме&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Running&lt;/strong&gt;: поток запущен и работает (не приостановлен)&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Stopped&lt;/strong&gt;: поток завершен&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;StopRequested&lt;/strong&gt;: поток получил запрос на остановку&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Suspended&lt;/strong&gt;: поток приостановлен&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;SuspendRequested&lt;/strong&gt;: поток получил запрос на приостановку&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Unstarted&lt;/strong&gt;: поток еще не был запущен&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;WaitSleepJoin&lt;/strong&gt;: поток заблокирован в результате действия методов Sleep или Join&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;В процессе работы потока его статус многократно может измениться под действием методов. Так, в самом начале еще до применения метода \r\nStart его статус имеет значение &lt;strong&gt;Unstarted&lt;/strong&gt;. Запустив поток, мы изменим его статус на &lt;strong&gt;Running&lt;/strong&gt;. \r\nВызвав метод Sleep, статус изменится на &lt;strong&gt;WaitSleepJoin&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Кроме того статическое свойство &lt;strong&gt;CurrentThread&lt;/strong&gt; класса Thread позволяет получить текущий поток&lt;/p&gt;\r\n&lt;p&gt;В программе на C# есть как минимум один поток - главный поток, в котором выполняется метод Main.&lt;/p&gt;\r\n&lt;p&gt;Например, используем вышеописанные свойства для получения информации о потоке:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nusing System.Threading;\r\n \r\n// получаем текущий поток\r\nThread currentThread = Thread.CurrentThread;\r\n \r\n//получаем имя потока\r\nConsole.WriteLine($&quot;Имя потока: {currentThread.Name}&quot;);\r\ncurrentThread.Name = &quot;Метод Main&quot;;\r\nConsole.WriteLine($&quot;Имя потока: {currentThread.Name}&quot;);\r\n \r\nConsole.WriteLine($&quot;Запущен ли поток: {currentThread.IsAlive}&quot;);\r\nConsole.WriteLine($&quot;Id потока: {currentThread.ManagedThreadId}&quot;);\r\nConsole.WriteLine($&quot;Приоритет потока: {currentThread.Priority}&quot;);\r\nConsole.WriteLine($&quot;Статус потока: {currentThread.ThreadState}&quot;);\r\n&lt;/code&gt;\r\n&lt;p&gt;В этом случае мы получим примерно следующий вывод:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Имя потока:\r\nИмя потока: Метод Main\r\nЗапущен ли поток: True\r\nId потока: 1\r\nПриоритет потока: Normal\r\nСтатус потока: Running\r\n&lt;/pre&gt;\r\n\r\n&lt;p&gt;Так как по умолчанию свойство Name у объектов Thread не установлено, то в первом случае мы получаем в качестве значения этого \r\nсвойства пустую строку.&lt;/p&gt;\r\n&lt;p&gt;Также класс Thread определяет ряд методов для управления потоком. Основные из них:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;Статический метод &lt;strong&gt;GetDomain&lt;/strong&gt; возвращает ссылку на домен приложения &lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Статический метод &lt;strong&gt;GetDomainID&lt;/strong&gt; возвращает id домена приложения, в котором выполняется текущий поток &lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Статический метод &lt;strong&gt;Sleep&lt;/strong&gt; останавливает поток на определенное количество миллисекунд&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Метод &lt;strong&gt;Interrupt&lt;/strong&gt; прерывает поток, который находится в состоянии WaitSleepJoin&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Метод &lt;strong&gt;Join&lt;/strong&gt; блокирует выполнение вызвавшего его потока до тех пор, пока не завершится поток, для которого был вызван данный метод&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Метод &lt;strong&gt;Start&lt;/strong&gt; запускает поток&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Например, применим метод Sleep для задания задержки выполнения приложения:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nusing System.Threading;\r\n \r\nfor(int i = 0; i &lt; 10; i++)\r\n{\r\n    Thread.Sleep(500);      // задержка выполнения на 500 миллисекунд\r\n    Console.WriteLine(i);\r\n}\r\n&lt;/code&gt;\r\n'),
(55, 'Создание потоков. Делегат ThreadStart', 18, 2, 2, '&lt;p&gt;Язык C# позволяет запускать и выполнять в рамках приложения несколько потоков, которые будут выполняться одновременно.&lt;/p&gt;\r\n&lt;p&gt;Для создания потока применяется один из конструкторов класса &lt;strong&gt;Thread&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Thread(ThreadStart)&lt;/strong&gt;: в качестве параметра принимает объект делегата ThreadStart, который представляет выполняемое в потоке действие&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Thread(ThreadStart, Int32)&lt;/strong&gt;: в дополнение к делегату ThreadStart принимает числовое значение, которое устанавливает размер стека, выделяемого \r\nпод данный поток&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Thread(ParameterizedThreadStart)&lt;/strong&gt;: в качестве параметра принимает объект делегата ParameterizedThreadStart, который представляет выполняемое в потоке действие&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Thread(ParameterizedThreadStart, Int32)&lt;/strong&gt;: вместе с делегатом ParameterizedThreadStart принимает числовое значение, которое устанавливает размер стека для \r\nданного потока&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;\r\n&lt;p&gt;Вне зависимости от того, какой конструктор будет применяться для создания, нам надо определить выполняемое в потоке действие. В этой статье рассмотрим использование делегата ThreadStart. \r\nЭтот делегат представляет действие, которое не принимает никаких параметров и не возвращает никакого значения:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\npublic delegate void ThreadStart();\r\n&lt;/code&gt;\r\n&lt;p&gt;То есть под этот делегат нам надо определить метод, который имеет тип void и не принимает никаких параметров. Примеры определения потоков:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nThread myThread1 = new Thread(Print); \r\nThread myThread2 = new Thread(new ThreadStart(Print));\r\nThread myThread3 = new Thread(()=&gt;Console.WriteLine(&quot;Hello Threads&quot;));\r\n \r\nvoid Print() =&gt; Console.WriteLine(&quot;Hello Threads&quot;);\r\n&lt;/code&gt;\r\n&lt;p&gt;Для запуска нового потока применяется метод &lt;strong&gt;Start&lt;/strong&gt; класса Thread:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nusing System.Threading;\r\n \r\n// создаем новый поток\r\nThread myThread1 = new Thread(Print); \r\nThread myThread2 = new Thread(new ThreadStart(Print));\r\nThread myThread3 = new Thread(()=&gt;Console.WriteLine(&quot;Hello Threads&quot;));\r\n \r\nmyThread1.Start();  // запускаем поток myThread1\r\nmyThread2.Start();  // запускаем поток myThread2\r\nmyThread3.Start();  // запускаем поток myThread3\r\n \r\nvoid Print() =&gt; Console.WriteLine(&quot;Hello Threads&quot;);\r\n&lt;/code&gt;\r\n&lt;p&gt;Преимуществом потоком является то, что они могут выполняться одновременно. Например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nusing System.Threading;\r\n \r\n// создаем новый поток\r\nThread myThread = new Thread(Print);\r\n// запускаем поток myThread\r\nmyThread.Start();\r\n \r\n// действия, выполняемые в главном потоке\r\nfor (int i = 0; i &lt; 5; i++)\r\n{\r\n    Console.WriteLine($&quot;Главный поток: {i}&quot;);\r\n    Thread.Sleep(300);\r\n}\r\n \r\n// действия, выполняемые во втором потокке\r\nvoid Print()\r\n{\r\n    for (int i = 0; i &lt; 5; i++)\r\n    {\r\n        Console.WriteLine($&quot;Второй поток: {i}&quot;);\r\n        Thread.Sleep(400);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь новый поток будет производить действия, определенные в методе Print, то есть выводить числа от 0 до 4 на консоль. Причем после каждого вывода производится задержка \r\nна 400 миллисекунд.&lt;/p&gt;\r\n&lt;p&gt;В главном потоке - в методе Main создаем и запускаем новый поток, в котором выполняется метод Print:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nThread myThread = new Thread(Print);\r\nmyThread.Start();\r\n&lt;/code&gt;\r\n&lt;p&gt;Кроме того, в главном потоке производим аналогичные действия - выводим на консоль числа от 0 до 4 с задержкой в 300 миллисекунд.&lt;/p&gt;\r\n&lt;p&gt;Таким образом, в нашей программе будут работать одновременно главный поток, представленный методом Main, и второй поток, в котором выполняется метод Print. \r\nКак только все потоки отработают, программа завершит свое выполнение. В итоге мы получим следующий консольный вывод:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Главный поток: 0\r\nВторой поток: 0\r\nГлавный поток: 1\r\nВторой поток: 1\r\nГлавный поток: 2\r\nВторой поток: 2\r\nГлавный поток: 3\r\nВторой поток: 3\r\nГлавный поток: 4\r\nВторой поток: 4\r\n&lt;/pre&gt;\r\n\r\n&lt;p&gt;Подобным образом мы можем создать и запускать и три, и четыре, и целый набор новых потоков, которые смогут решать те или иные задачи.&lt;/p&gt;'),
(56, 'Потоки с параметрами и ParameterizedThreadStart', 18, 3, 2, '&lt;p&gt;В предыдущей статье было рассмотрено, как запускать в отдельных потоках методы без параметров. А что, если нам надо передать какие-нибудь параметры в поток?&lt;/p&gt;\r\n&lt;p&gt;Для этой цели используется делегат &lt;strong&gt;ParameterizedThreadStart&lt;/strong&gt;, который передается в конструктор класса Thread:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\npublic delegate void ParameterizedThreadStart(object? obj);\r\n&lt;/code&gt; \r\n&lt;p&gt;Применение делегата ParameterizedThreadStart во многом похоже на работу с &lt;strong&gt;ThreadStart&lt;/strong&gt;. Рассмотрим на примере:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nusing System.Threading;\r\n \r\n// создаем новые потоки\r\nThread myThread1 = new Thread(new ParameterizedThreadStart(Print));\r\nThread myThread2 = new Thread(Print);\r\nThread myThread3 = new Thread(message =&gt; Console.WriteLine(message));\r\n \r\n// запускаем потоки\r\nmyThread1.Start(&quot;Hello&quot;);\r\nmyThread2.Start(&quot;Привет&quot;);\r\nmyThread3.Start(&quot;Salut&quot;);\r\n \r\n \r\nvoid Print(object? message) =&gt; Console.WriteLine(message);\r\n&lt;/code&gt;\r\n&lt;p&gt;При создании потока в конструктор класса Thread передается объект делегата ParameterizedThreadStart &lt;strong&gt;new Thread(new ParameterizedThreadStart(Print))&lt;/strong&gt;, \r\nлибо непосредственно метод, который соответствует этому делегату (&lt;strong&gt;new Thread(Print)&lt;/strong&gt;), в том числе в виде лямбда-выражения \r\n(&lt;strong&gt;new Thread(message =&gt; Console.WriteLine(message))&lt;/strong&gt;)&lt;/p&gt;\r\n&lt;p&gt;Затем при запуске потока в метод &lt;strong&gt;Start()&lt;/strong&gt; передается значение, которое передается параметру метода Print. И в данном случае мы получим следующий \r\nконсольный вывод:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Salut\r\nHello\r\nПривет\r\n&lt;/pre&gt;\r\n\r\n&lt;p&gt;При использовании ParameterizedThreadStart мы сталкиваемся с ограничением: мы можем запускать во втором потоке только такой метод, который в \r\nкачестве единственного параметра принимает объект типа &lt;strong&gt;object?&lt;/strong&gt;. Поэтому если мы хотим использовать данные других типов, в \r\nсамом методе необходимо выполнить приведение типов. Например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nusing System.Threading;\r\n \r\nint number = 4;\r\n// создаем новый поток\r\nThread myThread = new Thread(Print);\r\nmyThread.Start(number);    // n * n = 16\r\n \r\n \r\n// действия, выполняемые во втором потокке\r\nvoid Print(object? obj)\r\n{\r\n    // здесь мы ожидаем получить число\r\n    if (obj is int n)\r\n    {\r\n        Console.WriteLine($&quot;n * n = {n * n}&quot;);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;в данном случае нам надо дополнительно привести переданное значение к типу int, чтобы его использовать в вычислениях.&lt;/p&gt;\r\n&lt;p&gt;Но что делать, если нам надо передать не один, а несколько параметров различного типа? В этом случае можно определить свои типы:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nusing System.Threading;\r\n \r\nPerson tom = new Person(&quot;Tom&quot;, 37);\r\n// создаем новый поток\r\nThread myThread = new Thread(Print);\r\nmyThread.Start(tom);\r\n \r\nvoid Print(object? obj)\r\n{\r\n    // здесь мы ожидаем получить объект Person\r\n    if (obj is Person person)\r\n    {\r\n        Console.WriteLine($&quot;Name = {person.Name}&quot;);\r\n        Console.WriteLine($&quot;Age = {person.Age}&quot;);\r\n    }\r\n}\r\n \r\nrecord class Person(string Name, int Age);\r\n&lt;/code&gt;\r\n&lt;p&gt;Сначала определяем специальный класс Person, объект которого будет передаваться во второй поток, а в методе Main передаем его во второй поток.&lt;/p&gt;\r\n&lt;p&gt;Но тут опять же есть одно ограничение: метод &lt;strong&gt;Thread.Start&lt;/strong&gt; не является типобезопасным, то есть мы можем передать в него любой тип, \r\nи потом нам придется приводить переданный объект к нужному нам типу. Для решения данной проблемы рекомендуется объявлять все используемые методы \r\nи переменные в специальном классе, а в основной программе запускать поток через ThreadStart. Например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nusing System.Threading;\r\n \r\nPerson tom = new Person(&quot;Tom&quot;, 37);\r\n// создаем новый поток\r\nThread myThread = new Thread(tom.Print);\r\nmyThread.Start();\r\n \r\nrecord class Person(string Name, int Age)\r\n{\r\n    public void Print()\r\n    {\r\n        Console.WriteLine($&quot;Name = {Name}&quot;);\r\n        Console.WriteLine($&quot;Age = {Age}&quot;);\r\n    }\r\n}\r\n&lt;/code&gt;'),
(57, 'Синхронизация потоков', 18, 4, 2, '&lt;p&gt;Нередко в потоках используются некоторые разделяемые ресурсы, общие для всей программы. Это могут быть общие переменные, файлы, другие ресурсы. Например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint x = 0;\r\n \r\n// запускаем пять потоков\r\nfor (int i = 1; i &lt; 6; i++)\r\n{\r\n    Thread myThread = new(Print);\r\n    myThread.Name = $&quot;Поток {i}&quot;;   // устанавливаем имя для каждого потока\r\n    myThread.Start();\r\n}\r\n \r\nvoid Print()\r\n{\r\n    x = 1;\r\n    for (int i = 1; i &lt; 6; i++)\r\n    {\r\n        Console.WriteLine($&quot;{Thread.CurrentThread.Name}: {x}&quot;);\r\n        x++;\r\n        Thread.Sleep(100);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь у нас запускаются пять потоков, которые вызывают метод Print и которые работают с общей переменной x. \r\nИ мы предполагаем, что метод выведет все значения x от 1 до 5. И так для каждого потока. \r\nОднако в реальности в процессе работы будет происходить переключение между потоками, и значение переменной x становится непредсказуемым. \r\nНапример, в моем случае я получил следующий консольный вывод (он может в каждом конкретном случае различаться):&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Поток 1: 1\r\nПоток 5: 1\r\nПоток 4: 1\r\nПоток 2: 1\r\nПоток 3: 1\r\nПоток 1: 6\r\nПоток 5: 7\r\nПоток 3: 7\r\nПоток 2: 7\r\nПоток 4: 9\r\nПоток 1: 11\r\nПоток 4: 11\r\nПоток 2: 11\r\nПоток 3: 14\r\nПоток 5: 11\r\nПоток 1: 16\r\nПоток 2: 16\r\nПоток 3: 16\r\nПоток 5: 18\r\nПоток 4: 16\r\nПоток 1: 21\r\nПоток 5: 21\r\nПоток 3: 21\r\nПоток 2: 21\r\nПоток 4: 21\r\n&lt;/pre&gt;\r\n\r\n\r\n&lt;p&gt;Решение проблемы состоит в том, чтобы синхронизировать потоки и ограничить доступ к разделяемым ресурсам на время их использования каким-нибудь потоком. \r\nДля этого используется ключевое слово &lt;strong&gt;lock&lt;/strong&gt;. Оператор &lt;strong&gt;lock&lt;/strong&gt; определяет блок кода, внутри которого весь код блокируется и \r\nстановится недоступным для других потоков до завершения работы текущего потока. Остальный потоки помещаются в очередь ожидания и ждут, пока текущий поток \r\nне освободит данный блок кода. В итоге с помощью lock мы можем переделать предыдущий пример следующим образом:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint x = 0;\r\nobject locker = new();  // объект-заглушка\r\n// запускаем пять потоков\r\nfor (int i = 1; i &lt; 6; i++)\r\n{\r\n    Thread myThread = new(Print);\r\n    myThread.Name = $&quot;Поток {i}&quot;;\r\n    myThread.Start();\r\n}\r\n \r\n \r\nvoid Print()\r\n{\r\n    lock (locker)\r\n    {\r\n        x = 1;\r\n        for (int i = 1; i &lt; 6; i++)\r\n        {\r\n            Console.WriteLine($&quot;{Thread.CurrentThread.Name}: {x}&quot;);\r\n            x++;\r\n            Thread.Sleep(100);\r\n        }\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Для блокировки с ключевым словом lock используется объект-заглушка, в данном случае это переменная &lt;strong&gt;locker&lt;/strong&gt;. Обычно это переменная типа object. И когда выполнение доходит \r\nдо оператора lock, объект locker блокируется, и на время его блокировки монопольный доступ к блоку кода имеет только один поток. После окончания работы блока кода, \r\nобъект locker освобождается и становится доступным для других потоков.&lt;/p&gt;\r\n&lt;p&gt;В этом случае консольный вывод будет более упорядоченным:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Поток 1: 1\r\nПоток 1: 2\r\nПоток 1: 3\r\nПоток 1: 4\r\nПоток 1: 5\r\nПоток 5: 1\r\nПоток 5: 2\r\nПоток 5: 3\r\nПоток 5: 4\r\nПоток 5: 5\r\nПоток 3: 1\r\nПоток 3: 2\r\nПоток 3: 3\r\nПоток 3: 4\r\nПоток 3: 5\r\nПоток 2: 1\r\nПоток 2: 2\r\nПоток 2: 3\r\nПоток 2: 4\r\nПоток 2: 5\r\nПоток 4: 1\r\nПоток 4: 2\r\nПоток 4: 3\r\nПоток 4: 4\r\nПоток 4: 5\r\n&lt;/pre&gt;\r\n'),
(58, 'Асинхронные методы, async и await', 19, 1, 2, '&lt;p&gt;Нередко программа выполняет такие операции, которые могут занять продолжительное время, например, обращение к сетевым ресурсам, чтение-запись файлов, обращение к базе данных и т.д. \r\nТакие операции могут серьезно нагрузить приложение. Особенно это актуально в графических (десктопных или мобильных) приложениях, где продолжительные операции \r\nмогут блокировать интерфейс пользователя и негативно повлиять на желание пользователя работать с программой, или в веб-приложениях, которые должны быть готовы обслуживать \r\nтысячи запросов в секунду. В синхронном приложении при выполнении продолжительных операций в основном потоке этот поток просто бы блокировался на время \r\nвыполнения операции. И чтобы продолжительные операции не блокировали общую работу приложения, в C# можно задействовать асинхронность.&lt;/p&gt;\r\n&lt;p&gt;&lt;strong&gt;Асинхронность&lt;/strong&gt; позволяет вынести отдельные задачи из основного потока в специальные асинхронные \r\nметоды и при этом более экономно использовать потоки. Асинхронные методы выполняются в отдельных потоках. Однако при выполнении продолжительной операции \r\nпоток асинхронного метода возвратится в пул потоков и будет использоваться для других задач. А когда продолжительная операция завершит свое выполнение, \r\nдля асинхронного метода опять выделяется поток из пула потоков, и асинхронный метод продолжает свою работу.&lt;/p&gt;\r\n&lt;p&gt;Ключевыми для работы с асинхронными вызовами в C# являются два оператора: &lt;strong&gt;async&lt;/strong&gt; и &lt;strong&gt;await&lt;/strong&gt;, \r\nцель которых - упростить написание асинхронного кода. Они используются вместе для создания асинхронного метода.&lt;/p&gt;\r\n&lt;p&gt;&lt;strong&gt;Асинхронный метод&lt;/strong&gt; обладает следующими признаками:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;В заголовке метода используется модификатор &lt;strong&gt;async&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Метод содержит одно или несколько выражений &lt;strong&gt;await&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;В качестве возвращаемого типа используется один из следующих:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;void&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Task&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Task&lt;T&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;ValueTask&lt;T&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Асинхронный метод, как и обычный, может использовать любое количество параметров или не использовать их вообще. Однако асинхронный \r\nметод не может определять параметры с модификаторами &lt;strong&gt;out&lt;/strong&gt;, &lt;strong&gt;ref&lt;/strong&gt; и &lt;strong&gt;in&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;p&gt;Также стоит отметить, что слово &lt;strong&gt;async&lt;/strong&gt;, которое указывается в определении метода, НЕ делает автоматически метод \r\nасинхронным. Оно лишь указывает, что данный метод может содержать одно или несколько выражений &lt;strong&gt;await&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;p&gt;Рассмотрим простейший пример определения и вызова асинхронного метода:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nawait PrintAsync();   // вызов асинхронного метода\r\nConsole.WriteLine(&quot;Некоторые действия в методе Main&quot;);\r\n \r\nvoid Print()\r\n{\r\n    Thread.Sleep(3000);     // имитация продолжительной работы\r\n    Console.WriteLine(&quot;Hello METANIT.COM&quot;);\r\n}\r\n \r\n// определение асинхронного метода\r\nasync Task PrintAsync()\r\n{\r\n    Console.WriteLine(&quot;Начало метода PrintAsync&quot;); // выполняется синхронно\r\n    await Task.Run(() =&gt; Print());                // выполняется асинхронно\r\n    Console.WriteLine(&quot;Конец метода PrintAsync&quot;);\r\n}   \r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь прежде всего определен обычный метод Print, который просто выводит некоторую строку на консоль. Для имитации долгой работы в нем используется \r\nзадержка на 3 секунд с помощью метода &lt;strong&gt;Thread.Sleep()&lt;/strong&gt;. \r\nТо есть условно Print - это некоторый метод, который выполняет некоторую продолжительную операцию. В реальном приложении это могло бы быть обращение к базе данных или чтение-запись файлов, \r\nно для упрощения понимания он просто выводит строку на консоль.&lt;/p&gt;\r\n&lt;p&gt;Также здесь определен асинхронный метод &lt;strong&gt;PrintAsync()&lt;/strong&gt;. Асинхронным он является потому, что имеет в определении перед возвращаемым типом \r\nмодификатор &lt;strong&gt;async&lt;/strong&gt;, его возвращаемым типом является Task, и в теле метода определено выражение \r\n&lt;strong&gt;await&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;p&gt;Стоит отметить, что явным образом метод PrintAsync не возвращает никакого объекта Task, однако поскольку в теле метода применяется выражение &lt;strong&gt;await&lt;/strong&gt;, \r\nто в качестве возвращаемого типа можно использовать тип Task.&lt;/p&gt;\r\n&lt;p&gt;Оператор &lt;strong&gt;await&lt;/strong&gt; предваряет выполнение задачи, которая будет выполняться асинхронно. В данном случае \r\nподобная операция представляет выполнение метода Print:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nawait Task.Run(()=&gt;Print());\r\n&lt;/code&gt;\r\n&lt;p&gt;По негласным правилам в названии асинхроннных методов принято использовать суффикс &lt;strong&gt;Async&lt;/strong&gt; - &lt;strong&gt;Print&lt;strong&gt;Async&lt;/strong&gt;()&lt;/strong&gt;, \r\nхотя в принципе это необязательно делать.&lt;/p&gt;\r\n&lt;p&gt;И затем в программе (в данном случае в методе Main) вызывается этот асинхронный метод.&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nawait PrintAsync();   // вызов асинхронного метода\r\n&lt;/code&gt;\r\n&lt;p&gt;Посмотрим, какой у программы будет консольный вывод:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Начало метода PrintAsync\r\nHello METANIT.COM\r\nКонец метода PrintAsync\r\nНекоторые действия в методе Main\r\n&lt;/pre&gt;\r\n\r\n&lt;p&gt;Разберем поэтапно, что здесь происходит:&lt;/p&gt;\r\n&lt;ol&gt;\r\n&lt;li&gt;&lt;p&gt;Запускается программа, а точнее метод Main, в котором вызывается асинхронный метод PrintAsync.&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Метод PrintAsync начинает выполняться &lt;strong&gt;синхронно&lt;/strong&gt; вплоть до выражения await.&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nConsole.WriteLine(&quot;Начало метода PrintAsync&quot;); // выполняется синхронно\r\n&lt;/code&gt;\r\n&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Выражение await запускает асинхронную задачу &lt;strong&gt;Task.Run(()=&gt;Print())&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Пока выполняется асинхронная задача &lt;strong&gt;Task.Run(()=&gt;Print())&lt;/strong&gt; (а она может выполняться довольно продожительное время), \r\nвыполнение кода возвращается в вызывающий метод - то есть в метод Main.&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Когда асинхронная задача завершила свое выполнение (в случае выше - вывела строку через три секунды), продолжает работу асинхронный метод \r\nPrintAsync, который вызвал асинхронную задачу.&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;После завершения метода PrintAsync продолжает работу метод Main.&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ol&gt;\r\n&lt;h3&gt;Асинхронный метод Main&lt;/h3&gt;\r\n&lt;p&gt;Стоит учитывать, что оператор &lt;strong&gt;await&lt;/strong&gt; можно применять только в методе, который имеет модификатор &lt;strong&gt;async&lt;/strong&gt;. И если мы в методе Main используем \r\nоператор &lt;strong&gt;await&lt;/strong&gt;, то метод Main тоже должен быть определен как асинхронный. То есть предыдущий пример фактически будет аналогичен следующему:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Program\r\n{\r\n    async static Task Main(string[] args)\r\n    {\r\n        await PrintAsync();   // вызов асинхронного метода\r\n        Console.WriteLine(&quot;Некоторые действия в методе Main&quot;);\r\n \r\n \r\n        void Print()\r\n        {\r\n            Thread.Sleep(3000);     // имитация продолжительной работы\r\n            Console.WriteLine(&quot;Hello METANIT.COM&quot;);\r\n        }\r\n \r\n        // определение асинхронного метода\r\n        async Task PrintAsync()\r\n        {\r\n            Console.WriteLine(&quot;Начало метода PrintAsync&quot;); // выполняется синхронно\r\n            await Task.Run(() =&gt; Print());                // выполняется асинхронно\r\n            Console.WriteLine(&quot;Конец метода PrintAsync&quot;);\r\n        }\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;h3&gt;Задержка асинхронной операции и Task.Delay&lt;/h3&gt;\r\n&lt;p&gt;В асинхронных методах для остановки метода на некоторое время можно применять метод &lt;strong&gt;Task.Delay()&lt;/strong&gt;. В качестве параметра он принимает количество миллисекунд в виде \r\nзначения int, либо объект TimeSpan, который задает время задержки:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nawait PrintAsync();   // вызов асинхронного метода\r\nConsole.WriteLine(&quot;Некоторые действия в методе Main&quot;);\r\n \r\n// определение асинхронного метода\r\nasync Task PrintAsync()\r\n{\r\n    await Task.Delay(3000);     // имитация продолжительной работы\r\n    // или так\r\n    //await Task.Delay(TimeSpan.FromMilliseconds(3000));\r\n    Console.WriteLine(&quot;Hello METANIT.COM&quot;);\r\n}   \r\n&lt;/code&gt;\r\n&lt;p&gt;Причем метод &lt;strong&gt;Task.Delay&lt;/strong&gt; сам по себе представляет асинхронную операцию, поэтому к нему применяется оператор await.&lt;/p&gt;\r\n&lt;h3&gt;Преимущества асинхронности&lt;/h3&gt;\r\n&lt;p&gt;Выше приведенные примеры являются упрощением, и вряд ли их можно считать показательным. Рассмотрим другой пример:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPrintName(&quot;Tom&quot;);\r\nPrintName(&quot;Bob&quot;);\r\nPrintName(&quot;Sam&quot;);\r\n \r\nvoid PrintName(string name)\r\n{\r\n    Thread.Sleep(3000);     // имитация продолжительной работы\r\n    Console.WriteLine(name);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Данный код является синхронным и выполняет последовательно три вызова метода PrintName. Поскольку для имитации продолжительной работы в методе установлена \r\nзадержка на три секунды, то общее выполнение программы займет не менее 9 секунд. Так как каждый последующий вызов PrintName будет ждать пока завершится предыдущий.&lt;/p&gt;\r\n&lt;p&gt;Изменим в программе синхронный метод PrintName на асинхронный:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nawait PrintNameAsync(&quot;Tom&quot;);\r\nawait PrintNameAsync(&quot;Bob&quot;);\r\nawait PrintNameAsync(&quot;Sam&quot;);\r\n \r\n// определение асинхронного метода\r\nasync Task PrintNameAsync(string name)\r\n{\r\n    await Task.Delay(3000);     // имитация продолжительной работы\r\n    Console.WriteLine(name);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Вместо метода PrintName теперь вызывается три раза PrintNameAsync. Для имитации продолжительной работы в методе установлена \r\nзадержка на 3 секунды с помощью вызова &lt;strong&gt;Task.Delay(3000)&lt;/strong&gt;. И поскольку при вызовае каждого метода применяется оператор await, \r\nкоторый останавливает выполнение до завершения асинхронного метода, то общее выполнение программы опять же займет не менее 9 секунд. Тем не менее теперь выполнение \r\nасинхронных операций не блокирует основной поток.&lt;/p&gt;\r\n&lt;p&gt;Теперь оптимизируем программу:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar tomTask = PrintNameAsync(&quot;Tom&quot;);\r\nvar bobTask = PrintNameAsync(&quot;Bob&quot;);\r\nvar samTask = PrintNameAsync(&quot;Sam&quot;);\r\n \r\nawait tomTask;\r\nawait bobTask;\r\nawait samTask;\r\n// определение асинхронного метода\r\nasync Task PrintNameAsync(string name)\r\n{\r\n    await Task.Delay(3000);     // имитация продолжительной работы\r\n    Console.WriteLine(name);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае задачи фактически запускаются при определении. А оператор await применяется лишь тогда, когда нам нужно дождаться завершения асинхронных операций - \r\nто есть в конце программы. И в этом случае общее выполнение программы займет не менее 3 секунд, но гораздо меньше 9 секунд.&lt;/p&gt;\r\n\r\n&lt;h3&gt;Опеределение асинхронного лямбда-выражения&lt;/h3&gt;\r\n&lt;p&gt;Асинхронную операцию можно определить не только с помощью отдельного метода, но и с помощью лямбда-выражения:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\n// асинхронное лямбда-выражение\r\nFunc&lt;string, Task&gt; printer = async (message) =&gt;\r\n{\r\n    await Task.Delay(1000);\r\n    Console.WriteLine(message);\r\n};\r\n \r\nawait printer(&quot;Hello World&quot;);\r\nawait printer(&quot;Hello METANIT.COM&quot;);\r\n&lt;/code&gt;\r\n');
INSERT INTO `lectures` (`IDLecture`, `Name`, `IDChapter`, `SerialNumber`, `IDStatus`, `Content`) VALUES
(59, 'Возвращение результата из асинхронного метода', 19, 2, 2, '&lt;p&gt;В качестве возвращаемого типа в асинхронном методе должны использоваться типы &lt;strong&gt;void&lt;/strong&gt;, \r\n&lt;strong&gt;Task&lt;/strong&gt;, &lt;strong&gt;Task&lt;T&gt;&lt;/strong&gt; или &lt;strong&gt;ValueTask&lt;T&gt;&lt;/strong&gt;&lt;/p&gt;\r\n&lt;h3&gt;void&lt;/h3&gt;\r\n&lt;p&gt;При использовании ключевого слова void асинхронный метод ничего не возвращает:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPrintAsync(&quot;Hello World&quot;);\r\nPrintAsync(&quot;Hello METANIT.COM&quot;);\r\n \r\nConsole.WriteLine(&quot;Main End&quot;);\r\nawait Task.Delay(3000); // ждем завершения задач\r\n \r\n// определение асинхронного метода\r\nasync void PrintAsync(string message)\r\n{\r\n    await Task.Delay(1000);     // имитация продолжительной работы\r\n    Console.WriteLine(message);\r\n}   \r\n&lt;/code&gt;\r\n&lt;p&gt;Однако асинхронных void-методов следует избегать и следует использовать только там, где эти подобные методы представляют единственный возможный способ \r\nопределения асинхронного метода. Прежде всего, мы не можем применить к подобным методам оператор await. Также потому что исключения в таких методах сложно обрабатывать, так как они не могут быть перехвачены вне метода. Кроме того, \r\nподобные void-методы сложно тестировать.&lt;/p&gt;\r\n&lt;p&gt;Тем не менее есть ситуации, где без подобных методов не обойтись - например, при обработке событий:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nAccount account = new Account();\r\naccount.Added += PrintAsync;\r\n \r\naccount.Put(500);\r\n \r\nawait Task.Delay(2000); // ждем завершения\r\n \r\n// определение асинхронного метода\r\nasync void PrintAsync(object? obj, string message)\r\n{\r\n    await Task.Delay(1000);     // имитация продолжительной работы\r\n    Console.WriteLine(message);\r\n}\r\n \r\nclass Account\r\n{\r\n    int sum = 0;\r\n    public event EventHandler&lt;string&gt;? Added;\r\n    public void Put(int sum)\r\n    {\r\n        this.sum += sum;\r\n        Added?.Invoke(this, $&quot;На счет поступило {sum} $&quot;);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае событие Added в классе Account представляет делегат EventHandler, который имеет тип void. Соответственно под это событие можно определить только \r\nметод-обработчик с типом void.&lt;/p&gt;\r\n&lt;h3&gt;Task&lt;/h3&gt;\r\n&lt;p&gt;Возвращение объекта типа Task:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nawait PrintAsync(&quot;Hello Metanit.com&quot;);\r\n \r\n// определение асинхронного метода\r\nasync Task PrintAsync(string message)\r\n{\r\n    await Task.Delay(1000);     // имитация продолжительной работы\r\n    Console.WriteLine(message);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь формально метод PrintAsync не использует оператор &lt;strong&gt;return&lt;/strong&gt; для возвращения результата. Однако если в \r\nасинхронном методе выполняется в выражении await асинхронная операция, то мы можем возвращать из метода объект Task.&lt;/p&gt;\r\n&lt;p&gt;Для ожидания завершения асинхронной задачи можно применить оператор &lt;strong&gt;await&lt;/strong&gt;. Причем его необязательно использовать непосредственно при вызове \r\nзадачи. Его можно применить лишь там, где нам нужно гарантировано получить результат задачи или удостовериться, что задача завершена.&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar task = PrintAsync(&quot;Hello Metanit.com&quot;); // задача начинает выполняться\r\nConsole.WriteLine(&quot;Main Works&quot;);\r\n \r\nawait task; // ожидаем завершения задачи\r\n \r\n// определение асинхронного метода\r\nasync Task PrintAsync(string message)\r\n{\r\n    await Task.Delay(0);\r\n    Console.WriteLine(message);\r\n}\r\n&lt;/code&gt;\r\n&lt;h3&gt;Task&lt;T&gt;&lt;/h3&gt;\r\n&lt;p&gt;Метод может возвращать некоторое значение. Тогда возвращаемое значение оборачивается в объект Task, а возвращаемым \r\nтипом является &lt;strong&gt;Task&lt;T&gt;&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint n1 = await SquareAsync(5);\r\nint n2 = await SquareAsync(6);\r\nConsole.WriteLine($&quot;n1={n1}  n2={n2}&quot;); // n1=25  n2=36\r\n \r\nasync Task&lt;int&gt; SquareAsync(int n)\r\n{\r\n    await Task.Delay(0);\r\n    return n * n;\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае метод Square возвращает значение типа int - квадрат числа. Поэтому возвращаемым типом в данном случае является типа Task&lt;int&gt;.&lt;/p&gt;\r\n&lt;p&gt;Чтобы получить результат асинхронного метода применяем оператор await при вызове SquareAsync:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nint n1 = await SquareAsync(5);\r\n&lt;/code&gt;\r\n&lt;p&gt;Подобным образом можно получать данные других типов:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPerson person = await GetPersonAsync(&quot;Tom&quot;);\r\nConsole.WriteLine(person.Name); // Tom\r\n// определение асинхронного метода\r\nasync Task&lt;Person&gt; GetPersonAsync(string name)\r\n{\r\n    await Task.Delay(0);\r\n    return new Person(name);\r\n}\r\nrecord class Person(string Name);\r\n&lt;/code&gt;\r\n&lt;p&gt;Опять же получение непосредственных результатов асинхронной задачи можно отложить до того момента, когда они непосредственно нужны:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar square5 = SquareAsync(5);\r\nvar square6 = SquareAsync(6);\r\n \r\nConsole.WriteLine(&quot;Остальные действия в методе Main&quot;);\r\n \r\nint n1 = await square5;\r\nint n2 = await square6;\r\nConsole.WriteLine($&quot;n1={n1}  n2={n2}&quot;); // n1=25  n2=36\r\n \r\nasync Task&lt;int&gt; SquareAsync(int n)\r\n{\r\n    await Task.Delay(0);\r\n    var result = n * n;\r\n    Console.WriteLine($&quot;Квадрат числа {n} равен {result}&quot;);\r\n    return result;\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Пример работы программы (ввывод не детерминирован):&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Квадрат числа 5 равен 25\r\nКвадрат числа 6 равен 36\r\nОстальные действия в методе Main\r\nn1=25  n2=36\r\n&lt;/pre&gt;\r\n\r\n\r\n&lt;h3&gt;ValueTask&lt;T&gt;&lt;/h3&gt;\r\n&lt;p&gt;Использование типа ValueTask&lt;T&gt; во многом аналогично применению Task&lt;T&gt; за исключением некоторых различий в работе с памятью, \r\nпоскольку ValueTask - структура. Соответственно при использовании ValueTask можно избежать дополнительных выделений памяти. \r\nПоэтому MS рекомендует предпочитать ValueTask, а не Task.&lt;/p&gt;\r\n&lt;p&gt;Использование ValueTask:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nawait PrintAsync(&quot;Hello METANIT.COM&quot;);\r\n \r\nPerson person = await GetPersonAsync(&quot;Tom&quot;);\r\nConsole.WriteLine(person.Name); // Tom\r\n \r\n// определение асинхронного метода\r\nasync ValueTask PrintAsync(string message)\r\n{\r\n    await Task.Delay(0);\r\n    Console.WriteLine(message);\r\n}\r\n \r\n// определение асинхронного метода\r\nasync ValueTask&lt;Person&gt; GetPersonAsync(string name)\r\n{\r\n    await Task.Delay(0);\r\n    return new Person(name);\r\n}\r\nrecord class Person(string Name);\r\n&lt;/code&gt;'),
(60, 'Последовательное и параллельное выполнение. Task.WhenAll и Task.WhenAny', 19, 3, 2, '&lt;p&gt;Асинхронный метод может содержать множество выражений await. Когда система встречает в блоке \r\nкода оператор await, то выполнение в асинхронном методе останавливается, пока не завершится асинхронная задача. \r\nПосле завершения задачи управление переходит к следующему оператору await и так далее. Это позволяет вызывать асинхронные \r\nзадачи последовательно в определенном порядке. Например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nawait PrintAsync(&quot;Hello C#&quot;);\r\nawait PrintAsync(&quot;Hello World&quot;);\r\nawait PrintAsync(&quot;Hello METANIT.COM&quot;);\r\n \r\nasync Task PrintAsync(string message)\r\n{\r\n    await Task.Delay(2000);     // имитация продолжительной операции\r\n    Console.WriteLine(message);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Консольный вывод данной программы:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Hello C#\r\nHello World\r\nHello METANIT.COM\r\n&lt;/pre&gt;\r\n\r\n&lt;p&gt;То есть мы видим, что вызовы PrintAsync выполняются последовательно в том порядке, в котором они определены в коде. Каждая задача выполняется \r\nкак минимум 2 секунды, соответственно общее время выполнения трех задач будет как минимум 6 секунд. И в данном случае вывод строго детерминирован.&lt;/p&gt;\r\n&lt;p&gt;Нередко такая последовательность бывает необходима, если одна задача зависит от результатов другой.&lt;/p&gt;\r\n&lt;p&gt;Однако это не всегда необходимо. В подобном случае мы можем сразу запустить все задачи параллельно и применить оператор await там, где необходимо гарантировать \r\nзавершение выполнения задачи, например, в самом конце программы.&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\n// определяем и запускаем задачи\r\nvar task1 = PrintAsync(&quot;Hello C#&quot;);\r\nvar task2 = PrintAsync(&quot;Hello World&quot;);\r\nvar task3 = PrintAsync(&quot;Hello METANIT.COM&quot;);\r\n \r\n// ожидаем завершения задач\r\nawait task1;\r\nawait task2;\r\nawait task3;\r\n \r\nasync Task PrintAsync(string message)\r\n{\r\n    await Task.Delay(2000);     // имитация продолжительной операции\r\n    Console.WriteLine(message);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В этом случае все задачи запускаются и выполняются параллельно, соответственно общее время выполнения будет меньше 6 секунд, а консольный вывод программы недетерминирован. \r\nНапример, он может быть следующим:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Hello METANIT.COM\r\nHello C#\r\nHello World\r\n&lt;/pre&gt;\r\n\r\n&lt;p&gt;Однако .NET позволяет упростить отслеживание выполнения набора задач с помощью метода &lt;strong&gt;Task.WhenAll&lt;/strong&gt;. Этот метод принимает набор \r\nасинхронных задач и ожидает завершения всех этих задач. Этот метод является аналогом статического метода &lt;strong&gt;Task.WaitAll()&lt;/strong&gt;, однако \r\nпредназначен непосредственно для асинхронных методов и позволяет применять оператор await:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\n// определяем и запускаем задачи\r\nvar task1 = PrintAsync(&quot;Hello C#&quot;);\r\nvar task2 = PrintAsync(&quot;Hello World&quot;);\r\nvar task3 = PrintAsync(&quot;Hello METANIT.COM&quot;);\r\n \r\n// ожидаем завершения всех задач\r\nawait Task.WhenAll(task1, task2, task3);\r\n \r\nasync Task PrintAsync(string message)\r\n{\r\n    await Task.Delay(2000);     // имитация продолжительной операции\r\n    Console.WriteLine(message);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Вначале запускаются три задачи. Затем Task.WhenAll создает новую задачу, которая будет автоматически выполнена после выполнения всех предоставленных задач, то есть задач task1, task2, task3. \r\nА с помощью оператора await ожидаем ее завершения.&lt;/p&gt;\r\n&lt;p&gt;Если нам надо дождаться, когда будет выполнена хотя бы одна задача из некоторого набора задач, то можно применять метод &lt;strong&gt;Task.WhenAny()&lt;/strong&gt;. \r\nЭто аналог метода &lt;strong&gt;Task.WaitAny()&lt;/strong&gt; - он завершает выполнение, когда завершается хотя бы одна задача. Но для ожидания выполнения к Task.WhenAny() применяется \r\nоператор await:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\n// определяем и запускаем задачи\r\nvar task1 = PrintAsync(&quot;Hello C#&quot;);\r\nvar task2 = PrintAsync(&quot;Hello World&quot;);\r\nvar task3 = PrintAsync(&quot;Hello METANIT.COM&quot;);\r\n \r\n// ожидаем завершения хотя бы одной задачи\r\nawait Task.WhenAny(task1, task2, task3);\r\n \r\nasync Task PrintAsync(string message)\r\n{   \r\n    await Task.Delay(new Random().Next(1000, 2000));     // имитация продолжительной операции\r\n    Console.WriteLine(message);\r\n}\r\n&lt;/code&gt;\r\n&lt;h3&gt;Получение результата&lt;/h3&gt;\r\n&lt;p&gt;Задачи, передаваемые в &lt;strong&gt;Task.WhenAll&lt;/strong&gt; и &lt;strong&gt;Task.WhenAny&lt;/strong&gt;, могут возвращать некоторое значение. \r\nВ этом случае из методов Task.WhenAll и Task.WhenAny можно получить массив, который будет содержать результаты задач:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\n// определяем и запускаем задачи\r\nvar task1 = SquareAsync(4);\r\nvar task2 = SquareAsync(5);\r\nvar task3 = SquareAsync(6);\r\n \r\n// ожидаем завершения всех задач\r\nint[] results = await Task.WhenAll(task1, task2, task3);\r\n// получаем результаты:\r\nforeach (int result in results)\r\n    Console.WriteLine(result);\r\n \r\nasync Task&lt;int&gt; SquareAsync(int n)\r\n{\r\n    await Task.Delay(1000);\r\n    return n * n;\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае метод Square возвращает число int - квадрат передаваемого в метод числа. И переменная results будет содержать результат вызова \r\nTask.WhenAll - по сути результаты всех трех запущенных задач. Поскольку все передаваемые в Task.WhenAll задачи возвращают int, то соответственно \r\nрезультат Task.WhenAll будет представлять массив значений int.&lt;/p&gt;\r\n&lt;p&gt;Также после завершения задачи ее результат можно получить стандартным образом через свойство Result:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\n// определяем и запускаем задачи\r\nvar task1 = SquareAsync(4);\r\nvar task2 = SquareAsync(5);\r\nvar task3 = SquareAsync(6);\r\n \r\nawait Task.WhenAll(task1, task2, task3);\r\n// получаем результат задачи task2\r\nConsole.WriteLine($&quot;task2 result: {task2.Result}&quot;); // task2 result: 25\r\n \r\nasync Task&lt;int&gt; SquareAsync(int n)\r\n{\r\n    await Task.Delay(1000);\r\n    return n * n;\r\n}\r\n&lt;/code&gt;\r\n'),
(61, 'Обработка ошибок в асинхронных методах', 19, 4, 2, '&lt;p&gt;Обработка ошибок в асинхронных методах, использующих ключевые слова &lt;strong&gt;async&lt;/strong&gt; и &lt;strong&gt;await&lt;/strong&gt;, имеет свои особенности.&lt;/p&gt;\r\n&lt;p&gt;Для обработки ошибок выражение &lt;strong&gt;await&lt;/strong&gt; помещается в блок try:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ntry\r\n{\r\n    await PrintAsync(&quot;Hello METANIT.COM&quot;);\r\n    await PrintAsync(&quot;Hi&quot;);\r\n}\r\ncatch (Exception ex)\r\n{\r\n    Console.WriteLine(ex.Message);\r\n}\r\n \r\nasync Task PrintAsync(string message)\r\n{\r\n    // если длина строки меньше 3 символов, генерируем исключение\r\n    if (message.Length &lt; 3)\r\n        throw new ArgumentException($&quot;Invalid string length: {message.Length}&quot;);\r\n    await Task.Delay(100);     // имитация продолжительной операции\r\n    Console.WriteLine(message);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае асинхронный метод PrintAsync генерирует исключение ArgumentException, если методу передается строка с длиной меньше 3 символов.&lt;/p&gt;\r\n&lt;p&gt;Для обработки исключения в методе Main выражение await помещено в блок try. В итоге при выполнении \r\nвызова &lt;strong&gt;await PrintAsync(&quot;Hi&quot;)&lt;/strong&gt; будет сгенерировано исключение, \r\nчто привет к генерации исключения. Однако программа не остановит аварийно свою работу, а обработает исключение и продолжит дальнейшие вычисления.&lt;/p&gt;\r\n&lt;p&gt;Консольный вывод программы:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Hello METANIT.COM\r\nInvalid string length: 2\r\n&lt;/pre&gt;\r\n\r\n&lt;p&gt;Следует учитывать, что если асинхронный метод имеет тип void, то в этом случае исключение во вне не передается, соответственно мы не сможем обработать \r\nисключение при вызове метода:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ntry\r\n{\r\n    PrintAsync(&quot;Hello METANIT.COM&quot;);\r\n    PrintAsync(&quot;Hi&quot;);       // здесь программа сгенерирует исключение и аварийно остановится\r\n    await Task.Delay(1000); // ждем завершения задач\r\n}\r\ncatch (Exception ex)    // исключение НЕ будет обработано\r\n{\r\n    Console.WriteLine(ex.Message);\r\n}\r\n \r\nasync void PrintAsync(string message)\r\n{\r\n    // если длина строки меньше 3 символов, генерируем исключение\r\n    if (message.Length &lt; 3)\r\n        throw new ArgumentException($&quot;Invalid string length: {message.Length}&quot;);\r\n    await Task.Delay(100);     // имитация продолжительной операции\r\n    Console.WriteLine(message);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае, не смотря на то, что асинхронные методы вызываются в блоке try, исключение не будет перехвачено и обработано. В этом один из минусов применения \r\nасинхронных void-методов. Правда, в этом случае мы можем определить обработку исключения в самом асинхронном методе:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nPrintAsync(&quot;Hello METANIT.COM&quot;);\r\nPrintAsync(&quot;Hi&quot;);\r\nawait Task.Delay(1000); // ждем завершения задач\r\n \r\nasync void PrintAsync(string message)\r\n{\r\n    try\r\n    {\r\n        // если длина строки меньше 3 символов, генерируем исключение\r\n        if (message.Length &lt; 3)\r\n            throw new ArgumentException($&quot;Invalid string length: {message.Length}&quot;);\r\n        await Task.Delay(100);     // имитация продолжительной операции\r\n        Console.WriteLine(message);\r\n    }\r\n    catch (Exception ex)\r\n    {\r\n        Console.WriteLine(ex.Message);\r\n    }\r\n \r\n}\r\n&lt;/code&gt;\r\n\r\n&lt;h3&gt;Исследование исключения&lt;/h3&gt;\r\n&lt;p&gt;При возникновении ошибки у объекта Task, представляющего асинхронную задачу, в которой произошла ошибка, свойство \r\n&lt;strong&gt;IsFaulted&lt;/strong&gt; имеет значение &lt;strong&gt;true&lt;/strong&gt;. Кроме того, свойство &lt;strong&gt;Exception&lt;/strong&gt; объекта Task \r\nсодержит всю информацию об ошибке. Проинспектируем данное свойство:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nvar task = PrintAsync(&quot;Hi&quot;);\r\ntry\r\n{\r\n    await task;\r\n}\r\ncatch\r\n{\r\n    Console.WriteLine(task.Exception?.InnerException?.Message); // Invalid string length: 2\r\n    Console.WriteLine($&quot;IsFaulted: {task.IsFaulted}&quot;);  // IsFaulted: True\r\n    Console.WriteLine($&quot;Status: {task.Status}&quot;);        // Status: Faulted\r\n}\r\n \r\nasync Task PrintAsync(string message)\r\n{\r\n    // если длина строки меньше 3 символов, генерируем исключение\r\n    if (message.Length &lt; 3)\r\n        throw new ArgumentException($&quot;Invalid string length: {message.Length}&quot;);\r\n    await Task.Delay(1000);     // имитация продолжительной операции\r\n    Console.WriteLine(message);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;И если мы передадим в метод строку с длиной меньше 3 символов, то &lt;strong&gt;task.IsFaulted&lt;/strong&gt; будет равно true.&lt;/p&gt;\r\n&lt;h3&gt;Обработка нескольких исключений. WhenAll&lt;/h3&gt;\r\n&lt;p&gt;Если мы ожидаем выполнения сразу нескольких задач, например, с помощью &lt;strong&gt;Task.WhenAll&lt;/strong&gt;, то мы можем получить сразу несколько исключений одномоментно \r\nдля каждой выполняемой задачи. В этом случае мы можем получить все исключения из свойства &lt;strong&gt;Exception.InnerExceptions&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\n// определяем и запускаем задачи\r\nvar task1 = PrintAsync(&quot;H&quot;);\r\nvar task2 = PrintAsync(&quot;Hi&quot;);\r\nvar allTasks = Task.WhenAll(task1, task2);\r\ntry\r\n{\r\n    await allTasks;\r\n}\r\ncatch (Exception ex)\r\n{\r\n    Console.WriteLine($&quot;Exception: {ex.Message}&quot;);\r\n    Console.WriteLine($&quot;IsFaulted: {allTasks.IsFaulted}&quot;);\r\n    if(allTasks.Exception is not null)\r\n    {\r\n        foreach (var exception in allTasks.Exception.InnerExceptions)\r\n        {\r\n            Console.WriteLine($&quot;InnerException: {exception.Message}&quot;);\r\n        }\r\n    }\r\n}\r\n \r\nasync Task PrintAsync(string message)\r\n{\r\n    // если длина строки меньше 3 символов, генерируем исключение\r\n    if (message.Length &lt; 3)\r\n        throw new ArgumentException($&quot;Invalid string: {message}&quot;);\r\n    await Task.Delay(1000);     // имитация продолжительной операции\r\n    Console.WriteLine(message);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь в два вызова метода PrintAsync передаются заведомо некорректные значения. Таким образом, при обоих вызовах будет сгенерирована ошибка.&lt;/p&gt;\r\n&lt;p&gt;Хотя блок &lt;strong&gt;catch&lt;/strong&gt; через переменную &lt;strong&gt;Exception ex&lt;/strong&gt; будет получать одно перехваченное исключение, но с помощью \r\nколлекции &lt;strong&gt;Exception.InnerExceptions&lt;/strong&gt; мы сможем получить информацию обо всех возникших исключениях.&lt;/p&gt;\r\n&lt;p&gt;В итоге при выполнении этого метода мы получим следующий консольный вывод:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Exception: Invalid string: H\r\nIsFaulted: True\r\nInnerException: Invalid string: H\r\nInnerException: Invalid string: Hi\r\n&lt;/pre&gt;\r\n'),
(62, 'Асинхронные стримы', 19, 5, 2, '&lt;p&gt;Начиная с версии C# 8.0 в C# были добавлены &lt;strong&gt;асинхронные стримы&lt;/strong&gt;, которые упрощают работу со потоками данных в \r\nасинхронном режиме. Хотя асинхронность в C# существует уже довольно давно, тем не менее асинхронные методы до сих пор позволяли получать один объект, когда асинхронная операция \r\nбыла готова предоставить результат. Для возвращения нескольких значений в C# могут применяться итераторы, но они имеют синхронную природу, блокируют вызывающий поток и не могут использоваться в асинхронном контексте. \r\nАсинхронные стримы обходят эту  проблему, позволяя получать множество значений и возвращать их по мере готовности в асинхронном режиме.&lt;/p&gt;\r\n&lt;p&gt;По сути асинхронный стрим представляет метод, который обладает тремя характеристиками:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;метод имеет модификатор &lt;strong&gt;async&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;метод возращает объект &lt;strong&gt;IAsyncEnumerable&lt;T&gt;&lt;/strong&gt;. Интерфейс IAsyncEnumerable определяет метод GetAsyncEnumerator, \r\nкоторый возвращает IAsyncEnumerator:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\npublic interface IAsyncEnumerable&lt;out T&gt;\r\n{\r\n    IAsyncEnumerator&lt;T&gt; GetAsyncEnumerator(CancellationToken cancellationToken = default);\r\n}\r\n \r\npublic interface IAsyncEnumerator&lt;out T&gt; : IAsyncDisposable\r\n{\r\n    T Current { get; }\r\n    ValueTask&lt;bool&gt; MoveNextAsync();\r\n}\r\npublic interface IAsyncDisposable\r\n{\r\n    ValueTask DisposeAsync();\r\n}\r\n&lt;/code&gt;\r\n&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;метод содержит выражения &lt;strong&gt;yield return&lt;/strong&gt; для последовательного получения элементов из асинхронного стрима&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Фактически асинхронный стрим объединяет асинхронность и итераторы. Рассмотрим простейший пример:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nawait foreach (var number in GetNumbersAsync())\r\n{\r\n    Console.WriteLine(number);\r\n}\r\n \r\nasync IAsyncEnumerable&lt;int&gt; GetNumbersAsync()\r\n{\r\n    for (int i = 0; i &lt; 10; i++)\r\n    {\r\n        await Task.Delay(100);\r\n        yield return i;\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Итак, метод &lt;strong&gt;GetNumbersAsync()&lt;/strong&gt; фактически и представляет асинхронный стрим. Этот метод является асинхронным. Его возвращаемый тип - \r\n&lt;strong&gt;IAsyncEnumerable&lt;int&gt;&lt;/strong&gt;. А его суть сводится к тому, что он возвращает с помощью &lt;strong&gt;yield return&lt;/strong&gt; каждые 100 миллисекунд \r\nнекоторое число. То есть фактически метод должен вернуть 10 чисел от 0 до 9 с промежутком в 100 миллисекунд.&lt;/p&gt;\r\n&lt;p&gt;Для получения данных из стрима в методе Main используется цикл foreach:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nawait foreach (var number in GetNumbersAsync())\r\n&lt;/code&gt;\r\n&lt;p&gt;Важно отметить, что он предваряется оператором &lt;strong&gt;await&lt;/strong&gt;. В итоге, каждый раз когда асинхронный стрим будет возвращать очередное число, цикл будет его получать и выводить на консоль.&lt;/p&gt;\r\n&lt;p&gt;Где можно применять асинхронные стримы? Асинхронные стримы могут применяться для получения данных из какого-нибудь внешнего хранилища. Например, \r\nпусть имеется следующий класс некоторого хранилища:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Repository\r\n{\r\n    string[] data = { &quot;Tom&quot;, &quot;Sam&quot;, &quot;Kate&quot;, &quot;Alice&quot;, &quot;Bob&quot; };\r\n    public async IAsyncEnumerable&lt;string&gt; GetDataAsync()\r\n    {\r\n        for (int i = 0; i &lt; data.Length; i++)\r\n        {\r\n            Console.WriteLine($&quot;Получаем {i + 1} элемент&quot;);\r\n            await Task.Delay(500);\r\n            yield return data[i];\r\n        }\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Для упрощения примера данные здесь представлены в виде простого внутреннего массива строк. Для имитации задержки в получении применяется метод Task.Delay.&lt;/p&gt;\r\n&lt;p&gt;Получим эти данные в программе:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nRepository repo = new Repository();\r\nIAsyncEnumerable&lt;string&gt; data = repo.GetDataAsync();\r\nawait foreach (var name in data)\r\n{\r\n    Console.WriteLine(name);\r\n}\r\n \r\nclass Repository\r\n{\r\n    string[] data = { &quot;Tom&quot;, &quot;Sam&quot;, &quot;Kate&quot;, &quot;Alice&quot;, &quot;Bob&quot; };\r\n    public async IAsyncEnumerable&lt;string&gt; GetDataAsync()\r\n    {\r\n        for (int i = 0; i &lt; data.Length; i++)\r\n        {\r\n            Console.WriteLine($&quot;Получаем {i + 1} элемент&quot;);\r\n            await Task.Delay(500);\r\n            yield return data[i];\r\n        }\r\n    }\r\n}\r\n&lt;/code&gt;'),
(63, 'DLR в C#. Ключевое слово dynamic', 20, 1, 2, '&lt;p&gt;Хотя C# относится к статически типизированным языкам, в последних версиях языка были добавлены некоторые динамические возможности. Так, начиная с .NET 4.0 \r\nбыла добавлена новая функциональность под названием DLR (Dynamic Language Runtime). DLR представляет среду выполнения динамических языков, \r\nнапример, таких языков как IronPython и IronRuby.&lt;/p&gt;\r\n&lt;p&gt;Чтобы понять значение данного нововведение, нужно осознавать разичие между языками со статической и динамической типизицией. В языках со \r\nстатической типизацией выявление всех типов и их членов - свойств и методов происходит на этапе компиляции. А в динамических языках системе ничего не известно о свойствах \r\nи методах типов вплоть до выполнения.&lt;/p&gt;\r\n&lt;p&gt;Благодаря этой среде DLR C# может создавать динамические объекты, члены которых выявляются на этапе выполнения программы, и использовать их вместе с традиционными объектами со статической типизацией.&lt;/p&gt;\r\n&lt;p&gt;Ключевым моментом использования DLR в C# является применение типов &lt;strong&gt;dynamic&lt;/strong&gt;. Это ключевое слово позволяет опустить \r\nпроверку типов во время компиляции. Кроме того, объекты, объявленные как dynamic, могут в течение работы программы менять свой тип. Например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ndynamic obj = 3;            // здесь obj - целочисленное int\r\nConsole.WriteLine(obj);     // 3\r\n \r\nobj = &quot;Hello world&quot;;        // obj - строка\r\nConsole.WriteLine(obj);     // Hello world\r\n \r\nobj = new Person(&quot;Tom&quot;, 37); // obj - объект Person\r\nConsole.WriteLine(obj);      // Person { Name = Tom, Age = 37 }\r\n \r\nrecord class Person(string Name, int Age);\r\n&lt;/code&gt;\r\n&lt;p&gt;Несмотря на то, что переменная x меняет тип своего значения несколько раз, данный код будет нормально работать. В этом использование типов dynamic \r\nотличается от применения ключевого слова &lt;strong&gt;var&lt;/strong&gt;. Для переменной, объявленной с помощью ключевого слова &lt;strong&gt;var&lt;/strong&gt;, \r\nтип выводится во время компиляции и затем во время выполнения больше не меняется.&lt;/p&gt;\r\n&lt;p&gt;Также можно найти общее между использованием &lt;strong&gt;dynamic&lt;/strong&gt; и типом object. Если в предыдущем примере мы заменим dynamic на object: \r\n&lt;strong&gt;object x = 3;&lt;/strong&gt;, то результат будет тот же. Однако и тут есть различия. Например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nobject obj = 24;\r\ndynamic dyn = 24;\r\nobj += 4; // так нельзя\r\ndyn += 4; // а так можно\r\n&lt;/code&gt;\r\n&lt;p&gt;На строке &lt;strong&gt;obj += 4;&lt;/strong&gt; мы увидим ошибку, так как операция += не может быть применена к типам object и int. С переменной, объявленной \r\nкак dynamic, это пройдет, так как ее тип будет известен только во время выполнения.&lt;/p&gt;\r\n&lt;p&gt;Еще одна отличительная особенность использования dynamic состоит в том, что это ключевое слово применяется не только к переменным, но и к свойствам и методам. Например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nclass Person\r\n{\r\n    public string Name { get;}\r\n    public dynamic Age { get; set; }\r\n    public Person(string name, dynamic age)\r\n    {\r\n        Name = name; Age = age;\r\n    }\r\n \r\n    // выводим зарплату в зависимости от переданного формата\r\n    public dynamic GetSalary(dynamic value, string format)\r\n    {\r\n        if (format == &quot;string&quot;) return $&quot;{value} euro&quot;;\r\n        else if (format == &quot;int&quot;) return value;\r\n        else return 0.0;\r\n    }\r\n \r\n    public override string ToString() =&gt; $&quot;Name: {Name}  Age: {Age}&quot;;\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В классе Person определено динамическое свойство Age, поэтому при задании значения этому свойству мы можем написать и &lt;strong&gt;person.Age=22&lt;/strong&gt;, и \r\n&lt;strong&gt;person.Age=&quot;twenty-two&quot;&lt;/strong&gt;. Оба варианта будут допустимыми. А через параметр age в конструкторе этому свойству можно передать любое значение.&lt;/p&gt;\r\n&lt;p&gt;Также есть метод &lt;strong&gt;GetSalary&lt;/strong&gt;, который возвращает значение dynamic. Например, в зависимости от параметра мы можем вернуть или строковое представление \r\nсуммы дохода или численное. Также метод принимает dynamic в качестве параметра. Таким образом, мы можем передать в качестве значения дохода как целое, так и дробное число или строку. \r\nПосмотрим на конкретное применение:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ndynamic tom = new Person(&quot;Tom&quot;, 22);\r\nConsole.WriteLine(tom);\r\nConsole.WriteLine(tom.GetSalary(28, &quot;int&quot;));\r\n \r\ndynamic bob = new Person(&quot;Bob&quot;, &quot;twenty-two&quot;);\r\nConsole.WriteLine(bob);\r\nConsole.WriteLine(bob.GetSalary(&quot;twenty-eight&quot;, &quot;string&quot;));\r\n&lt;/code&gt;\r\n&lt;p&gt;Консольный вывод программы:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Name: Tom  Age: 22\r\n28\r\nName: Bob  Age: twenty-two\r\ntwenty-eight euro\r\n&lt;/pre&gt;\r\n'),
(64, 'DynamicObject и ExpandoObject', 20, 2, 2, '&lt;p&gt;Интересные возможности при разработке в C# и .NET с использованием DLR предоставляет пространство имен &lt;strong&gt;System.Dynamic&lt;/strong&gt; и в частности класс &lt;strong&gt;ExpandoObject&lt;/strong&gt;. \r\nОн позволяет создавать динамические объекты, наподобие тех, что используются в javascript:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\n// определяем объект, который будет хранять ряд значений\r\ndynamic person = new System.Dynamic.ExpandoObject();\r\nperson.Name = &quot;Tom&quot;;\r\nperson.Age = 46;\r\nperson.Languages = new List&lt;string&gt; { &quot;english&quot;, &quot;german&quot;, &quot;french&quot; };\r\n \r\nConsole.WriteLine($&quot;{person.Name} - {person.Age}&quot;);\r\nforeach (var lang in person.Languages)\r\n    Console.WriteLine(lang);\r\n \r\n// объявляем метод\r\nperson.IncrementAge = (Action&lt;int&gt;)(x =&gt; person.Age += x);\r\nperson.IncrementAge(6); // увеличиваем возраст на 6 лет\r\nConsole.WriteLine($&quot;{person.Name} - {person.Age}&quot;);\r\n&lt;/int&gt;&lt;/string&gt;\r\n&lt;/code&gt;\r\n&lt;p&gt;Консольный вывод:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Tom - 46\r\nenglish\r\ngerman\r\nfrench\r\nTom - 52\r\n&lt;/pre&gt;\r\n\r\n&lt;p&gt;У динамического объекта ExpandoObject можно объявить любые свойства, например, Name, Age, Languages, которые могут представлять самые различные объекты. \r\nКроме того, можно задать методы с помощью делегатов.&lt;/p&gt;\r\n&lt;h3&gt;DynamicObject&lt;/h3&gt;\r\n&lt;p&gt;На ExpandoObject по своему действию похож другой класс - &lt;strong&gt;DynamicObject&lt;/strong&gt;. Он также позволяет задавать динамические объекты, но \r\nприменяется в более изощренных и сложных ситуациях и когда необходим больший контроль над динамическими объектами. Тогда как \r\nExpandoObject больше подходит для простых ситуаций, где не требуется определять какие-то специфические операции или статические компоненты.&lt;/p&gt;\r\n&lt;p&gt;Для использования &lt;strong&gt;DynamicObject&lt;/strong&gt; надо создать свой класс, унаследовав его от DynamicObject и реализовав его методы:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;TryBinaryOperation()&lt;/strong&gt;: выполняет бинарную операцию между двумя объектами. Эквивалентно стандартным бинарным операциям, например, \r\nсложению &lt;strong&gt;x + y&lt;/strong&gt;)&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;TryConvert()&lt;/strong&gt;: выполняет преобразование к определенному типу. Эквивалентно базовому преобразованию в C#, например, &lt;strong&gt;(SomeType) obj&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;TryCreateInstance()&lt;/strong&gt;: создает экземпляр объекта&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;TryDeleteIndex()&lt;/strong&gt;: удаляет индексатор&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;TryDeleteMember()&lt;/strong&gt;: удаляет свойство или метод&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;TryGetIndex()&lt;/strong&gt;: получает элемент по индексу через индексатор. В C# может быть эквивалентно следующему выражению &lt;strong&gt;int x = collection[i]&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;TryGetMember()&lt;/strong&gt;: получаем значение свойства. Эквивалентно обращению к свойству, например, &lt;strong&gt;string n = person.Name&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;TryInvoke()&lt;/strong&gt;: вызов объекта в качестве делегата&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;TryInvokeMember()&lt;/strong&gt;: вызов метода&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;TrySetIndex()&lt;/strong&gt;: устанавливает элемент по индексу через индексатор. В C# может быть эквивалентно следующему выражению &lt;strong&gt;collection[i] = x;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;TrySetMember()&lt;/strong&gt;: устанавливает свойство. Эквивалентно присвоению свойству значения, например: &lt;strong&gt;person.Name = &quot;Tom&quot;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;TryUnaryOperation()&lt;/strong&gt;: выполняет унарную операцию подобно унарным операциям в C#: &lt;strong&gt;x++&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Каждый из этих методов имеет одну и ту же модель определения: все они возвращают логическое значение, показывающее, удачно ли прошла операция. В качестве \r\nпервого параметра все они принимают объект связывателя или binder. Если метод представляет вызов индексатора или метода объекта, которые могут принимать параметры, \r\nто в качестве второго параметра используется массив &lt;strong&gt;object[]&lt;/strong&gt; - он хранит переданные в метод или индексатор аргументы.&lt;/p&gt;\r\n&lt;p&gt;Почти все операции, кроме установки и удаления свойств и индексаторов, возвращают определенное значение (например, если мы получаем значение свойства). \r\nВ этом случае применяется третий параметр &lt;strong&gt;out object vaue&lt;/strong&gt;, который предназначен для хранения возвращаемого объекта.&lt;/p&gt;\r\n&lt;p&gt;Например, определение метода &lt;strong&gt;TryInvokeMember()&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\npublic virtual bool TryInvokeMember (InvokeMemberBinder binder, object?[]? args, out object? result)\r\n&lt;/code&gt;\r\n&lt;p&gt;Параметр &lt;strong&gt;InvokeMemberBinder binder&lt;/strong&gt; является связывателем - получает свойства и методы объекта, &lt;strong&gt;object?[]? args&lt;/strong&gt; хранит передаваемые аргументы, \r\n&lt;strong&gt;out object? result&lt;/strong&gt; предназначен для хранения выходного результата.&lt;/p&gt;\r\n&lt;p&gt;Рассмотрим на примере. Создадим класс динамического объекта:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nusing System.Dynamic;\r\n \r\nclass PersonObject : DynamicObject\r\n{\r\n    // словарь для хранения всех свойств\r\n    Dictionary&lt;string, object&gt; members = new Dictionary&lt;string, object&gt;();\r\n \r\n    // установка свойства\r\n    public override bool TrySetMember(SetMemberBinder binder, object? value)\r\n    {\r\n        if(value is not null)\r\n        {\r\n            members[binder.Name] = value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // получение свойства\r\n    public override bool TryGetMember(GetMemberBinder binder, out object? result)\r\n    {\r\n        result = null;\r\n        if (members.ContainsKey(binder.Name))\r\n        {\r\n            result = members[binder.Name];\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // вызов метода\r\n    public override bool TryInvokeMember(InvokeMemberBinder binder, object?[]? args, out object? result)\r\n    {\r\n        result = null;\r\n        if(args?[0] is int number)\r\n        {\r\n            // получаем метод по имен\r\n            dynamic method = members[binder.Name];\r\n            // вызываем метод, передавая его параметру значение args?[0]\r\n            result = method(number);\r\n        }\r\n        // если result не равен null, то вызов метода прошел успешно\r\n        return result != null;\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Класс наследуется от DynamicObject, так как непосредственно создавать объекты DynamicObject мы не можем. И также здесь переопределяется три \r\nунаследованных метода.&lt;/p&gt;\r\n&lt;p&gt;Для хранения всех членов класса, как свойств, так и методов, определен словарь &lt;strong&gt;Dictionary&lt;string, object&gt; members&lt;/strong&gt;. \r\nКлючами здесь являются названия свойств и методов, а значениями - значения этих свойств.&lt;/p&gt;\r\n&lt;p&gt;В методе &lt;strong&gt;TrySetMember()&lt;/strong&gt; производится установка свойства:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nbool TrySetMember(SetMemberBinder binder, object? value)\r\n&lt;/code&gt;\r\n&lt;p&gt;Параметр binder хранит название устанавливаемого свойства (binder.Name), а value - значение, которое ему надо установить.&lt;/p&gt;\r\n&lt;p&gt;Для получения значения свойства переопределен метод &lt;strong&gt;TryGetMember&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nbool TryGetMember(GetMemberBinder binder, out object? result)\r\n&lt;/code&gt;\r\n&lt;p&gt;Опять же binder содержит название свойства, а параметр result будет содержать значение получаемого свойства.&lt;/p&gt;\r\n&lt;p&gt;Для вызова методов определен метод &lt;strong&gt;TryInvokeMember&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\npublic override bool TryInvokeMember(InvokeMemberBinder binder, object?[]? args, out object? result)\r\n{\r\n    result = null;\r\n    if(args?[0] is int number)\r\n    {\r\n        // получаем метод по имен\r\n        dynamic method = members[binder.Name];\r\n        // вызываем метод, передавая его параметру значение args?[0]\r\n        result = method(number);\r\n    }\r\n    // если result не равен null, то вызов метода прошел успешно\r\n    return result != null;\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Сначала с помощью bindera получаем метод и затем передаем ему аргумент &lt;strong&gt;args[0]&lt;/strong&gt;, предварительно приведя его к типу int, и \r\nрезультат метода устанавливаем в параметре result. То есть в данном случае подразумевается, что метод будет принимать один параметр типа int и \r\nвозвращать какой-то результат. Если метод возвращает true, то будем считать, что вызов метод прошел успешно.&lt;/p&gt;\r\n&lt;p&gt;Теперь применим класс в программе:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nusing System.Dynamic;\r\n \r\n// создаем объект\r\ndynamic person = new PersonObject();\r\n// устанавливаем ряд свойств\r\nperson.Name = &quot;Tom&quot;;\r\nperson.Age = 23;\r\n// определяем метод для изменения свойства Age\r\nFunc&lt;int, int&gt; increment = (int n) =&gt; { person.Age += n; return person.Age; };\r\nperson.IncrementAge = increment;\r\n \r\nConsole.WriteLine($&quot;{person.Name} - {person.Age}&quot;); // Tom - 23\r\nperson.IncrementAge(4); // применяем метод\r\nConsole.WriteLine($&quot;{person.Name} - {person.Age}&quot;); // Tom - 27\r\n&lt;/code&gt;\r\n&lt;p&gt;Выражение &lt;strong&gt;person.Name = &quot;Tom&quot;&lt;/strong&gt; будет вызывать метод &lt;strong&gt;TrySetMember&lt;/strong&gt;, в который в качестве второго параметра будет передаваться строка &quot;Tom&quot;.&lt;/p&gt;\r\n&lt;p&gt;Выражение &lt;strong&gt;return person.Age;&lt;/strong&gt; вызывает метод &lt;strong&gt;TryGetMember&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;p&gt;Также у объекта person определен метод &lt;strong&gt;IncrementAge&lt;/strong&gt;, который представляет действия лямбда-выражения \r\n&lt;strong&gt;(int n) =&gt; { person.Age += n; return person.Age; };&lt;/strong&gt;. Это выражение принимает число n, увеличивает на это число свойство Age и возвращает новое значение person.Age. \r\nИ при вызове этого метода будет происходить обращение к методу &lt;strong&gt;TryInvokeMember&lt;/strong&gt;. И, таким образом, произойдет приращение значения свойства person.Age.&lt;/p&gt;'),
(65, 'Использование IronPython в .NET', 20, 3, 2, '&lt;p&gt;Одним из ключевых достоинств среды DLR является поддержка таких динамических языков как &lt;strong&gt;IronPython&lt;/strong&gt; и \r\n&lt;strong&gt;IronRuby&lt;/strong&gt;. Казалось бы, зачем нам нужны еще языки, тем более которые применяются в рамках другого языка C#?&lt;/p&gt;\r\n&lt;p&gt;На самом деле динамические языки, возможно, не часто используются, однако есть сферы, где их применение является целесообразным. Например, \r\nнаписание клиентских сценариев. Возможно, пользователь нашей программы захочет внести какое-то дополнительное поведение в программу и для этого может \r\nиспользоваться IronPython. Можно даже сказать, что создание клиентских сценариев широко распространено в наши дни, многие программы и даже игры \r\nподдерживают добавление клиентских сценариев, написанных на различных языках.&lt;/p&gt;\r\n&lt;p&gt;Кроме того, возможно, есть библиотеки на Python, функциональность которых может отсутствовать в .NET. И в этом случае опять же нам может помочь IronPython.&lt;/p&gt;\r\n&lt;p&gt;Рассмотрим на примере применение IronPython. Но для начала необходимо добавить в проект несколько пакетов через пакетный менеджер NuGet. Для \r\nтого нажмем в окне проекта на узел &lt;strong&gt;Dependencies&lt;/strong&gt; правой кнопкой мыши и выберем в появившемся списке пункт &lt;strong&gt;Manage NuGet Packages...&lt;/strong&gt; (Управление NuGet-пакетами):&lt;/p&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/9.1.png&quot; alt=&quot;Пакетный менеджер NuGet в Visual Studio&quot;&gt;\r\n&lt;p&gt;И перед нами откроется окно пакетного менеджера. Чтобы найти нужный пакет, введем в поле поиска &quot;DLR&quot;, и менеджер отобразит ряд результатов, из которых \r\nпервый - пакет &lt;strong&gt;DynamicLanguageRuntime&lt;/strong&gt; необходимо установить.&lt;/p&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/9.2.png&quot; alt=&quot;Пакет DynamicLanguageRuntime в NuGet&quot;&gt;\r\n&lt;p&gt;После этого в проект в узел Dependencies добавляется библиотека &lt;strong&gt;Microsoft.Scripting&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;p&gt;Теперь также нам надо добавить пакет &lt;strong&gt;IronPython&lt;/strong&gt;. Для этого введем в поле поиска &quot;IronPython&quot; и после этого установим одноименный \r\nпакет:&lt;/p&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/9.3.png&quot; alt=&quot;Пакет IronPython в NuGet&quot;&gt;\r\n&lt;p&gt;После установки пакета в узле Dependencies добавляется библиотека IronPython.&lt;/p&gt;\r\n&lt;p&gt;Теперь напишем примитивную программу:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nusing IronPython.Hosting;\r\nusing Microsoft.Scripting.Hosting;\r\n \r\nScriptEngine engine = Python.CreateEngine();\r\nengine.Execute(&quot;print(&#039;hello, world&#039;)&quot;);\r\n&lt;/code&gt;\r\n&lt;p&gt;Консольный вывод:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;hello, world\r\n&lt;/pre&gt;\r\n\r\n&lt;p&gt;Здесь используется выражение &lt;strong&gt;print(&#039;hello, world&#039;)&lt;/strong&gt; языка Python, которое выводит на консоль строку. Для создания движка, выполняющего скрипт, \r\nприменяется класс &lt;strong&gt;ScriptEngine&lt;/strong&gt;. А его метод &lt;strong&gt;Execute()&lt;/strong&gt; выполняет скрипт.&lt;/p&gt;\r\n&lt;p&gt;Мы также могли бы определить файл &lt;strong&gt;hello.py&lt;/strong&gt;, то есть обычный текстовый файл с кодом на языке Python, со следующим содержимым:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nprint (&quot;hello, metanit.com&quot;)\r\n&lt;/code&gt;\r\n&lt;p&gt;И запустить его в программе:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nusing IronPython.Hosting;\r\nusing Microsoft.Scripting.Hosting;\r\n \r\nScriptEngine engine = Python.CreateEngine();\r\nengine.ExecuteFile(&quot;hello.py&quot;);\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае предполагается, что скрипт находится в проекте:&lt;/p&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/9.4.png&quot; alt=&quot;файл с кодом Python в проекте на C#&quot;&gt;\r\n&lt;p&gt;Также можно использовать абсолютные пути, например, если скрипт располагается по пути &quot;D://hello.py&quot;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nScriptEngine engine = Python.CreateEngine();\r\nengine.ExecuteFile(&quot;D://hello.py&quot;);\r\n&lt;/code&gt;\r\n&lt;h3&gt;ScriptScope&lt;/h3&gt;\r\n&lt;p&gt;Объект ScriptScope позволяет взаимодействовать со скриптом, получая или устанавливая его переменные, получая ссылки на функции. Например, \r\nнапишем простейший скрипт &lt;strong&gt;hello2.py&lt;/strong&gt;, который использует переменные:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nx = 10\r\nz = x + y\r\nprint(z)\r\n&lt;/code&gt;\r\n&lt;p&gt;Теперь напишем программу, которая будет взаимодействовать со скриптом:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nusing IronPython.Hosting;\r\nusing Microsoft.Scripting.Hosting;\r\n \r\nint y = 22;\r\n \r\nScriptEngine engine = Python.CreateEngine();\r\nScriptScope scope = engine.CreateScope();\r\nscope.SetVariable(&quot;y&quot;, y);\r\nengine.ExecuteFile(&quot;hello.py&quot;, scope);\r\ndynamic x = scope.GetVariable(&quot;x&quot;);\r\ndynamic z = scope.GetVariable(&quot;z&quot;);\r\nConsole.WriteLine($&quot;{x} + {y} = {z}&quot;);\r\n&lt;/code&gt;\r\n&lt;p&gt;Объект ScriptScope с  помощью метода &lt;strong&gt;SetVariable&lt;/strong&gt; позволяет установить переменные в скрипте, а с помощью метода &lt;strong&gt;GetVariable()&lt;/strong&gt; - \r\nполучить их.&lt;/p&gt;\r\n&lt;p&gt;Консольный вывод:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;32\r\n10 + 22 = 32\r\n&lt;/pre&gt;\r\n\r\n&lt;h3&gt;Вызов функций из IronPython&lt;/h3&gt;\r\n&lt;p&gt;Определим в файле &lt;strong&gt;hello.py&lt;/strong&gt; функцию для вычисления квадрата числа:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\ndef square(n):\r\n   return n * n\r\n&lt;/code&gt;\r\n&lt;p&gt;Теперь обратимся к этой функции в коде C#:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nusing IronPython.Hosting;\r\nusing Microsoft.Scripting.Hosting;\r\n \r\nint number = 5;\r\n \r\nScriptEngine engine = Python.CreateEngine();\r\nScriptScope scope = engine.CreateScope();\r\n \r\nengine.ExecuteFile(&quot;hello.py&quot;, scope);\r\ndynamic square = scope.GetVariable(&quot;square&quot;);\r\n// вызываем функцию и получаем результат\r\ndynamic result = square(number);\r\nConsole.WriteLine(result);      // 25\r\n&lt;/code&gt;\r\n&lt;p&gt;Получить объект функции можно также, как и переменную: &lt;strong&gt;scope.GetVariable(&quot;square&quot;);&lt;/strong&gt;. Затем с этим объектом работаем также, как и с \r\nлюбым другим методом. В итоге при передаче в метод/функцию square числа 5 его результатом будет 25.&lt;/p&gt;');
INSERT INTO `lectures` (`IDLecture`, `Name`, `IDChapter`, `SerialNumber`, `IDStatus`, `Content`) VALUES
(66, 'Работа с файловой системой', 21, 1, 2, '&lt;p&gt;Большинство задач в программировании так или иначе связаны с работой с файлами и каталогами. Нам может потребоваться прочитать текст из \r\nфайла или наоборот произвести запись, удалить файл или целый каталог, не говоря уже о более комплексных задачах, как например, создание текстового редактора \r\nи других подобных задачах.&lt;/p&gt;\r\n&lt;p&gt;Фреймворк .NET предоставляет большие возможности по управлению и манипуляции файлами и каталогами, которые по большей части сосредоточены в \r\nпространстве имен &lt;strong&gt;System.IO&lt;/strong&gt;. Классы, расположенные в этом пространстве имен (такие как Stream, StreamWriter, FileStream и др.), \r\nпозволяют управлять файловым вводом-выводом.&lt;/p&gt;\r\n&lt;h2&gt;Работа с дисками&lt;/h2&gt;\r\n&lt;p&gt;Работу с файловой системой начнем с самого верхнего уровня - дисков. Для представления диска в пространстве имен &lt;strong&gt;System.IO&lt;/strong&gt; \r\nимеется класс &lt;strong&gt;DriveInfo&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;p&gt;Этот класс имеет статический метод &lt;strong&gt;GetDrives()&lt;/strong&gt;, который возвращает имена всех логических дисков компьютера. Также он предоставляет \r\nряд полезных свойств:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;AvailableFreeSpace&lt;/strong&gt;: указывает на объем доступного свободного места на диске в байтах&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;DriveFormat&lt;/strong&gt;: получает имя файловой системы&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;DriveType&lt;/strong&gt;: представляет тип диска&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;IsReady&lt;/strong&gt;: готов ли диск (например, DVD-диск может быть не вставлен в дисковод)&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Name&lt;/strong&gt;: получает имя диска&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;RootDirectory&lt;/strong&gt;: возвращает корневой каталог диска&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;TotalFreeSpace&lt;/strong&gt;: получает общий объем свободного места на диске в байтах&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;TotalSize&lt;/strong&gt;: общий размер диска в байтах&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;VolumeLabel&lt;/strong&gt;: получает или устанавливает метку тома&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Получим имена и свойства всех дисков на компьютере:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nDriveInfo[] drives = DriveInfo.GetDrives();\r\n \r\nforeach (DriveInfo drive in drives)\r\n{\r\n    Console.WriteLine($&quot;Название: {drive.Name}&quot;);\r\n    Console.WriteLine($&quot;Тип: {drive.DriveType}&quot;);\r\n    if (drive.IsReady)\r\n    {\r\n        Console.WriteLine($&quot;Объем диска: {drive.TotalSize}&quot;);\r\n        Console.WriteLine($&quot;Свободное пространство: {drive.TotalFreeSpace}&quot;);\r\n        Console.WriteLine($&quot;Метка диска: {drive.VolumeLabel}&quot;);\r\n    }\r\n    Console.WriteLine();\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Консольный вывод в моем случае:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Название: C:\\ \r\nТип: Fixed\r\nОбъем диска: 624823205888\r\nСвободное пространство: 58199781376\r\nМетка диска: \r\n\r\nНазвание: D: \r\nТип: Fixed\r\nОбъем диска: 105372446720\r\nСвободное пространство: 3887951872\r\nМетка диска: Windows7\r\n\r\nНазвание: E: \r\nТип: Fixed\r\nОбъем диска: 17809010688\r\nСвободное пространство: 463650816\r\nМетка диска: RECOVERY\r\n\r\nНазвание: G: \r\nТип: Fixed\r\nОбъем диска: 954200064\r\nСвободное пространство: 275193856\r\nМетка диска: \r\n&lt;/pre&gt;\r\n'),
(67, 'Работа с каталогами', 21, 2, 2, '&lt;p&gt;Для работы с каталогами в пространстве имен System.IO предназначены сразу два класса: &lt;strong&gt;Directory&lt;/strong&gt; и \r\n&lt;strong&gt;DirectoryInfo&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;h3&gt;Класс Directory&lt;/h3&gt;\r\n&lt;p&gt;Статический класс Directory предоставляет ряд методов для управления каталогами. Некоторые из этих методов:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;CreateDirectory(path)&lt;/strong&gt;: создает каталог по указанному пути path&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Delete(path)&lt;/strong&gt;: удаляет каталог по указанному пути path&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Exists(path)&lt;/strong&gt;: определяет, существует ли каталог по указанному пути path. Если существует, возвращается &lt;strong&gt;true&lt;/strong&gt;, \r\nесли не существует, то &lt;strong&gt;false&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;GetCurrentDirectory()&lt;/strong&gt;: получает путь к текущей папке&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;GetDirectories(path)&lt;/strong&gt;: получает список подкаталогов в каталоге path&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;GetFiles(path)&lt;/strong&gt;: получает список файлов в каталоге path&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;GetFileSystemEntries(path)&lt;/strong&gt;: получает список подкаталогов и файлов в каталоге path&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Move(sourceDirName, destDirName)&lt;/strong&gt;: перемещает каталог&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;GetParent(path)&lt;/strong&gt;: получение родительского каталога&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;GetLastWriteTime(path)&lt;/strong&gt;: возвращает время последнего изменения каталога&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;GetLastAccessTime(path)&lt;/strong&gt;: возвращает время последнего обращения к каталогу&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;GetCreationTime(path)&lt;/strong&gt;: возвращает время создания каталога&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;h3&gt;Класс DirectoryInfo&lt;/h3&gt;\r\n&lt;p&gt;Данный класс предоставляет функциональность для создания, удаления, перемещения и других операций с каталогами. Во многом он похож на \r\nDirectory, но не является статическим.&lt;/p&gt;\r\n&lt;p&gt;Для создания объекта класса DirectoryInfo применяется конструктор, который в качестве параметра принимает путь к каталогу:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\npublic DirectoryInfo (string path);\r\n&lt;/code&gt;\r\n&lt;p&gt;Основные методы класса &lt;strong&gt;DirectoryInfo&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Create()&lt;/strong&gt;: создает каталог&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;CreateSubdirectory(path)&lt;/strong&gt;: создает подкаталог по указанному пути path&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Delete()&lt;/strong&gt;: удаляет каталог&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;GetDirectories()&lt;/strong&gt;: получает список подкаталогов папки в виде массива DirectoryInfo&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;GetFiles()&lt;/strong&gt;: получает список файлов в папке в виде массива FileInfo&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;MoveTo(destDirName)&lt;/strong&gt;: перемещает каталог&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Основные свойства класса &lt;strong&gt;DirectoryInfo&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;CreationTime&lt;/strong&gt;: представляет время создания каталога&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;LastAccessTime&lt;/strong&gt;: представляет время последнего доступа к каталогу&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;LastWriteTime&lt;/strong&gt;: представляет время последнего изменения каталога&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Exists&lt;/strong&gt;: определяет, существует ли каталог&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Parent&lt;/strong&gt;: получение родительского каталога&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Root&lt;/strong&gt;: получение корневого каталога&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Name&lt;/strong&gt;: имя каталога&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;FullName&lt;/strong&gt;: полный путь к каталогу&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;h3&gt;Directory или DirectoryInfo&lt;/h3&gt;\r\n&lt;p&gt;Как видно из функционала, оба класса предоставляют похожие возможности. Когда же и что использовать? Если надо совершить одну-две операции с одним каталогом, то проще \r\nиспользовать класс Directory. Если необходимо выполнить последовательность операций с одним и тем же каталогом, то лучше воспользоваться классом \r\nDirectoryInfo. Почему? Дело в том, что методы класса Directory выполняют дополнительные проверки безопасности. А для класса DirectoryInfo \r\nтакие проверки не всегда обязательны.&lt;/p&gt;\r\n&lt;p&gt;Посмотрим на примерах применение этих классов&lt;/p&gt;\r\n&lt;h3&gt;Получение списка файлов и подкаталогов&lt;/h3&gt;\r\n&lt;code&gt;\r\n\r\nstring dirName = &quot;C:\\&quot;;\r\n// если папка существует\r\nif (Directory.Exists(dirName))\r\n{\r\n    Console.WriteLine(&quot;Подкаталоги:&quot;);\r\n    string[] dirs = Directory.GetDirectories(dirName);\r\n    foreach (string s in dirs)\r\n    {\r\n        Console.WriteLine(s);\r\n    }\r\n    Console.WriteLine();\r\n    Console.WriteLine(&quot;Файлы:&quot;);\r\n    string[] files = Directory.GetFiles(dirName);\r\n    foreach (string s in files)\r\n    {\r\n        Console.WriteLine(s);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Обратите внимание на использование слешей в именах файлов. Либо мы используем двойной слеш: &lt;strong&gt;&quot;C:\\&quot;&lt;/strong&gt;, либо одинарный, \r\nно тогда перед всем путем ставим знак @: &lt;strong&gt;@&quot;C:Program Files&quot;&lt;/strong&gt;&lt;/p&gt;\r\n&lt;p&gt;Аналогичный пример с DirectoryInfo:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nstring dirName = &quot;C:&quot;;\r\n \r\nvar directory = new DirectoryInfo(dirName);\r\n \r\nif (directory.Exists)\r\n{\r\n    Console.WriteLine(&quot;Подкаталоги:&quot;);\r\n    DirectoryInfo[] dirs = directory.GetDirectories();\r\n    foreach (DirectoryInfo dir in dirs)\r\n    {\r\n        Console.WriteLine(dir.FullName);\r\n    }\r\n    Console.WriteLine();\r\n    Console.WriteLine(&quot;Файлы:&quot;);\r\n    FileInfo[] files = directory.GetFiles();\r\n    foreach (FileInfo file in files)\r\n    {\r\n        Console.WriteLine(file.FullName);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;h3&gt;Фильтрация папок и файлов&lt;/h3&gt;\r\n&lt;p&gt;Методы получения папок и файлов позволяют выполнять фильтрацию. В качестве фильтра в эти методы передается шаблон, который может содержать два \r\nплейсхолдера: &lt;strong&gt;*&lt;/strong&gt; или символ-звездочка (соответствует любому количеству символов) и &lt;strong&gt;?&lt;/strong&gt; или вопросительный знак (соответствует одному символу)&lt;/p&gt;\r\n&lt;p&gt;Например, найдем все папки, которые начинаются на &quot;books&quot;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\n// класс Directory\r\nstring[] dirs = Directory.GetDirectories(dirName, &quot;books*.&quot;);\r\n \r\n// класс DirectoryInfo\r\nvar directory = new DirectoryInfo(dirName);\r\nDirectoryInfo[] dirs = directory.GetDirectories(&quot;books*.&quot;);\r\n&lt;/code&gt;\r\n&lt;p&gt;Или получим все файлы с расширением &quot;.exe&quot;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\n// класс Directory\r\nstring[] files = Directory.GetFiles(dirName, &quot;*.exe&quot;);\r\n \r\n// класс DirectoryInfo\r\nvar directory = new DirectoryInfo(dirName);\r\nFileInfo[] files = directory.GetFiles(&quot;*.exe&quot;);\r\n&lt;/code&gt;\r\n&lt;h3&gt;Создание каталога&lt;/h3&gt;\r\n&lt;p&gt;Класс DirectoryInfo&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nstring path = @&quot;C:SomeDir&quot;;\r\nstring subpath = @&quot;programavalon&quot;;\r\nDirectoryInfo dirInfo = new DirectoryInfo(path);\r\nif (!dirInfo.Exists)\r\n{\r\n    dirInfo.Create();\r\n}\r\ndirInfo.CreateSubdirectory(subpath);\r\n&lt;/code&gt;\r\n&lt;p&gt;Вначале проверяем, а нету ли такой директории, так как если она существует, то ее создать будет нельзя, и приложение выбросит ошибку. \r\nВ итоге у нас получится следующий путь: &quot;C:SomeDirprogramavalon&quot;&lt;/p&gt;\r\n&lt;p&gt;Аналогичный пример с классом Directory:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nstring path = @&quot;C:SomeDir&quot;;\r\nstring subpath = @&quot;programavalon&quot;;\r\nif (!Directory.Exists(path))\r\n{\r\n    Directory.CreateDirectory(path);\r\n}\r\nDirectory.CreateDirectory($&quot;{path}/{subpath}&quot;);\r\n&lt;/code&gt;\r\n\r\n&lt;h3&gt;Получение информации о каталоге&lt;/h3&gt;\r\n&lt;code&gt;\r\n\r\nstring dirName = &quot;C:\\Program Files&quot;;\r\n \r\nDirectoryInfo dirInfo = new DirectoryInfo(dirName);\r\n \r\nConsole.WriteLine($&quot;Название каталога: {dirInfo.Name}&quot;);\r\nConsole.WriteLine($&quot;Полное название каталога: {dirInfo.FullName}&quot;);\r\nConsole.WriteLine($&quot;Время создания каталога: {dirInfo.CreationTime}&quot;);\r\nConsole.WriteLine($&quot;Корневой каталог: {dirInfo.Root}&quot;);\r\n&lt;/code&gt;\r\n&lt;h3&gt;Удаление каталога&lt;/h3&gt;\r\n&lt;p&gt;Если мы просто применим метод &lt;strong&gt;Delete&lt;/strong&gt; к непустой папке, в которой есть какие-нибудь файлы или подкаталоги, то приложение \r\nнам выбросит ошибку. Поэтому нам надо передать в метод &lt;strong&gt;Delete&lt;/strong&gt; дополнительный параметр булевого типа, который укажет, что папку \r\nнадо удалять со всем содержимым. Кроме того, перед удалением следует проверить наличие удаляемой папки, иначе приложение выбросит исключение:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nstring dirName = @&quot;C:SomeDir&quot;;\r\n \r\nDirectoryInfo dirInfo = new DirectoryInfo(dirName);\r\nif (dirInfo.Exists)\r\n{\r\n    dirInfo.Delete(true);\r\n    Console.WriteLine(&quot;Каталог удален&quot;);\r\n}\r\nelse\r\n{\r\n    Console.WriteLine(&quot;Каталог не существует&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Или так:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nstring dirName = @&quot;C:SomeDir&quot;;\r\nif (Directory.Exists(dirName))\r\n{\r\n    Directory.Delete(dirName, true);\r\n    Console.WriteLine(&quot;Каталог удален&quot;);\r\n}\r\nelse\r\n{\r\n    Console.WriteLine(&quot;Каталог не существует&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;h3&gt;Перемещение каталога&lt;/h3&gt;\r\n&lt;p&gt;При перемещении надо учитывать, что новый каталог, в который мы хотим перемесить все содержимое старого каталога, не должен существовать.&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nstring oldPath = @&quot;C:SomeFolder&quot;;\r\nstring newPath = @&quot;C:SomeDir&quot;;\r\nDirectoryInfo dirInfo = new DirectoryInfo(oldPath);\r\nif (dirInfo.Exists &amp;amp;&amp;amp; !Directory.Exists(newPath))\r\n{\r\n    dirInfo.MoveTo(newPath);\r\n    // или так\r\n    // Directory.Move(oldPath, newPath);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Перемещение каталога в рамках одной папки (как в примере выше) фактически аналогично переименованию папки&lt;/p&gt;'),
(68, 'Работа с файлами. Классы File и FileInfo', 21, 3, 2, '&lt;p&gt;Подобно паре &lt;strong&gt;Directory/DirectoryInfo&lt;/strong&gt; для работы с файлами предназначена пара классов &lt;strong&gt;File&lt;/strong&gt; и \r\n&lt;strong&gt;FileInfo&lt;/strong&gt;. С их помощью мы можем создавать, удалять, перемещать файлы, получать их свойства и многое другое.&lt;/p&gt;\r\n&lt;h3&gt;FileInfo&lt;/h3&gt;\r\n&lt;p&gt;Некоторые полезные методы и свойства класса &lt;strong&gt;FileInfo&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;CopyTo(path)&lt;/strong&gt;: копирует файл в новое место по указанному пути path&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Create()&lt;/strong&gt;: создает файл&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Delete()&lt;/strong&gt;: удаляет файл&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;MoveTo(destFileName)&lt;/strong&gt;: перемещает файл в новое место&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Свойство &lt;strong&gt;Directory&lt;/strong&gt;: получает родительский каталог в виде объекта DirectoryInfo&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Свойство &lt;strong&gt;DirectoryName&lt;/strong&gt;: получает полный путь к родительскому каталогу&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Свойство &lt;strong&gt;Exists&lt;/strong&gt;: указывает, существует ли файл&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Свойство &lt;strong&gt;Length&lt;/strong&gt;: получает размер файла&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Свойство &lt;strong&gt;Extension&lt;/strong&gt;: получает расширение файла&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Свойство &lt;strong&gt;Name&lt;/strong&gt;: получает имя файла&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Свойство &lt;strong&gt;FullName&lt;/strong&gt;: получает полное имя файла&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Для создания объекта FileInfo применяется конструктор, который получает в качестве параметра путь к файлу:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nFileInfo fileInf = new FileInfo(@&quot;C:\\appcontent.txt&quot;);\r\n&lt;/code&gt;\r\n&lt;h3&gt;File&lt;/h3&gt;\r\n&lt;p&gt;Класс &lt;strong&gt;File&lt;/strong&gt; реализует похожую функциональность с помощью статических методов:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Copy()&lt;/strong&gt;: копирует файл в новое место&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Create()&lt;/strong&gt;: создает файл&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Delete()&lt;/strong&gt;: удаляет файл&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Move&lt;/strong&gt;: перемещает файл в новое место&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Exists(file)&lt;/strong&gt;: определяет, существует ли файл&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;h3&gt;Пути к файлам&lt;/h3&gt;\r\n&lt;p&gt;Для работы с файлами можно применять как абсолютные, так и относительные пути:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\n// абсолютные пути\r\nstring path1 = @&quot;C:UserseugeneDocumentscontent.txt&quot;;  // для Windows\r\nstring path2 = &quot;C:\\Users\\eugene\\Documents\\content.txt&quot;;  // для Windows\r\nstring path3 = &quot;/Users/eugene/Documents/content.txt&quot;;  // для MacOS/Linux\r\n \r\n// относительные пути\r\nstring path4 = &quot;MyDir\\content.txt&quot;;  // для Windows\r\nstring path5 = &quot;MyDir/content.txt&quot;;  // для MacOS/Linux\r\n&lt;/code&gt;\r\n&lt;h3&gt;Получение информации о файле&lt;/h3&gt;\r\n&lt;code&gt;\r\n\r\nstring path = @&quot;C:UserseugeneDocumentscontent.txt&quot;;\r\n// string path = &quot;/Users/eugene/Documents/content.txt&quot;;  // для MacOS/Linux\r\nFileInfo fileInfo = new FileInfo(path);\r\nif (fileInfo.Exists)\r\n{\r\n    Console.WriteLine($&quot;Имя файла: {fileInfo.Name}&quot;);\r\n    Console.WriteLine($&quot;Время создания: {fileInfo.CreationTime}&quot;);\r\n    Console.WriteLine($&quot;Размер: {fileInfo.Length}&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;h3&gt;Удаление файла&lt;/h3&gt;\r\n&lt;code&gt;\r\n\r\nstring path = @&quot;C:appcontent.txt&quot;;\r\nFileInfo fileInf = new FileInfo(path);\r\nif (fileInf.Exists)\r\n{\r\n   fileInf.Delete();\r\n   // альтернатива с помощью класса File\r\n   // File.Delete(path);\r\n}\r\n&lt;/code&gt;\r\n&lt;h3&gt;Перемещение файла&lt;/h3&gt;\r\n&lt;code&gt;\r\n\r\nstring path =  @&quot;C:OldDircontent.txt&quot;;\r\nstring newPath = @&quot;C:NewDirindex.txt&quot;;\r\nFileInfo fileInf = new FileInfo(path);\r\nif (fileInf.Exists)\r\n{\r\n   fileInf.MoveTo(newPath);       \r\n   // альтернатива с помощью класса File\r\n   // File.Move(path, newPath);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Если файл по новому пути уже существует, то с помощью дополнительного параметра можно указать, надо ли перезаписать файл (при значении true файл перезаписывается)&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nstring path =  @&quot;C:OldDircontent.txt&quot;;\r\nstring newPath = @&quot;C:NewDirindex.txt&quot;;\r\nFileInfo fileInf = new FileInfo(path);\r\nif (fileInf.Exists)\r\n{\r\n   fileInf.MoveTo(newPath, true);       \r\n   // альтернатива с помощью класса File\r\n   // File.Move(path, newPath, true);\r\n}\r\n&lt;/code&gt;\r\n&lt;h3&gt;Копирование файла&lt;/h3&gt;\r\n&lt;code&gt;\r\n\r\nstring path =  @&quot;C:OldDircontent.txt&quot;;\r\nstring newPath = @&quot;C:NewDirindex2.txt&quot;;\r\nFileInfo fileInf = new FileInfo(path);\r\nif (fileInf.Exists)\r\n{\r\n   fileInf.CopyTo(newPath, true);      \r\n   // альтернатива с помощью класса File\r\n   // File.Copy(path, newPath, true);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Метод &lt;strong&gt;CopyTo&lt;/strong&gt; класса &lt;strong&gt;FileInfo&lt;/strong&gt; принимает два параметра: путь, по которому файл будет копироваться, и булевое значение, \r\nкоторое указывает, надо ли при копировании перезаписывать файл (если &lt;strong&gt;true&lt;/strong&gt;, как в случае выше, файл при копировании перезаписывается). Если же в \r\nкачестве последнего параметра передать значение &lt;strong&gt;false&lt;/strong&gt;, то если такой файл уже существует, приложение выдаст ошибку.&lt;/p&gt;\r\n&lt;p&gt;Метод &lt;strong&gt;Copy&lt;/strong&gt; класса &lt;strong&gt;File&lt;/strong&gt; принимает три параметра: путь к исходному файлу, путь, по которому файл будет копироваться, и \r\nбулевое значение, указывающее, будет ли файл перезаписываться.&lt;/p&gt;\r\n&lt;h3&gt;Чтение и запись файлов&lt;/h3&gt;\r\n&lt;p&gt;В дополнение к вышерассмотренным методам класс File также предоставляет ряд методов для чтения-записи текстовых и бинарных файлов:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;AppendAllLines(String, IEnumerable&lt;String&gt;)&lt;/strong&gt; / \r\n&lt;strong&gt;AppendAllLinesAsync(String, IEnumerable&lt;String&gt;, CancellationToken)&lt;/strong&gt;&lt;/p&gt;\r\n&lt;p&gt;добавляют в файл набор строк. Если файл не существует, то он создается&lt;/p&gt;\r\n&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;AppendAllText(String, String)&lt;/strong&gt; / &lt;strong&gt;AppendAllTextAsync(String, String, CancellationToken)&lt;/strong&gt;&lt;/p&gt;\r\n&lt;p&gt;добавляют в файл строку. Если файл не существует, то он создается&lt;/p&gt;\r\n&lt;/li&gt;\r\n\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;byte[] ReadAllBytes (string path)&lt;/strong&gt; / \r\n&lt;strong&gt;Task&lt;byte[]&gt; ReadAllBytesAsync (string path, CancellationToken cancellationToken)&lt;/strong&gt;&lt;/p&gt;\r\n&lt;p&gt;считывают содержимое бинарного файла в массив байтов&lt;/p&gt;\r\n&lt;/li&gt;\r\n\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;string[] ReadAllLines (string path)&lt;/strong&gt; / \r\n&lt;strong&gt;Task&lt;string[]&gt; ReadAllLinesAsync (string path, CancellationToken cancellationToken)&lt;/strong&gt;&lt;/p&gt;\r\n&lt;p&gt;считывают содержимое текстового файла в массив строк&lt;/p&gt;\r\n&lt;/li&gt;\r\n\r\n\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;string ReadAllText (string path)&lt;/strong&gt; / \r\n&lt;strong&gt;Task&lt;string&gt; ReadAllTextAsync (string path, CancellationToken cancellationToken)&lt;/strong&gt;&lt;/p&gt;\r\n&lt;p&gt;считывают содержимое текстового файла в строку&lt;/p&gt;\r\n&lt;/li&gt;\r\n\r\n\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;IEnumerable&lt;string&gt; ReadLines (string path)&lt;/strong&gt;&lt;/p&gt;\r\n&lt;p&gt;считывают содержимое текстового файла в коллекцию строк&lt;/p&gt;\r\n&lt;/li&gt;\r\n\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;void WriteAllBytes (string path, byte[] bytes)&lt;/strong&gt; / \r\n&lt;strong&gt;Task WriteAllBytesAsync (string path, byte[] bytes, CancellationToken cancellationToken)&lt;/strong&gt;&lt;/p&gt;\r\n&lt;p&gt;записывают массив байт в бинарный файл. Если файл не существует, он создается. Если существует, то перезаписывается&lt;/p&gt;\r\n&lt;/li&gt;\r\n\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;void WriteAllLines (string path, string[] contents)&lt;/strong&gt; / \r\n&lt;strong&gt;Task WriteAllLinesAsync (string path, IEnumerable&lt;string&gt; contents, CancellationToken cancellationToken)&lt;/strong&gt;&lt;/p&gt;\r\n&lt;p&gt;записывают массив строк в текстовый файл. Если файл не существует, он создается. Если существует, то перезаписывается&lt;/p&gt;\r\n&lt;/li&gt;\r\n\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;WriteAllText (string path, string? contents)&lt;/strong&gt; / \r\n&lt;strong&gt;Task WriteAllTextAsync (string path, string? contents, CancellationToken cancellationToken)&lt;/strong&gt;&lt;/p&gt;\r\n&lt;p&gt;записывают строку в текстовый файл. Если файл не существует, он создается. Если существует, то перезаписывается&lt;/p&gt;\r\n&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Как видно, эти методы покрывают практически все основные сценарии - чтение и запись текстовых и бинарных файлов. Причем в зависимости от задачи можно применять \r\nкак синхронные методы, так и их асинхронные аналоги.&lt;/p&gt;\r\n&lt;p&gt;Например, запишем и считаем обратно в строку текстовый файл:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nstring path = @&quot;c:appcontent.txt&quot;;\r\n \r\nstring originalText = &quot;Hello Metanit.com&quot;;\r\n// запись строки\r\nawait File.WriteAllTextAsync(path, originalText);\r\n// дозапись в конец файла\r\nawait File.AppendAllTextAsync(path, &quot;\nHello work&quot;);\r\n \r\n// чтение файла\r\nstring fileText = await File.ReadAllTextAsync(path);\r\nConsole.WriteLine(fileText);\r\n&lt;/code&gt;\r\n&lt;p&gt;Консольный вывод:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Hello Metanit.com\r\nHello work\r\n&lt;/pre&gt;\r\n\r\n&lt;p&gt;Стоит отметить, что при добавлении текста я добавил в строку последовательность &quot;\n&quot;, которая выполняет перевод на следующую строку. Благодаря этому \r\nдобавляемый текст располагается в файле на новой строке.&lt;/p&gt;\r\n&lt;p&gt;Если мы хотим, что в файле изначально шло добавление на новую строку, то для записи стоит использовать метод &lt;strong&gt;WriteAllLines/ WriteAllLinesAsync&lt;/strong&gt;, \r\nа для добавления -  &lt;strong&gt;AppendAllLines / AppendAllLinesAsync&lt;/strong&gt;&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nawait File.WriteAllLinesAsync(path, new[] { &quot;Hello Metanit.com&quot;, &quot;Hello work&quot; });\r\n&lt;/code&gt;\r\n&lt;p&gt;Аналогично при чтении файла если мы хотим каждую строку файла считать отдельно, то вместо &lt;strong&gt;ReadAllText / ReadAllTextAsync&lt;/strong&gt; применяется \r\n&lt;strong&gt;ReadAllLines / ReadAllTextAsync&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;h3&gt;Кодировка&lt;/h3&gt;\r\n&lt;p&gt;В качестве дополнительного параметра методы чтения-записи текстовых файлов позволяют установить кодировку в виде объекта \r\n&lt;strong&gt;System.Text.Encoding&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nusing System.Text;\r\n \r\nstring path = &quot;/Users/eugene/Documents/app/content.txt&quot;;\r\n \r\nstring originalText = &quot;Привет Metanit.com&quot;;\r\n// запись строки\r\nawait File.WriteAllTextAsync(path, originalText, Encoding.Unicode);\r\n// дозапись в конец файла\r\nawait File.AppendAllTextAsync(path, &quot;\nПривет мир&quot;, Encoding.Unicode);\r\n \r\n// чтение файла\r\nstring fileText = await File.ReadAllTextAsync(path, Encoding.Unicode);\r\nConsole.WriteLine(fileText);\r\n&lt;/code&gt;\r\n&lt;p&gt;Для установки кодировки при записи и чтении здесь применяется встроенное значение &lt;strong&gt;Encoding.Unicode&lt;/strong&gt;. Также можно указать название кодировки, единственное \r\nследует удостовериться, что текущая операционная система поддерживает выбранную кодировку:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nusing System.Text;\r\n \r\nstring path = @&quot;c:appcontent.txt&quot;;\r\n \r\nstring originalText = &quot;Hello Metanit.com&quot;;\r\n// запись строки\r\nawait File.WriteAllTextAsync(path, originalText, Encoding.GetEncoding(&quot;iso-8859-1&quot;));\r\n// дозапись в конец файла\r\nawait File.AppendAllTextAsync(path, &quot;\nHello code&quot;, Encoding.GetEncoding(&quot;iso-8859-1&quot;));\r\n \r\n// чтение файла\r\nstring fileText = await File.ReadAllTextAsync(path, Encoding.GetEncoding(&quot;iso-8859-1&quot;));\r\nConsole.WriteLine(fileText);\r\n&lt;/code&gt;\r\n'),
(69, 'FileStream. Чтение и запись файла', 21, 4, 2, '&lt;p&gt;Класс &lt;strong&gt;FileStream&lt;/strong&gt; представляет возможности по считыванию из файла и записи в файл. Он позволяет работать как с \r\nтекстовыми файлами, так и с бинарными.&lt;/p&gt;\r\n&lt;h3&gt;Создание FileStream&lt;/h3&gt;\r\n&lt;p&gt;Для создания объекта FileStream можно использовать как конструкторы этого класса, так и статические методы класса File. Конструктор FileStream имеет множество перегруженных версий, \r\nиз которых отмечу лишь одну, самую простую и используемую:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nFileStream(string filename, FileMode mode)\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь в конструктор передается два параметра: путь к файлу и перечисление &lt;strong&gt;FileMode&lt;/strong&gt;. Данное перечисление указывает на режим доступа к \r\nфайлу и может принимать следующие значения:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Append&lt;/strong&gt;: если файл существует, то текст добавляется в конец файл. Если файла нет, то он создается. \r\nФайл открывается только для записи.&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Create&lt;/strong&gt;: создается новый файл. Если такой файл уже существует, то он перезаписывается&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;CreateNew&lt;/strong&gt;: создается новый файл. Если такой файл уже существует, то приложение выбрасывает ошибку&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Open&lt;/strong&gt;: открывает файл. Если файл не существует, выбрасывается исключение&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;OpenOrCreate&lt;/strong&gt;: если файл существует, он открывается, если нет - создается новый&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Truncate&lt;/strong&gt;: если файл существует, то он перезаписывается. Файл открывается только для записи.&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Другой способ создания объекта FileStream представляют статические методы класса File:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nFileStream File.Open(string file, FileMode mode);\r\nFileStream File.OpenRead(string file);\r\nFileStream File.OpenWrite(string file);\r\n&lt;/code&gt;\r\n&lt;p&gt;Первый метод открывает файл с учетом объекта FileMode и возвращает файловой поток FileStream. У этого метода также есть несколько перегруженных версий. Второй метод открывает поток для чтения, а третий открывает \r\nпоток для записи.&lt;/p&gt;\r\n&lt;h3&gt;Закрытие потока&lt;/h3&gt;\r\n&lt;p&gt;Класс FileStream для освобождения всех реусрсов, связанных с файлом, реализует интерфейс IDisposable. Соответственно после завершения работы с \r\nFileStream необходимо освободить связанный с ним файл вызовом метода Dispose. Для корректного закрытия можно вызвать метод \r\n&lt;strong&gt;Close()&lt;/strong&gt;, который вызывает метод Dispose:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nFileStream? fstream = null;\r\ntry\r\n{\r\n    fstream = new FileStream(&quot;note3.dat&quot;, FileMode.OpenOrCreate);\r\n    // операции с fstream\r\n}\r\ncatch(Exception ex)\r\n{  }\r\nfinally\r\n{\r\n    fstream?.Close();\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Либо можно использовать конструкцию using, которая автоматически освободит все связанные с FileStream ресурсы:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nusing (FileStream fstream = new FileStream(&quot;note3.dat&quot;, FileMode.OpenOrCreate))\r\n{\r\n    // операции с fstream\r\n}\r\n&lt;/code&gt;\r\n&lt;h3&gt;Свойства и методы FileStream&lt;/h3&gt;\r\n&lt;p&gt;Рассмотрим наиболее важные свойства класса &lt;strong&gt;FileStream&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;Свойство &lt;strong&gt;Length&lt;/strong&gt;: возвращает длину потока в байтах&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Свойство &lt;strong&gt;Position&lt;/strong&gt;: возвращает текущую позицию в потоке&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;Свойство &lt;strong&gt;Name&lt;/strong&gt;: возвращает абсолютный путь к файлу, открытому в FileStream&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Для чтения/записи файлов можно применять следующие методы класса &lt;strong&gt;FileStream&lt;/strong&gt;:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;void CopyTo(Stream destination)&lt;/strong&gt;: копирует данные из текущего потока в поток destination&lt;/p&gt;\r\n&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Task CopyToAsync(Stream destination)&lt;/strong&gt;: асинхронная версия метода CopyTo&lt;/p&gt;\r\n&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;void Flush()&lt;/strong&gt;: сбрасывает содержимое буфера в файл&lt;/p&gt;\r\n&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Task FlushAsync()&lt;/strong&gt;: асинхронная версия метода Flush&lt;/p&gt;\r\n&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;int Read(byte[] array, int offset, int count)&lt;/strong&gt;: считывает данные из файла в массив байтов и возвращает количество успешно считанных байтов. \r\nПринимает три параметра:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;array&lt;/strong&gt; - массив байтов, куда будут помещены считываемые из файла данные&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;offset&lt;/strong&gt; представляет смещение в байтах в массиве array, в который считанные байты будут помещены&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;count&lt;/strong&gt; - максимальное число байтов, предназначенных для чтения. Если в файле находится меньшее количество байтов, то \r\nвсе они будут считаны.&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Task&lt;int&gt; ReadAsync(byte[] array, int offset, int count)&lt;/strong&gt;: асинхронная версия метода Read&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;long Seek(long offset, SeekOrigin origin)&lt;/strong&gt;: устанавливает позицию в потоке со смещением на количество байт, \r\nуказанных в параметре offset.&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;void Write(byte[] array, int offset, int count)&lt;/strong&gt;: записывает в файл данные из массива байтов. Принимает три параметра: \r\n&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;array&lt;/strong&gt; - массив байтов, откуда данные будут записываться в файл&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;offset&lt;/strong&gt; - смещение в байтах в массиве array, откуда начинается запись байтов в поток&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;count&lt;/strong&gt; - максимальное число байтов, предназначенных для записи&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Task WriteAsync(byte[] array, int offset, int count)&lt;/strong&gt;: асинхронная версия метода Write&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;h3&gt;Чтение и запись файлов&lt;/h3&gt;\r\n&lt;p&gt;FileStream представляет доступ к файлам на уровне байтов, поэтому, например, если вам надо считать или записать одну или несколько строк в текстовый \r\nфайл, то массив байтов надо преобразовать в строки, используя специальные методы. Поэтому для работы с текстовыми файлами применяются другие классы.&lt;/p&gt;\r\n&lt;p&gt;В то же время при работе с различными бинарными файлами, имеющими определенную структуру, FileStream может быть очень даже полезен для извлечения \r\nопределенных порций информации и ее обработки.&lt;/p&gt;\r\n&lt;p&gt;Посмотрим на примере считывания-записи в текстовый файл:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nusing System.Text;\r\n \r\nstring path = @&quot;C:\\app\note.txt&quot;;   // путь к файлу\r\n \r\nstring text = &quot;Hello METANIT.COM&quot;; // строка для записи\r\n \r\n// запись в файл\r\nusing (FileStream fstream = new FileStream(path, FileMode.OpenOrCreate))\r\n{\r\n    // преобразуем строку в байты\r\n    byte[] buffer = Encoding.Default.GetBytes(text);\r\n    // запись массива байтов в файл\r\n    await fstream.WriteAsync(buffer, 0, buffer.Length);\r\n    Console.WriteLine(&quot;Текст записан в файл&quot;);\r\n}\r\n \r\n// чтение из файла\r\nusing (FileStream fstream = File.OpenRead(path))\r\n{\r\n    // выделяем массив для считывания данных из файла\r\n    byte[] buffer = new byte[fstream.Length];\r\n    // считываем данные\r\n    await fstream.ReadAsync(buffer, 0, buffer.Length);\r\n    // декодируем байты в строку\r\n    string textFromFile = Encoding.Default.GetString(buffer);\r\n    Console.WriteLine($&quot;Текст из файла: {textFromFile}&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Разберем этот пример. Вначале определяем путь к файлу и текст для записи в файл.&lt;/p&gt;\r\n&lt;p&gt;И при чтении, и при записи для создания и удаления объекта FileStream используется конструкция &lt;strong&gt;using&lt;/strong&gt;, \r\nпо завершению которой у созданного объекта FileStream автоматически вызывается метод &lt;strong&gt;Dispose&lt;/strong&gt;, и, таким образом, объект уничтожается.&lt;/p&gt;\r\n&lt;p&gt;Поскольку операции \r\nс файлами могут занимать продолжительное время и являются узким местом в работе программы, рекомендуется использовать асинхронные версии методов FileStream. \r\nИ при записи, и при чтении применяется объект кодировки &lt;strong&gt;Encoding.Default&lt;/strong&gt; из пространства имен &lt;strong&gt;System.Text&lt;/strong&gt;. \r\nВ данном случае мы используем два его метода: &lt;strong&gt;GetBytes&lt;/strong&gt; для получения массива байтов из строки и \r\n&lt;strong&gt;GetString&lt;/strong&gt; для получения строки из массива байтов.&lt;/p&gt;\r\n&lt;p&gt;В итоге введенная нами строка записывается в файл &lt;span class=&quot;ii&quot;&gt;note.txt&lt;/span&gt;. И мы получим следующий консольный вывод:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Текст записан в файл\r\nТекст из файла: Hello METANIT.COM\r\n&lt;/pre&gt;\r\n\r\n&lt;p&gt;Записанный файл по сути представляет бинарный файл (не текстовый), хотя если мы в него запишем только строку, \r\nто сможем посмотреть в удобочитаемом виде этот файл, открыв его в текстовом редакторе. Однако если мы в него запишем случайные байты, например:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nfstream.WriteByte(13);\r\nfstream.WriteByte(103);\r\n&lt;/code&gt;\r\n&lt;p&gt;То у нас могут возникнуть проблемы с его пониманием. Поэтому для работы непосредственно с текстовыми файлами предназначены отдельные классы - \r\nStreamReader и StreamWriter.&lt;/p&gt;\r\n&lt;h3&gt;Произвольный доступ к файлам&lt;/h3&gt;\r\n&lt;p&gt;Нередко бинарные файлы представляют определенную структуру. И, зная эту структуру, мы можем взять из файла нужную порцию информации или наоброт записать в определенном месте файла \r\nопределенный набор байтов. Например, в wav-файлах непосредственно звуковые данные начинаются с 44 байта, а до 44 байта идут различные метаданные - количество каналов аудио, \r\nчастота дискретизации и т.д.&lt;/p&gt;\r\n&lt;p&gt;С помощью метода &lt;strong&gt;Seek()&lt;/strong&gt; мы можем управлять положением курсора потока, начиная с которого производится считывание или запись в файл. Этот метод принимает два параметра: \r\noffset (смещение) и позиция в файле. Позиция в файле описывается тремя значениями:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;SeekOrigin.Begin&lt;/strong&gt;: начало файла&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;SeekOrigin.End&lt;/strong&gt;: конец файла&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;SeekOrigin.Current&lt;/strong&gt;: текущая позиция в файле&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Курсор потока, с которого начинается чтение или запись, смещается вперед на значение offset относительно позиции, \r\nуказанной в качестве второго параметра. Смещение может быть отрицательным, тогда курсор сдвигается назад, если положительное - то вперед.&lt;/p&gt;\r\n&lt;p&gt;Рассмотрим простой пример:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nusing System.Text;\r\n \r\nstring path = &quot;note.dat&quot;;\r\n \r\nstring text = &quot;hello world&quot;;\r\n \r\nusing (FileStream fstream = new FileStream(path, FileMode.OpenOrCreate))\r\n{\r\n    // преобразуем строку в байты\r\n    byte[] input = Encoding.Default.GetBytes(text);\r\n    // запись массива байтов в файл\r\n    fstream.Write(input, 0, input.Length);\r\n    Console.WriteLine(&quot;Текст записан в файл&quot;);\r\n}\r\n// чтение части файла\r\nusing (FileStream fstream = new FileStream(path, FileMode.OpenOrCreate))\r\n{ \r\n    // перемещаем указатель в конец файла, до конца файла- пять байт\r\n    fstream.Seek(-5, SeekOrigin.End); // минус 5 символов с конца потока\r\n \r\n    // считываем четыре символов с текущей позиции\r\n    byte[] output = new byte[5];\r\n    await fstream.ReadAsync(output, 0, output.Length);\r\n    // декодируем байты в строку\r\n    string textFromFile = Encoding.Default.GetString(output);\r\n    Console.WriteLine($&quot;Текст из файла: {textFromFile}&quot;); // world\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Вначале записываем в файл текст &quot;hello world&quot;. Затем снова обращаемся к файла для считывания. Сначала перемещаем курсор на пять символов назад относительно конца файлового потока:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nfstream.Seek(-5, SeekOrigin.End)\r\n&lt;/code&gt;\r\n&lt;img src=&quot;https://metanit.com/sharp/tutorial/pics/5.3.png&quot; alt=&quot;чтение и запись файлов через FileStream в C#&quot;&gt;\r\n&lt;p&gt;То есть после выполнения этого вызова курсор будет стоять на позиции символа &quot;w&quot;.&lt;/p&gt;\r\n&lt;p&gt;После этого считываем пять байт начиная с символа &quot;w&quot;. В кодировке по умолчанию 1 символ будет представлять 1 байт. Поэтому чтение 5 байт будет \r\nэквивалентно чтению пяти сиволов: &quot;world&quot;.&lt;/p&gt;\r\n&lt;p&gt;Соответственно мы получим следующий консольный вывод:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Текст записан в файл\r\nТекст из файла: world\r\n&lt;/pre&gt;\r\n\r\n&lt;p&gt;Рассмотрим чуть более сложный пример - с записью начиная с некоторой позиции:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nusing System.Text;\r\n \r\nstring path = &quot;note2.dat&quot;;\r\n \r\nstring text = &quot;hello world&quot;;\r\n \r\n// запись в файл\r\nusing (FileStream fstream = new FileStream(path, FileMode.OpenOrCreate))\r\n{\r\n    // преобразуем строку в байты\r\n    byte[] input = Encoding.Default.GetBytes(text);\r\n    // запись массива байтов в файл\r\n    fstream.Write(input, 0, input.Length);\r\n    Console.WriteLine(&quot;Текст записан в файл&quot;);\r\n}\r\nusing (FileStream fstream = new FileStream(path, FileMode.OpenOrCreate))\r\n{ \r\n    // заменим в файле слово world на слово house\r\n    string replaceText = &quot;house&quot;;\r\n    fstream.Seek(-5, SeekOrigin.End); // минус 5 символов с конца потока\r\n    byte[] input = Encoding.Default.GetBytes(replaceText);\r\n    await fstream.WriteAsync(input, 0, input.Length);\r\n \r\n    // считываем весь файл\r\n    // возвращаем указатель в начало файла\r\n    fstream.Seek(0, SeekOrigin.Begin);\r\n    byte[] output = new byte[fstream.Length];\r\n    await fstream.ReadAsync(output, 0, output.Length);\r\n    // декодируем байты в строку\r\n    string textFromFile = Encoding.Default.GetString(output);\r\n    Console.WriteLine($&quot;Текст из файла: {textFromFile}&quot;); // hello house\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь также вначале записываем в файл строку &quot;hello world&quot;. Затем также открываем файл и опять же перемещаемся в конец файла, не доходя до конца пять \r\nсимволов (то есть опять же с позиции символа &quot;w&quot;), и осуществляем запись строки &quot;house&quot;. Таким образом, строка &quot;house&quot; заменяет строку &quot;world&quot;.&lt;/p&gt;\r\n&lt;p&gt;Чтобы после этого считать весь файл, сдвигаем курсор на самое начало&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nfstream.Seek(0, SeekOrigin.Begin);\r\n&lt;/code&gt;\r\n&lt;p&gt;Консольный вывод программы:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Текст записан в файл\r\nТекст из файла: hello house\r\n&lt;/pre&gt;\r\n\r\n');
INSERT INTO `lectures` (`IDLecture`, `Name`, `IDChapter`, `SerialNumber`, `IDStatus`, `Content`) VALUES
(70, 'Чтение и запись текстовых файлов. StreamReader и StreamWriter', 21, 5, 2, '&lt;p&gt;Для работы непосредственно с текстовыми файлами в пространстве System.IO определены специальные \r\nклассы: &lt;strong&gt;StreamReader&lt;/strong&gt; и &lt;strong&gt;StreamWriter&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;h3&gt;Запись в файл и StreamWriter&lt;/h3&gt;\r\n&lt;p&gt;Для записи в текстовый файл используется класс &lt;strong&gt;StreamWriter&lt;/strong&gt;. Некоторые из его конструкторов, которые могут применяться для создания объекта \r\nStreamWriter:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;StreamWriter(string path)&lt;/strong&gt;: через параметр path передается путь к файлу, который будет связан с потоком&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;StreamWriter(string path, bool append)&lt;/strong&gt;: параметр append указывает, надо ли добавлять в конец файла данные или же перезаписывать файл. \r\nЕсли равно true, то новые данные добавляются в конец файла. Если равно false, то файл перезаписываетсяя заново&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;StreamWriter(string path, bool append, System.Text.Encoding encoding)&lt;/strong&gt;: параметр encoding указывает на кодировку, которая будет \r\nприменяться при записи&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Свою функциональность StreamWriter реализует через следующие методы:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;int Close()&lt;/strong&gt;: закрывает записываемый файл и освобождает все ресурсы&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;void Flush()&lt;/strong&gt;: записывает в файл оставшиеся в буфере данные и очищает буфер.&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Task FlushAsync()&lt;/strong&gt;: асинхронная версия метода Flush&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;void Write(string value)&lt;/strong&gt;: записывает в файл данные простейших типов, как int, double, char, string и т.д. Соответственно имеет ряд перегруженных \r\nверсий для записи данных элементарных типов, например, &lt;strong&gt;Write(char value)&lt;/strong&gt;, &lt;strong&gt;Write(int value)&lt;/strong&gt;, &lt;strong&gt;Write(double value)&lt;/strong&gt; и т.д.&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Task WriteAsync(string value)&lt;/strong&gt;: асинхронная версия метода Write. Обратите внимание, что асинхронные версии есть не для всех перегрузок метода Write.&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;void WriteLine(string value)&lt;/strong&gt;: также записывает данные, только после записи добавляет в файл символ окончания строки&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Task WriteLineAsync(string value)&lt;/strong&gt;: асинхронная версия метода WriteLine&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Рассмотрим запись в файл на примере:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nstring path = &quot;note1.txt&quot;;\r\nstring text = &quot;Hello World\\nHello METANIT.COM&quot;;\r\n \r\n// полная перезапись файла \r\nusing (StreamWriter writer = new StreamWriter(path, false))\r\n{\r\n    await writer.WriteLineAsync(text);\r\n}\r\n// добавление в файл\r\nusing (StreamWriter writer = new StreamWriter(path, true))\r\n{\r\n    await writer.WriteLineAsync(&quot;Addition&quot;);\r\n    await writer.WriteAsync(&quot;4,5&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае два раза создаем объект StreamWriter. В первом случае если файл существует, то он будет перезаписан. Если не существует, он будет создан. \r\nИ в нее будет записан текст из переменной text. Во втором случае файл открывается для дозаписи, и будут записаны атомарные данные - строка и число.&lt;/p&gt;\r\n&lt;p&gt;По завершении в папке программы мы сможем найти файл note.txt, который будет иметь следующие строки:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Hello World\r\nHello METANIT.COM\r\nAddition\r\n4,5\r\n&lt;/pre&gt;\r\n\r\n&lt;p&gt;В пример выше будет использоваться кодировка по умолчанию. но также можно задать ее явным образом:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nusing (StreamWriter writer = new StreamWriter(path, true, System.Text.Encoding.Default))\r\n{\r\n    // операции с writer\r\n}\r\n&lt;/code&gt;\r\n&lt;h3&gt;Чтение из файла и StreamReader&lt;/h3&gt;\r\n&lt;p&gt;Класс StreamReader позволяет нам легко считывать весь текст или отдельные строки из текстового файла.&lt;/p&gt;\r\n&lt;p&gt;Некоторые из конструкторов класса StreamReader:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;StreamReader(string path)&lt;/strong&gt;: через параметр path передается путь к считываемому файлу&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;StreamReader(string path, System.Text.Encoding encoding)&lt;/strong&gt;: параметр encoding задает кодировку для чтения файла&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Среди методов StreamReader можно выделить следующие:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;void Close()&lt;/strong&gt;: закрывает считываемый файл и освобождает все ресурсы&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;int Peek()&lt;/strong&gt;: возвращает следующий доступный символ, если символов больше нет, то возвращает -1&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;int Read()&lt;/strong&gt;: считывает и возвращает следующий символ в численном представлении. Имеет перегруженную версию: \r\n&lt;strong&gt;Read(char[] array, int index, int count)&lt;/strong&gt;, где &lt;strong&gt;array&lt;/strong&gt; - массив, куда считываются символы, &lt;strong&gt;index&lt;/strong&gt; - индекс в массиве array, \r\nначиная с которого записываются считываемые символы, и count - максимальное количество считываемых символов&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Task&lt;int&gt; ReadAsync()&lt;/strong&gt;: асинхронная версия метода Read&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;string ReadLine()&lt;/strong&gt;: считывает одну строку в файле&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;string ReadLineAsync()&lt;/strong&gt;: асинхронная версия метода ReadLine&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;string ReadToEnd()&lt;/strong&gt;: считывает весь текст из файла&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;string ReadToEndAsync()&lt;/strong&gt;: асинхронная версия метода ReadToEnd&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Сначала считаем текст полностью из ранее записанного файла:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nstring path = &quot;note1.txt&quot;;\r\n// асинхронное чтение\r\nusing (StreamReader reader = new StreamReader(path))\r\n{\r\n    string text = await reader.ReadToEndAsync();\r\n    Console.WriteLine(text);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Считаем текст из файла построчно:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nstring path = &quot;/Users/eugene/Documents/app/note1.txt&quot;;\r\n \r\n// асинхронное чтение\r\nusing (StreamReader reader = new StreamReader(path))\r\n{\r\n    string? line;\r\n    while ((line = await reader.ReadLineAsync()) != null)\r\n    {\r\n        Console.WriteLine(line);\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае считываем построчно через цикл while: &lt;strong&gt;while ((line = await reader.ReadLineAsync()) != null)&lt;/strong&gt; - сначала присваиваем переменной line результат функции \r\n&lt;strong&gt;reader.ReadLineAsync()&lt;/strong&gt;, а затем проверяем, не равна ли она null. Когда объект sr дойдет до конца файла и больше строк не останется, то \r\nметод &lt;strong&gt;reader.ReadLineAsync()&lt;/strong&gt; будет возвращать null.&lt;/p&gt;'),
(71, 'Бинарные файлы. BinaryWriter и BinaryReader', 21, 6, 2, '&lt;p&gt;Для работы с бинарными файлами предназначена пара классов &lt;strong&gt;BinaryWriter&lt;/strong&gt; и &lt;strong&gt;BinaryReader&lt;/strong&gt;. \r\nЭти классы позволяют читать и записывать данные в двоичном формате.&lt;/p&gt;\r\n&lt;h3&gt;BinaryWriter&lt;/h3&gt;\r\n&lt;p&gt;Для создания объекта BinaryWriter можно применять ряд конструкторов. Возьмем наиболее простую:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nBinaryWriter(Stream stream)\r\n&lt;/code&gt;\r\n&lt;p&gt;в его конструктор передается объект Stream (обычно это объект FileStream).&lt;/p&gt;\r\n&lt;p&gt;Основные методы класса BinaryWriter&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Close()&lt;/strong&gt;: закрывает поток и освобождает ресурсы&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Flush()&lt;/strong&gt;: очищает буфер, дописывая из него оставшиеся данные в файл&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Seek()&lt;/strong&gt;: устанавливает позицию в потоке&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Write()&lt;/strong&gt;: записывает данные в поток. В качестве параметра этот метод может принимать значения примитивных данных:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Write(bool)&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Write(byte)&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n	\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Write(char)&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Write(decimal)&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Write(double)&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Write(Half)&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Write(short)&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Write(int)&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Write(long)&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;	\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Write(sbyte)&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Write(float)&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Write(string)&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;	\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Write(ushort)&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;	\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Write(uint)&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;	\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Write(ulong)&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Либо можно передать массивы типов byte и char&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Write(byte[])&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Write(char[])&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Write(ReadOnlySpan&lt;byte&gt;)&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Write(ReadOnlySpan&lt;char&gt;)&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;При записи массива дополнительно можно указать, с кого элемента массива надо выполнять запись, а также число записываемых элементов массива:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Write(byte[], int, int)&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Write(char[], int, int)&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Рассмотрим простейшую запись бинарного файла:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nstring path = &quot;person.dat&quot;;\r\n \r\n// создаем объект BinaryWriter\r\nusing (BinaryWriter writer = new BinaryWriter(File.Open(path, FileMode.OpenOrCreate)))\r\n{\r\n    // записываем в файл строку\r\n    writer.Write(&quot;Tom&quot;);\r\n    // записываем в файл число int\r\n    writer.Write(37);\r\n    Console.WriteLine(&quot;File has been written&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь в файл person.dat записываются два значения: строка &quot;Tom&quot; и число 37. Для создание объекта применяется вызов \r\n&lt;strong&gt;new BinaryWriter(File.Open(path, FileMode.OpenOrCreate))&lt;/strong&gt;&lt;/p&gt;\r\n&lt;p&gt;Подобным образом можно сохранять более сложные данные. Например, сохраним в файл массив объектов:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nstring path = &quot;people.dat&quot;;\r\n \r\n// массив для записи\r\nPerson[] people =\r\n{\r\n    new Person(&quot;Tom&quot;, 37),\r\n    new Person(&quot;Bob&quot;, 41)\r\n};\r\n \r\nusing (BinaryWriter writer = new BinaryWriter(File.Open(path, FileMode.OpenOrCreate)))\r\n{\r\n    // записываем в файл значение каждого свойства объекта\r\n    foreach (Person person in people)\r\n    {\r\n        writer.Write(person.Name);\r\n        writer.Write(person.Age);\r\n    }\r\n    Console.WriteLine(&quot;File has been written&quot;);\r\n}\r\n \r\nclass Person\r\n{\r\n    public string Name { get; set; }\r\n    public int Age { get; set; }\r\n    public Person(string name, int age)\r\n    {\r\n        Name = name;\r\n        Age = age;\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае последовательно сохраняем в файл people.dat данные объектов Person из массива people.&lt;/p&gt;\r\n\r\n&lt;h3&gt;BinaryReader&lt;/h3&gt;\r\n&lt;p&gt;Для создания объекта BinaryReader можно применять ряд конструкторов. Возьмем наиболее простую версию:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nReader(Stream stream)\r\n&lt;/code&gt;\r\n&lt;p&gt;в его конструктор также передается объект Stream (также обычно это объект FileStream).&lt;/p&gt;\r\n&lt;p&gt;Основные методы класса BinaryReader&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Close()&lt;/strong&gt;: закрывает поток и освобождает ресурсы&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;ReadBoolean()&lt;/strong&gt;: считывает значение bool и перемещает указатель на один байт&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;ReadByte()&lt;/strong&gt;: считывает один байт и перемещает указатель на один байт&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;ReadChar()&lt;/strong&gt;: считывает значение char, то есть один символ, и перемещает указатель на столько байтов, \r\nсколько занимает символ в текущей кодировке&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;ReadDecimal()&lt;/strong&gt;: считывает значение decimal и перемещает указатель на 16 байт&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;ReadDouble()&lt;/strong&gt;: считывает значение double и перемещает указатель на 8 байт&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;ReadInt16()&lt;/strong&gt;: считывает значение short и перемещает указатель на 2 байта&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;ReadInt32()&lt;/strong&gt;: считывает значение int и перемещает указатель на 4 байта&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;ReadInt64()&lt;/strong&gt;: считывает значение long и перемещает указатель на 8 байт&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;ReadSingle()&lt;/strong&gt;: считывает значение float и перемещает указатель на 4 байта&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;ReadString()&lt;/strong&gt;: считывает значение string. Каждая строка предваряется значением длины строки, которое представляет 7-битное \r\nцелое число&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;С чтением бинарных данных все просто: соответствующий метод считывает данные определенного типа и перемещает указатель на размер этого \r\nтипа в байтах, например, значение типа int занимает 4 байта, поэтому BinaryReader считает 4 байта и переместит указатель на эти 4 байта.&lt;/p&gt;\r\n&lt;p&gt;Например, выше в примере с BinaryWriter в файл person.dat записывалась строка и число. Считаем их с помощью BinaryReader:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nusing (BinaryReader reader = new BinaryReader(File.Open(&quot;person.dat&quot;, FileMode.Open)))\r\n{\r\n    // считываем из файла строку\r\n    string name = reader.ReadString();\r\n    // считываем из файла число \r\n    int age = reader.ReadInt32();\r\n    Console.WriteLine($&quot;Name: {name}  Age: {age}&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Конструктор класса BinaryReader также в качестве параметра принимает объект потока, только в данном \r\nслучае устанавливаем в качестве режима FileMode.Open: &lt;strong&gt;new BinaryReader(File.Open(&quot;person.dat&quot;, FileMode.Open))&lt;/strong&gt;.&lt;/p&gt;\r\n&lt;p&gt;В каком порядке данные были записаны в файл, в таком порядке мы их можем оттуда считать. То есть если сначала записывалась строка, а потом число, то в \r\nданном порядке мы их можем считать из файла.&lt;/p&gt;\r\n&lt;p&gt;Или подобным образом считаем данные из файла people.dat, который был записан в примере выше и который содержит данные объектов Person:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\n// список для считываемых данных\r\nList&lt;Person&gt; people = new List&lt;Person&gt;();\r\n \r\n// создаем объект BinaryWriter\r\nusing (BinaryReader reader = new BinaryReader(File.Open(&quot;people.dat&quot;, FileMode.Open)))\r\n{\r\n    // пока не достигнут конец файла\r\n    // считываем каждое значение из файла\r\n    while (reader.PeekChar() &gt; -1)\r\n    {\r\n        string name = reader.ReadString();\r\n        int age = reader.ReadInt32();\r\n        // по считанным данным создаем объект Person и добавляем в список\r\n        people.Add(new Person(name, age));\r\n    }\r\n}\r\n// выводим содержимое списка people на консоль\r\nforeach(Person person in people)\r\n{\r\n    Console.WriteLine($&quot;Name: {person.Name}  Age: {person.Age}&quot;);\r\n}\r\n \r\nclass Person\r\n{\r\n    public string Name { get; set; }\r\n    public int Age { get; set; }\r\n    public Person(string name, int age)\r\n    {\r\n        Name = name;\r\n        Age = age;\r\n    }\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;Здесь в цикле &lt;strong&gt;while&lt;/strong&gt; считываем данные. Чтобы узнать окончание потока, вызываем метод &lt;strong&gt;PeekChar()&lt;/strong&gt;. Этот метод считывает \r\nследующий символ и возвращает его числовое представление. Если символ отсутствует, то метод возвращает -1, что будет означать, что мы достигли конца файла.&lt;/p&gt;\r\n&lt;p&gt;В цикле последовательно считываем значения для свойств объектов Person в том же порядке, в каком они записывались.&lt;/p&gt;'),
(72, 'Архивация и сжатие файлов', 21, 7, 2, '&lt;p&gt;Кроме классов чтения-записи .NET предоставляет классы, которые позволяют сжимать файлы, а также затем восстанавливать их в исходное состояние.&lt;/p&gt;\r\n&lt;p&gt;Это классы &lt;strong&gt;ZipFile&lt;/strong&gt;, &lt;strong&gt;DeflateStream&lt;/strong&gt; и &lt;strong&gt;GZipStream&lt;/strong&gt;, которые находятся в пространстве имен \r\n&lt;strong&gt;System.IO.Compression&lt;/strong&gt; и представляют реализацию одного из алгоритмов сжатия Deflate или GZip.&lt;/p&gt;\r\n&lt;h3&gt;GZipStream и DeflateStream&lt;/h3&gt;\r\n&lt;p&gt;Для создания объекта GZipStream можно использовать один из его конструкторов:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;/p&gt;&lt;strong&gt;GZipStream(Stream stream, CompressionLevel level)&lt;/strong&gt;: stream представляет данные, а level задает уровень сжатия&lt;p&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;/p&gt;&lt;strong&gt;GZipStream(Stream stream, CompressionMode mode)&lt;/strong&gt;: mode указывает, будут ли данные сжиматься или, наоборот, восстанавливаться и может принимать два значения:&lt;p&gt;&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;CompressionMode.Compress&lt;/strong&gt;: данные сжимаются&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;CompressionMode.Decompress&lt;/strong&gt;: данные восстанавливаются&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Если данные сжимаются, то stream указывает на поток архивируемых данных. Если данные восстанавливаются, то stream указывает на поток, куда будут передаваться восстановленные данные.&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;/p&gt;&lt;strong&gt;GZipStream(Stream stream, CompressionLevel level, bool leaveMode)&lt;/strong&gt;: параметр leaveMode указывает, надо ли оставить открытым поток stream после удаления \r\nобъекта GZipStream. Если значение true, то поток остается открытым&lt;p&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;/p&gt;&lt;strong&gt;GZipStream(Stream stream, CompressionMode mode, bool leaveMode)&lt;/strong&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Для управления сжатием/восстанавлением данных GZipStream предоставляет ряд методов. Основые из них:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;/p&gt;&lt;strong&gt;void CopyTo(Stream destination)&lt;/strong&gt;: копирует все данные в поток destination&lt;p&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;/p&gt;&lt;strong&gt;Task CopyToAsync(Stream destination)&lt;/strong&gt;: асинхронная версия метода CopyTo&lt;p&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;/p&gt;&lt;strong&gt;void Flush()&lt;/strong&gt;: очищает буфер, записывая все его данные в файл&lt;p&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;/p&gt;&lt;strong&gt;Task FlushAsync()&lt;/strong&gt;: асинхронная версия метода Flush&lt;p&gt;&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;int Read(byte[] array, int offset, int count)&lt;/strong&gt;: считывает данные из файла в массив байтов и возвращает количество успешно считанных байтов. \r\nПринимает три параметра:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;array&lt;/strong&gt; - массив байтов, куда будут помещены считываемые из файла данные&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;offset&lt;/strong&gt; представляет смещение в байтах в массиве array, в который считанные байты будут помещены&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;count&lt;/strong&gt; - максимальное число байтов, предназначенных для чтения. Если в файле находится меньшее количество байтов, то \r\nвсе они будут считаны.&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;int Read(byte[] array, int offset, int count)&lt;/strong&gt;: считывает данные из файла в массив байтов и возвращает количество успешно считанных байтов. \r\nПринимает три параметра:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;array&lt;/strong&gt; - массив байтов, куда будут помещены считываемые из файла данные&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;offset&lt;/strong&gt; представляет смещение в байтах в массиве array, в который считанные байты будут помещены&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;count&lt;/strong&gt; - максимальное число байтов, предназначенных для чтения. Если в файле находится меньшее количество байтов, то \r\nвсе они будут считаны.&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Task&lt;int&gt; ReadAsync(byte[] array, int offset, int count)&lt;/strong&gt;: асинхронная версия метода Read&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;long Seek(long offset, SeekOrigin origin)&lt;/strong&gt;: устанавливает позицию в потоке со смещением на количество байт, \r\nуказанных в параметре offset.&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;void Write(byte[] array, int offset, int count)&lt;/strong&gt;: записывает в файл данные из массива байтов. Принимает три параметра: \r\n&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;array&lt;/strong&gt; - массив байтов, откуда данные будут записываться в файл&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;offset&lt;/strong&gt; - смещение в байтах в массиве array, откуда начинается запись байтов в поток&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;count&lt;/strong&gt; - максимальное число байтов, предназначенных для записи&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Task WriteAsync(byte[] array, int offset, int count)&lt;/strong&gt;: асинхронная версия метода Write&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Рассмотрим применение класса GZipStream на примере:&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nusing System.IO.Compression;\r\n \r\nstring sourceFile = &quot;book.pdf&quot;; // исходный файл\r\nstring compressedFile = &quot;book.gz&quot;; // сжатый файл\r\nstring targetFile = &quot;book_new.pdf&quot;; // восстановленный файл\r\n \r\n// создание сжатого файла\r\nawait CompressAsync(sourceFile, compressedFile);\r\n// чтение из сжатого файла\r\nawait DecompressAsync(compressedFile, targetFile);\r\n \r\nasync Task CompressAsync(string sourceFile, string compressedFile)\r\n{\r\n    // поток для чтения исходного файла\r\n    using FileStream sourceStream = new FileStream(sourceFile, FileMode.OpenOrCreate);\r\n    // поток для записи сжатого файла\r\n    using FileStream targetStream = File.Create(compressedFile);\r\n \r\n    // поток архивации\r\n    using GZipStream compressionStream = new GZipStream(targetStream, CompressionMode.Compress);\r\n    await sourceStream.CopyToAsync(compressionStream); // копируем байты из одного потока в другой\r\n \r\n    Console.WriteLine($&quot;Сжатие файла {sourceFile} завершено.&quot;);\r\n    Console.WriteLine($&quot;Исходный размер: {sourceStream.Length}  сжатый размер: {targetStream.Length}&quot;);\r\n}\r\n \r\nasync Task DecompressAsync(string compressedFile, string targetFile)\r\n{\r\n    // поток для чтения из сжатого файла\r\n    using FileStream sourceStream = new FileStream(compressedFile, FileMode.OpenOrCreate);\r\n    // поток для записи восстановленного файла\r\n    using FileStream targetStream = File.Create(targetFile);\r\n    // поток разархивации\r\n    using GZipStream decompressionStream = new GZipStream(sourceStream, CompressionMode.Decompress);\r\n    await decompressionStream.CopyToAsync(targetStream);\r\n    Console.WriteLine($&quot;Восстановлен файл: {targetFile}&quot;);\r\n}\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае подразумевается, что в папке с программой располагается файл book.pdf, который собственно и будет архивироваться.&lt;/p&gt;\r\n&lt;p&gt;Метод &lt;strong&gt;CompressAsync&lt;/strong&gt; получает название исходного файла, который надо архивировать, и название будущего сжатого файла.&lt;/p&gt;\r\n&lt;p&gt;Сначала создается поток для чтения из исходного файла - &lt;strong&gt;FileStream sourceStream&lt;/strong&gt;. Затем создается поток для записи в сжатый файл - \r\n&lt;strong&gt;FileStream targetStream&lt;/strong&gt;. Поток архивации &lt;strong&gt;GZipStream compressionStream&lt;/strong&gt; инициализируется потоком targetStream и с помощью \r\nметода &lt;strong&gt;CopyToAsync()&lt;/strong&gt; получает данные от потока sourceStream.&lt;/p&gt;\r\n&lt;p&gt;Метод &lt;strong&gt;DecompressAsync&lt;/strong&gt; производит обратную операцию по восстановлению сжатого файла в исходное состояние. Он принимает в качестве параметров \r\nпути к сжатому файлу и будущему восстановленному файлу.&lt;/p&gt;\r\n&lt;p&gt;Здесь в начале создается поток для чтения из сжатого файла &lt;strong&gt;FileStream sourceStream&lt;/strong&gt;, затем поток для записи в восстанавливаемый файл \r\n&lt;strong&gt;FileStream targetStream&lt;/strong&gt;. В конце создается поток &lt;strong&gt;GZipStream decompressionStream&lt;/strong&gt;,  который с помощью метода \r\n&lt;strong&gt;CopyToAsync()&lt;/strong&gt; копирует восстановленные данные в поток targetStream.&lt;/p&gt;\r\n&lt;p&gt;Чтобы указать потоку GZipStream, для чего именно он предназначен - сжатия или восстановления - ему в конструктор передается параметр CompressionMode, \r\nпринимающий два значения: Compress и Decompress.&lt;/p&gt;\r\n&lt;p&gt;Пример консольного вывода программы:&lt;/p&gt;\r\n\r\n&lt;pre style=&quot;background: black; color: white; padding: 5px;&quot;&gt;Сжатие файла book.pdf завершено.\r\nИсходный размер: 3235353  сжатый размер: 2574401\r\nВосстановлен файл: book_new.pdf\r\n&lt;/pre&gt;\r\n\r\n&lt;p&gt;Если бы захотели бы использовать другой класс сжатия - DeflateStream, то мы могли бы просто заменить в коде упоминания GZipStream на DeflateStream, \r\nбез изменения остального кода. Их использование идентично.&lt;/p&gt;\r\n&lt;p&gt;В то же время при использовании этих классов есть некоторые ограничения, в частности, мы можем сжимать только один файл. Для архивации группы файлы \r\nлучше выбрать другие инструменты, например, ZipFile.&lt;/p&gt;\r\n&lt;h3&gt;ZipFile&lt;/h3&gt;\r\n&lt;p&gt;Статический класс &lt;strong&gt;ZipFile&lt;/strong&gt; из простанства имен System.IO.Compression предоставляет дополнительные возможности для создания архивов. Он позволяет создавать архив из каталогов. \r\nЕго основные методы:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;void CreateFromDirectory(string sourceDirectoryName, string destinationFileName)&lt;/strong&gt;: архивирует папку по пути sourceDirectoryName в \r\nфайл с названием destinationFileName&lt;/p&gt;&lt;/li&gt;\r\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;void ExtractToDirectory(string sourceFileName, string destinationDirectoryName)&lt;/strong&gt;: извлекает все файлы из zip-файла sourceFileName в каталог destinationDirectoryName&lt;/p&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;Оба метода имеют ряд дополнительных перегруженных версий. Рассмотрим их применение.&lt;/p&gt;\r\n&lt;code&gt;\r\n\r\nusing System.IO.Compression;\r\n \r\nstring sourceFolder = &quot;D://test/&quot;; // исходная папка\r\nstring zipFile = &quot;D://test.zip&quot;; // сжатый файл\r\nstring targetFolder = &quot;D://newtest&quot;; // папка, куда распаковывается файл\r\n \r\nZipFile.CreateFromDirectory(sourceFolder, zipFile);\r\nConsole.WriteLine($&quot;Папка {sourceFolder} архивирована в файл {zipFile}&quot;);\r\nZipFile.ExtractToDirectory(zipFile, targetFolder);\r\n \r\nConsole.WriteLine($&quot;Файл {zipFile} распакован в папку {targetFolder}&quot;);\r\n&lt;/code&gt;\r\n&lt;p&gt;В данном случае папка &quot;D://test/&quot; методом &lt;strong&gt;ZipFile.CreateFromDirectory&lt;/strong&gt; архивируется в файл test.zip. Затем метод \r\n&lt;strong&gt;ZipFile.ExtractToDirectory()&lt;/strong&gt; распаковывает данный файл в папку &quot;D://newtest&quot; (если такой папки нет, она создается).&lt;/p&gt;\r\n');

-- --------------------------------------------------------

--
-- Структура таблицы `lecture_recommended`
--

CREATE TABLE `lecture_recommended` (
  `IDString` int NOT NULL,
  `IDResult` int NOT NULL,
  `IDLecture` int NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;

--
-- Дамп данных таблицы `lecture_recommended`
--

INSERT INTO `lecture_recommended` (`IDString`, `IDResult`, `IDLecture`) VALUES
(1, 9, 5),
(2, 10, 7),
(3, 10, 7),
(4, 14, 7),
(5, 15, 7),
(6, 16, 7),
(7, 16, 5),
(8, 17, 7),
(9, 17, 5),
(10, 18, 7),
(11, 18, 5),
(12, 19, 3),
(13, 19, 5),
(14, 19, 7),
(15, 20, 5),
(16, 20, 7),
(17, 21, 3),
(18, 21, 5),
(19, 21, 7),
(20, 22, 3),
(21, 22, 5),
(22, 22, 7),
(23, 23, 3),
(24, 23, 5),
(25, 23, 7),
(26, 24, 5),
(27, 24, 7),
(28, 25, 5),
(29, 25, 7),
(30, 26, 3),
(31, 26, 5),
(32, 26, 7),
(33, 27, 3),
(34, 27, 5),
(35, 27, 7),
(36, 28, 3),
(37, 28, 5),
(38, 28, 7),
(42, 29, 3),
(43, 29, 5),
(44, 29, 7),
(45, 30, 7),
(46, 31, 5),
(47, 31, 7),
(48, 32, 3),
(49, 32, 5),
(50, 32, 7),
(51, 34, 3),
(52, 34, 7),
(53, 35, 3),
(54, 35, 5),
(55, 35, 7),
(56, 36, 7),
(57, 37, 7),
(58, 38, 3),
(59, 38, 7),
(60, 39, 7),
(61, 40, 7),
(62, 41, 3),
(63, 41, 5),
(64, 42, 3),
(65, 42, 5),
(66, 42, 7),
(67, 55, 19),
(68, 55, 38),
(69, 55, 10),
(70, 56, 11),
(71, 56, 21),
(72, 57, 5),
(73, 57, 38),
(74, 57, 10),
(75, 57, 43),
(76, 57, 4),
(77, 57, 55);

-- --------------------------------------------------------

--
-- Структура таблицы `questions`
--

CREATE TABLE `questions` (
  `IDQuestion` int NOT NULL,
  `Name` varchar(5000) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `Code` varchar(5000) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL,
  `IDType` int NOT NULL,
  `IDTest` int NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;

--
-- Дамп данных таблицы `questions`
--

INSERT INTO `questions` (`IDQuestion`, `Name`, `Code`, `IDType`, `IDTest`) VALUES
(111, 'тест&quot;', 'тест', 1, 6),
(112, '111', '', 3, 6),
(113, '', '', 1, 7),
(193, 'Что будет на выходе следующей программы?', 'public class Program\n{\n	public static void Main()\n	{\n		Person per = new Person();\n		Console.WriteLine(per.Id); \n	}\n}\n\npublic class Person\n{\n	public int Id;\n}', 1, 3),
(194, 'Что будет на выходе следующей программы? ', 'public static void Main()\n{\n	var x;\n	x=100;\n	Console.WriteLine(x); \n}', 1, 3),
(195, 'Какой из следующих типов данных следует использовать для денежного выражения?', '', 1, 3),
(196, 'Что будет на выходе следующей программы? ', 'public static void Main()\n{\n    float f = 10.12f;\n    long l = 200L;\n\n    Console.WriteLine(f+l);\n}\n', 1, 3),
(197, 'Что будет на выходе следующей программы? ', 'public static void Main(string[] args)\n{\n    int i = 2;\n	   \n 	Console.Write(++i);  \n	Console.Write(i++);\n	Console.Write(i);  \n}', 4, 3),
(198, 'Какой модификатор доступа по умолчанию для членов класса?', '', 3, 3),
(199, 'Что будет на выходе следующей программы? ', 'public static void Main(string[] args)\n{\n	string str1 = &quot;Hi&quot;;\n	string str2 = String.Copy(str1);\n		\n	Console.Write(Object.ReferenceEquals(str1, str2));\n}\n', 1, 3),
(200, 'Что будет на выходе следующей программы? ', 'for (double d = 1.01D; d &amp;lt; 1.05; d+= 0.01D)\n{\n    Console.Write(&quot;{0}, &quot;, d);\n}\n', 1, 3),
(201, 'Что будет на выходе следующей программы? ', 'public class Program\n{\n	public static void Main()\n	{\n		WorkingDays.Wednesday= 5;\n		Console.Write(WeekDays.Wednesday);\n	}\n}\n\nenum WorkingDays\n{\n    Monday,\n    Tuesday,\n    Wednesday,\n    Thursday,\n    Friday\n}\n', 1, 3),
(202, 'Какое из следующих объявлений массива допустимо?', '', 2, 3),
(212, 'Что будет на выходе следующей программы? ', 'public class Program\n{\n	public static void Main()\n	{\n		int?[] arr = new int?[5];\n		Console.WriteLine(arr[0]); \n	}\n}', 1, 4),
(213, 'Как бы вы объявили событие для следующего делегата?', 'public delegate void ClickHandler();', 2, 4),
(214, 'Что будет на выходе следующей программы? ', 'public static void Main()\n{\n	var i=10, j=2, k=3;\n	Console.WriteLine(k=i*j); \n}\n', 1, 4),
(215, 'Если вы хотите сохранить положительное целое значение до 250. Какой из следующих типов данных вы будете использовать для переменной? ', '', 1, 4),
(216, 'Что будет на выходе следующей программы? ', 'Console.WriteLine(Convert.ToInt32(&#039;A&#039;));', 1, 4),
(217, 'Что будет на выходе следующей программы? ', 'public static void Main(string[] args)\n{\n    test();     \n}\n	\nvoid test(){\n	Console.Write(&quot;test()&quot;);\n}', 1, 4),
(218, 'Что будет на выходе следующей программы? ', 'class Program\n{\n    static void Main()\n    {\n        Person p = new Person() {\n                Id = 1\n        };\n\n        Console.Write(p.ToString());\n    }\n}\n\nclass Person\n{\n	public int Id;\n\n	public override string ToString() =&gt; this.Id.ToString();\n}', 4, 4),
(219, 'Какое ключевое слово используется для создания исключения вручную? ', '', 3, 4),
(220, 'Перечисление не может быть объявлено внутри метода. ', '', 1, 4),
(222, '1', '', 1, 8),
(223, '2', '', 1, 9),
(235, 'Что будет на выходе следующей программы? ', 'public static void Main()\n{ \n    int i; \n    Console.WriteLine(i); \n}', 1, 2),
(236, 'Что будет на выходе следующей программы? ', 'int i = 5, j;\nConsole.WriteLine(j=i*2); ', 1, 2),
(237, 'Что будет на выходе следующей программы? ', 'public static void Main()\n{\n	int k;\n	display(k);\n}\n	\nstatic void display(int val = 0)\n{\n	Console.Write(val);\n}', 1, 2),
(238, 'Какой из тип данных может включать максимальное положительное или отрицательное, целое число или значение с плавающей запятой?', '', 3, 2),
(239, 'Что будет на выходе следующей программы? ', 'public static void Main(string[] args)\n{\n    int a = 1, b = 2, c = 3;\n  \n    Console.Write((a*b)+(b*c));   \n}', 4, 2),
(240, 'Что из следующего является модификатором доступа по умолчанию в пространстве имен? ', '', 1, 2),
(241, 'Конструктор в классе может иметь возвращаемый тип. ', '', 1, 2),
(242, 'Что из следующего является правильным способом инициализации массива?', '', 2, 2),
(243, 'Что будет на выходе следующей программы? ', 'int i = 0;\n\nfor(;;)\n{\n    if (i &lt; 5)\n        Console.Write(i);\n    else\n        break;\n	i++;\n}', 1, 2),
(244, 'Что будет на выходе следующей программы? ', 'public static void Main()\n{\n	int val = GetVal();\n}\n	\npublic static int GetVal(){\n	int[] arr = {1, 2, 3, 4, 5};\n	try\n    {\n        return arr[10];\n    }\n	catch(Exception ex){\n        Console.WriteLine(&quot;Произошла ошибка!&quot;);\n	}\n	finally{\n		return 0;\n	}\n}', 1, 2),
(245, 'Какой из следующих методов является точкой входа в консольную программу C#? ', '', 1, 1),
(246, 'Какие из следующих типов являются типами значений в C#? ', '', 2, 1),
(247, 'Что из следующего является ссылочным типом в C#? ', '', 1, 1),
(248, 'Структура это ', '', 1, 1),
(249, 'Что из следующего является правильным способом объявления массива в C#?', '', 1, 1),
(250, 'Какое ключевое слово используется, чтобы при создании переменной её тип был определен автоматически?', '', 3, 1),
(251, 'Сколько бит в памяти занимает переменная типа Integer?', '', 4, 1),
(252, 'Все массивы начинаются с _____ индекса.', '', 1, 1),
(253, 'Что из следующего верно для переменных, доступных только для чтения?', '', 1, 1),
(254, 'Какое из следующих утверждений верно? ', '', 2, 1),
(255, 'Переменные типа значения в C# являются производными от класса System.ValueType.', '', 1, 5),
(256, 'Что будет на выходе следующей программы? ', 'static void Main()\n{\n    Predicate&lt;int&gt; GetBool = delegate (int val)\n    {\n        if (val &lt;= 0)\n            return false;\n        else\n            return true;\n    };\n    Console.Write(GetBool(-1));\n} \n', 1, 5),
(257, 'Что будет на выходе следующей программы? ', 'class Program\n{\n    static void Main(string[] args)\n    {\n        Processor&lt;int&gt; p = new Processor&lt;int&gt;();\n        p.BaseValue = 1;\n        int result = p.Add(10);\n            \n        Console.Write(result);\n    }\n}\n\nclass Processor&lt;T&gt;\n{\n    public int Add(int value) {\n        return this.BaseValue + value;\n    }\n    public T BaseValue { get; set; }\n}\n', 1, 5),
(258, 'Как бы вы переписали следующее условие?', 'int a = 15, b = 9, c;\nif (a &gt; b) \n    c = b;\nelse\n    c = a;', 1, 5),
(259, 'Что из следующего не поддерживается в C#?', '', 2, 5),
(260, 'Класс может наследовать одну или несколько структур.', '', 1, 5),
(261, 'Что будет на выходе следующей программы? ', 'class Person\n{\n    public void Introduction(){ \n        Console.WriteLine(&quot;I am a person.&quot;);\n    }\n\n    public void Introduction(string name){ \n        Console.WriteLine(&quot;My name is &quot; + name);\n    }\n        \n    public void Introduction(string name, int age = 0){ \n        Console.WriteLine($&quot;My name is {name} and I am {age} years old.&quot;);\n    }\n        \n}\n\nPerson p = new Person();\np.Introduction(&quot;Steve&quot;);\n', 3, 5),
(262, 'Какое из следующих ключевых слов используется для указания того, что поле может быть изменено несколькими потоками, выполняющимися одновременно?', '', 1, 5),
(263, 'Какие из следующих типов возвращаемых значений могут быть у асинхронного метода?', '', 2, 5),
(264, 'Какой из следующих операторов не выдает исключение, если приведение не удается?', '', 1, 5),
(265, 'Какое время ожидания в секундах будет у Task?', 'await Task.Delay(3000);', 4, 5);

-- --------------------------------------------------------

--
-- Структура таблицы `questions_lectures`
--

CREATE TABLE `questions_lectures` (
  `IDString` int NOT NULL,
  `IDQuestion` int NOT NULL,
  `IDLecture` int NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;

--
-- Дамп данных таблицы `questions_lectures`
--

INSERT INTO `questions_lectures` (`IDString`, `IDQuestion`, `IDLecture`) VALUES
(112, 193, 10),
(113, 194, 7),
(114, 195, 7),
(115, 196, 9),
(116, 197, 9),
(117, 198, 11),
(118, 199, 11),
(119, 200, 18),
(120, 201, 21),
(131, 212, 19),
(132, 213, 38),
(133, 213, 38),
(134, 214, 9),
(135, 215, 7),
(136, 216, 7),
(137, 217, 4),
(138, 218, 10),
(139, 219, 32),
(140, 220, 21),
(152, 235, 5),
(153, 236, 5),
(154, 237, 9),
(155, 238, 7),
(156, 239, 4),
(157, 240, 25),
(158, 241, 11),
(159, 242, 19),
(160, 243, 18),
(161, 244, 32),
(162, 245, 4),
(163, 246, 7),
(164, 247, 7),
(165, 248, 7),
(166, 249, 19),
(167, 250, 5),
(168, 251, 1),
(169, 252, 19),
(170, 253, 5),
(171, 254, 32),
(172, 255, 5),
(173, 256, 38),
(174, 257, 24),
(175, 258, 9),
(176, 259, 10),
(177, 259, 43),
(178, 259, 4),
(179, 260, 10),
(180, 262, 55),
(181, 263, 58),
(182, 265, 60);

-- --------------------------------------------------------

--
-- Структура таблицы `question_type`
--

CREATE TABLE `question_type` (
  `IDType` int NOT NULL,
  `Name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;

--
-- Дамп данных таблицы `question_type`
--

INSERT INTO `question_type` (`IDType`, `Name`) VALUES
(1, 'Один правильный ответ'),
(2, 'Несколько правильных ответов'),
(3, 'Ввод строки'),
(4, 'Ввод числа');

-- --------------------------------------------------------

--
-- Структура таблицы `tests`
--

CREATE TABLE `tests` (
  `IDTest` int NOT NULL,
  `Name` varchar(200) COLLATE utf8mb4_general_ci NOT NULL,
  `IDComplexity` int NOT NULL,
  `IDStatus` int NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;

--
-- Дамп данных таблицы `tests`
--

INSERT INTO `tests` (`IDTest`, `Name`, `IDComplexity`, `IDStatus`) VALUES
(1, 'C# переменные, типы данных, структуры, операторы, перечисления, массивы, обработка ошибок, делегаты', 1, 2),
(2, 'C# переменные, типы данных, операторы, циклы, перечисления, коллекции, исключения', 1, 2),
(3, 'Типы данных, классы, структуры, коллекции, делегаты, функции', 2, 2),
(4, 'Типы данных, циклы, объектно-ориентированное программирование', 2, 2),
(5, 'Делегаты, события, файлы ввода-вывода', 3, 2),
(6, 'тест&quot;', 2, 3),
(7, '', 1, 3),
(8, '2', 1, 3),
(9, '2', 1, 3);

-- --------------------------------------------------------

--
-- Структура таблицы `test_complexity`
--

CREATE TABLE `test_complexity` (
  `IDСomplexity` int NOT NULL,
  `Name` varchar(30) COLLATE utf8mb4_general_ci NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;

--
-- Дамп данных таблицы `test_complexity`
--

INSERT INTO `test_complexity` (`IDСomplexity`, `Name`) VALUES
(1, 'Легкая'),
(2, 'Средняя'),
(3, 'Сложная');

-- --------------------------------------------------------

--
-- Структура таблицы `test_results`
--

CREATE TABLE `test_results` (
  `IDResult` int NOT NULL,
  `IDTest` int NOT NULL,
  `IDUser` int NOT NULL,
  `Score` int NOT NULL,
  `Date` date NOT NULL,
  `Time` time NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;

--
-- Дамп данных таблицы `test_results`
--

INSERT INTO `test_results` (`IDResult`, `IDTest`, `IDUser`, `Score`, `Date`, `Time`) VALUES
(1, 1, 1, 0, '2022-02-13', '00:00:00'),
(2, 1, 1, 0, '2022-02-13', '00:00:00'),
(3, 1, 1, 0, '2022-02-13', '00:00:00'),
(4, 1, 1, 0, '2022-02-13', '00:00:00'),
(5, 1, 1, 0, '2022-02-08', '00:00:00'),
(6, 1, 1, 0, '2022-02-13', '00:00:00'),
(7, 1, 1, 0, '2022-02-13', '00:00:00'),
(8, 1, 1, 0, '2022-02-13', '00:00:00'),
(9, 1, 1, 0, '2022-02-13', '00:00:00'),
(10, 1, 1, 0, '2022-02-13', '00:00:00'),
(11, 1, 1, 5, '2022-02-14', '00:00:00'),
(12, 1, 1, 5, '2022-02-14', '00:00:00'),
(13, 1, 1, 4, '2022-02-14', '00:00:00'),
(14, 1, 1, 4, '2022-02-14', '00:00:00'),
(15, 1, 1, 3, '2022-02-14', '00:00:00'),
(16, 1, 1, 2, '2022-02-14', '00:00:00'),
(17, 1, 1, 3, '2022-02-14', '00:00:00'),
(18, 1, 1, 3, '2022-02-14', '00:00:00'),
(19, 1, 1, 0, '2022-02-14', '00:00:00'),
(20, 1, 1, 3, '2022-02-14', '00:00:00'),
(21, 1, 1, 2, '2022-02-14', '00:00:00'),
(22, 1, 1, 0, '2022-02-14', '00:00:00'),
(23, 1, 1, 0, '2022-02-14', '00:00:00'),
(24, 1, 1, 2, '2022-02-16', '00:00:00'),
(25, 1, 1, 2, '2022-02-16', '00:00:00'),
(26, 1, 1, 2, '2022-02-16', '00:00:00'),
(27, 1, 1, 2, '2022-02-16', '00:00:00'),
(28, 1, 1, 1, '2022-02-20', '00:00:00'),
(29, 1, 1, 1, '2022-02-25', '19:23:50'),
(30, 1, 1, 6, '2022-02-25', '19:25:13'),
(31, 1, 1, 1, '2022-02-25', '22:46:33'),
(32, 1, 1, 0, '2022-02-26', '10:06:52'),
(33, 1, 1, 7, '2022-03-03', '12:41:29'),
(34, 1, 1, 4, '2022-03-03', '12:49:50'),
(35, 1, 1, 1, '2022-03-05', '19:26:34'),
(36, 1, 2, 4, '2022-03-19', '16:55:47'),
(37, 1, 2, 4, '2022-03-19', '16:58:25'),
(38, 1, 1, 3, '2022-03-19', '17:01:38'),
(39, 1, 2, 5, '2022-03-19', '17:02:49'),
(40, 1, 1, 5, '2022-03-20', '14:11:06'),
(41, 1, 1, 4, '2022-03-20', '14:13:17'),
(42, 1, 1, 0, '2022-03-21', '17:10:03'),
(43, 6, 13, 1, '2022-03-23', '21:08:26'),
(44, 6, 2, 1, '2022-03-23', '21:08:42'),
(45, 6, 2, 0, '2022-03-23', '21:09:03'),
(46, 6, 2, 1, '2022-03-23', '22:26:46'),
(47, 6, 2, 1, '2022-03-23', '22:27:38'),
(48, 6, 2, 2, '2022-03-23', '22:27:56'),
(49, 6, 2, 2, '2022-03-23', '22:27:59'),
(50, 6, 2, 2, '2022-03-23', '22:28:01'),
(51, 6, 1, 1, '2022-03-23', '22:29:44'),
(52, 1, 1, 10, '2022-03-24', '07:34:17'),
(53, 2, 1, 9, '2022-03-24', '08:30:12'),
(54, 2, 1, 10, '2022-03-24', '08:32:59'),
(55, 4, 1, 6, '2022-03-24', '19:25:47'),
(56, 3, 1, 8, '2022-03-24', '19:39:36'),
(57, 5, 1, 6, '2022-03-24', '20:02:54'),
(58, 5, 2, 10, '2022-03-24', '20:40:30'),
(59, 5, 2, 6, '2022-03-24', '20:41:46'),
(60, 5, 2, 8, '2022-03-24', '20:41:46'),
(61, 5, 2, 10, '2022-03-24', '20:41:46'),
(62, 5, 2, 10, '2022-03-24', '20:41:46'),
(63, 5, 2, 9, '2022-03-24', '20:41:46'),
(64, 5, 2, 5, '2022-03-24', '20:41:46'),
(65, 5, 2, 11, '2022-03-24', '20:41:46'),
(66, 5, 2, 11, '2022-03-24', '20:41:46'),
(67, 5, 2, 6, '2022-03-24', '20:41:46'),
(68, 5, 2, 11, '2022-03-24', '20:41:46'),
(69, 5, 2, 4, '2022-03-24', '20:41:46'),
(70, 5, 2, 0, '2022-03-24', '20:41:46'),
(71, 5, 2, 6, '2022-03-24', '20:41:46'),
(72, 5, 2, 4, '2022-03-24', '20:41:46'),
(73, 5, 2, 11, '2022-03-24', '20:41:46'),
(74, 5, 2, 0, '2022-03-24', '20:41:46'),
(75, 5, 2, 3, '2022-03-24', '20:41:46'),
(76, 5, 2, 1, '2022-03-24', '20:41:46'),
(77, 5, 2, 11, '2022-03-24', '20:41:46'),
(78, 5, 2, 2, '2022-03-24', '20:41:46'),
(79, 5, 2, 0, '2022-03-24', '20:41:46'),
(80, 5, 2, 1, '2022-03-24', '20:41:46'),
(81, 5, 2, 4, '2022-03-24', '20:41:46'),
(82, 5, 2, 11, '2022-03-24', '20:41:46'),
(83, 5, 2, 3, '2022-03-24', '20:41:46'),
(84, 5, 2, 1, '2022-03-24', '20:41:46'),
(85, 5, 2, 3, '2022-03-24', '20:41:46'),
(86, 5, 2, 9, '2022-03-24', '20:41:46'),
(87, 5, 2, 4, '2022-03-24', '20:41:46'),
(88, 5, 2, 3, '2022-03-24', '20:41:46'),
(89, 5, 2, 3, '2022-03-24', '20:41:46'),
(90, 5, 2, 7, '2022-03-24', '20:41:46'),
(91, 5, 2, 0, '2022-03-24', '20:41:46'),
(92, 5, 2, 10, '2022-03-24', '20:41:46'),
(93, 5, 2, 6, '2022-03-24', '20:41:46'),
(94, 5, 2, 5, '2022-03-24', '20:41:46'),
(95, 5, 2, 6, '2022-03-24', '20:41:46'),
(96, 5, 2, 2, '2022-03-24', '20:41:46'),
(97, 5, 2, 1, '2022-03-24', '20:41:46'),
(98, 5, 2, 9, '2022-03-24', '20:41:46'),
(99, 5, 2, 11, '2022-03-24', '20:41:46'),
(100, 5, 2, 5, '2022-03-24', '20:41:46'),
(101, 5, 2, 11, '2022-03-24', '20:41:46'),
(102, 5, 2, 8, '2022-03-24', '20:41:46'),
(103, 5, 2, 2, '2022-03-24', '20:41:46'),
(104, 5, 2, 6, '2022-03-24', '20:41:46'),
(105, 5, 2, 8, '2022-03-24', '20:41:46'),
(106, 5, 2, 7, '2022-03-24', '20:41:46'),
(107, 5, 2, 7, '2022-03-24', '20:41:46'),
(108, 5, 2, 3, '2022-03-24', '20:41:46'),
(109, 5, 2, 9, '2022-03-24', '20:41:46'),
(110, 5, 2, 2, '2022-03-24', '20:41:46'),
(111, 5, 2, 4, '2022-03-24', '20:41:46'),
(112, 5, 2, 11, '2022-03-24', '20:41:46'),
(113, 5, 2, 9, '2022-03-24', '20:41:46'),
(114, 5, 2, 2, '2022-03-24', '20:41:46'),
(115, 5, 2, 5, '2022-03-24', '20:41:46'),
(116, 5, 2, 8, '2022-03-24', '20:41:46'),
(117, 5, 2, 9, '2022-03-24', '20:41:46'),
(118, 5, 2, 10, '2022-03-24', '20:41:46'),
(119, 5, 2, 6, '2022-03-24', '20:41:46'),
(120, 5, 2, 1, '2022-03-24', '20:41:46'),
(121, 5, 2, 7, '2022-03-24', '20:41:46'),
(122, 5, 2, 0, '2022-03-24', '20:41:46'),
(123, 5, 2, 7, '2022-03-24', '20:41:46'),
(124, 5, 2, 0, '2022-03-24', '20:41:46'),
(125, 5, 2, 4, '2022-03-24', '20:41:46'),
(126, 5, 2, 5, '2022-03-24', '20:41:46'),
(127, 5, 2, 6, '2022-03-24', '20:41:46'),
(128, 5, 2, 11, '2022-03-24', '20:41:46'),
(129, 5, 2, 2, '2022-03-24', '20:41:46'),
(130, 5, 2, 8, '2022-03-24', '20:41:46'),
(131, 5, 2, 4, '2022-03-24', '20:41:46'),
(132, 5, 2, 2, '2022-03-24', '20:41:46'),
(133, 5, 2, 1, '2022-03-24', '20:41:46'),
(134, 5, 2, 11, '2022-03-24', '20:41:46'),
(135, 5, 2, 5, '2022-03-24', '20:41:46'),
(136, 5, 2, 10, '2022-03-24', '20:41:46'),
(137, 5, 2, 7, '2022-03-24', '20:41:46'),
(138, 5, 2, 7, '2022-03-24', '20:41:46'),
(139, 5, 2, 1, '2022-03-24', '20:41:46'),
(140, 5, 2, 10, '2022-03-24', '20:41:46'),
(141, 5, 2, 9, '2022-03-24', '20:41:46'),
(142, 5, 2, 9, '2022-03-24', '20:41:46'),
(143, 5, 2, 1, '2022-03-24', '20:41:46'),
(144, 5, 2, 5, '2022-03-24', '20:41:46'),
(145, 5, 2, 8, '2022-03-24', '20:41:46'),
(146, 5, 2, 5, '2022-03-24', '20:41:46'),
(147, 5, 2, 0, '2022-03-24', '20:41:46'),
(148, 5, 2, 3, '2022-03-24', '20:41:46'),
(149, 5, 2, 9, '2022-03-24', '20:41:46'),
(150, 5, 2, 3, '2022-03-24', '20:41:46'),
(151, 5, 2, 1, '2022-03-24', '20:41:46'),
(152, 5, 2, 2, '2022-03-24', '20:41:46'),
(153, 5, 2, 7, '2022-03-24', '20:41:46'),
(154, 5, 2, 4, '2022-03-24', '20:41:46'),
(155, 5, 2, 1, '2022-03-24', '20:41:46'),
(156, 5, 2, 11, '2022-03-24', '20:41:46'),
(157, 5, 2, 1, '2022-03-24', '20:41:46'),
(158, 5, 2, 10, '2022-03-24', '20:41:46'),
(159, 5, 2, 2, '2022-03-24', '20:42:03'),
(160, 5, 2, 1, '2022-03-24', '20:42:03'),
(161, 5, 2, 5, '2022-03-24', '20:42:03'),
(162, 5, 2, 6, '2022-03-24', '20:42:03'),
(163, 5, 2, 8, '2022-03-24', '20:42:03'),
(164, 5, 2, 11, '2022-03-24', '20:42:03'),
(165, 5, 2, 8, '2022-03-24', '20:42:03'),
(166, 5, 2, 9, '2022-03-24', '20:42:03'),
(167, 5, 2, 2, '2022-03-24', '20:42:03'),
(168, 5, 2, 0, '2022-03-24', '20:42:03'),
(169, 5, 2, 6, '2022-03-24', '20:42:03'),
(170, 5, 2, 10, '2022-03-24', '20:42:03'),
(171, 5, 2, 10, '2022-03-24', '20:42:03'),
(172, 5, 2, 1, '2022-03-24', '20:42:03'),
(173, 5, 2, 4, '2022-03-24', '20:42:03'),
(174, 5, 2, 7, '2022-03-24', '20:42:03'),
(175, 5, 2, 1, '2022-03-24', '20:42:03'),
(176, 5, 2, 4, '2022-03-24', '20:42:03'),
(177, 5, 2, 9, '2022-03-24', '20:42:03'),
(178, 5, 2, 0, '2022-03-24', '20:42:03'),
(179, 5, 2, 0, '2022-03-24', '20:42:03'),
(180, 5, 2, 1, '2022-03-24', '20:42:03'),
(181, 5, 2, 5, '2022-03-24', '20:42:03'),
(182, 5, 2, 3, '2022-03-24', '20:42:03'),
(183, 5, 2, 5, '2022-03-24', '20:42:03'),
(184, 5, 2, 6, '2022-03-24', '20:42:03'),
(185, 5, 2, 1, '2022-03-24', '20:42:03'),
(186, 5, 2, 0, '2022-03-24', '20:42:03'),
(187, 5, 2, 10, '2022-03-24', '20:42:03'),
(188, 5, 2, 0, '2022-03-24', '20:42:03'),
(189, 5, 2, 0, '2022-03-24', '20:42:03'),
(190, 5, 2, 0, '2022-03-24', '20:42:03'),
(191, 5, 2, 8, '2022-03-24', '20:42:03'),
(192, 5, 2, 4, '2022-03-24', '20:42:03'),
(193, 5, 2, 8, '2022-03-24', '20:42:03'),
(194, 5, 2, 2, '2022-03-24', '20:42:03'),
(195, 5, 2, 2, '2022-03-24', '20:42:03'),
(196, 5, 2, 9, '2022-03-24', '20:42:03'),
(197, 5, 2, 9, '2022-03-24', '20:42:03'),
(198, 5, 2, 6, '2022-03-24', '20:42:03'),
(199, 5, 2, 5, '2022-03-24', '20:42:03'),
(200, 5, 2, 4, '2022-03-24', '20:42:03'),
(201, 5, 2, 1, '2022-03-24', '20:42:03'),
(202, 5, 2, 10, '2022-03-24', '20:42:03'),
(203, 5, 2, 1, '2022-03-24', '20:42:03'),
(204, 5, 2, 2, '2022-03-24', '20:42:03'),
(205, 5, 2, 5, '2022-03-24', '20:42:03'),
(206, 5, 2, 11, '2022-03-24', '20:42:03'),
(207, 5, 2, 5, '2022-03-24', '20:42:03'),
(208, 5, 2, 9, '2022-03-24', '20:42:03'),
(209, 5, 2, 5, '2022-03-24', '20:42:03'),
(210, 5, 2, 6, '2022-03-24', '20:42:03'),
(211, 5, 2, 7, '2022-03-24', '20:42:03'),
(212, 5, 2, 0, '2022-03-24', '20:42:03'),
(213, 5, 2, 6, '2022-03-24', '20:42:04'),
(214, 5, 2, 11, '2022-03-24', '20:42:04'),
(215, 5, 2, 5, '2022-03-24', '20:42:04'),
(216, 5, 2, 8, '2022-03-24', '20:42:04'),
(217, 5, 2, 1, '2022-03-24', '20:42:04'),
(218, 5, 2, 5, '2022-03-24', '20:42:04'),
(219, 5, 2, 1, '2022-03-24', '20:42:04'),
(220, 5, 2, 3, '2022-03-24', '20:42:04'),
(221, 5, 2, 8, '2022-03-24', '20:42:04'),
(222, 5, 2, 11, '2022-03-24', '20:42:04'),
(223, 5, 2, 2, '2022-03-24', '20:42:04'),
(224, 5, 2, 2, '2022-03-24', '20:42:04'),
(225, 5, 2, 4, '2022-03-24', '20:42:04'),
(226, 5, 2, 4, '2022-03-24', '20:42:04'),
(227, 5, 2, 1, '2022-03-24', '20:42:04'),
(228, 5, 2, 1, '2022-03-24', '20:42:04'),
(229, 5, 2, 3, '2022-03-24', '20:42:04'),
(230, 5, 2, 8, '2022-03-24', '20:42:04'),
(231, 5, 2, 11, '2022-03-24', '20:42:04'),
(232, 5, 2, 0, '2022-03-24', '20:42:04'),
(233, 5, 2, 4, '2022-03-24', '20:42:04'),
(234, 5, 2, 9, '2022-03-24', '20:42:04'),
(235, 5, 2, 3, '2022-03-24', '20:42:04'),
(236, 5, 2, 2, '2022-03-24', '20:42:04'),
(237, 5, 2, 3, '2022-03-24', '20:42:04'),
(238, 5, 2, 10, '2022-03-24', '20:42:04'),
(239, 5, 2, 4, '2022-03-24', '20:42:04'),
(240, 5, 2, 6, '2022-03-24', '20:42:04'),
(241, 5, 2, 10, '2022-03-24', '20:42:04'),
(242, 5, 2, 7, '2022-03-24', '20:42:04'),
(243, 5, 2, 7, '2022-03-24', '20:42:04'),
(244, 5, 2, 9, '2022-03-24', '20:42:04'),
(245, 5, 2, 5, '2022-03-24', '20:42:04'),
(246, 5, 2, 3, '2022-03-24', '20:42:04'),
(247, 5, 2, 5, '2022-03-24', '20:42:04'),
(248, 5, 2, 1, '2022-03-24', '20:42:04'),
(249, 5, 2, 7, '2022-03-24', '20:42:04'),
(250, 5, 2, 0, '2022-03-24', '20:42:04'),
(251, 5, 2, 4, '2022-03-24', '20:42:04'),
(252, 5, 2, 6, '2022-03-24', '20:42:04'),
(253, 5, 2, 7, '2022-03-24', '20:42:04'),
(254, 5, 2, 1, '2022-03-24', '20:42:04'),
(255, 5, 2, 11, '2022-03-24', '20:42:04'),
(256, 5, 2, 8, '2022-03-24', '20:42:04'),
(257, 5, 2, 5, '2022-03-24', '20:42:04'),
(258, 5, 2, 0, '2022-03-24', '20:42:04'),
(259, 3, 2, 5, '2022-03-24', '20:43:24'),
(260, 3, 2, 4, '2022-03-24', '20:43:24'),
(261, 3, 2, 1, '2022-03-24', '20:43:24'),
(262, 3, 2, 5, '2022-03-24', '20:43:24'),
(263, 3, 2, 5, '2022-03-24', '20:43:24'),
(264, 3, 2, 5, '2022-03-24', '20:43:24'),
(265, 3, 2, 6, '2022-03-24', '20:43:24'),
(266, 3, 2, 2, '2022-03-24', '20:43:24'),
(267, 3, 2, 1, '2022-03-24', '20:43:24'),
(268, 3, 2, 5, '2022-03-24', '20:43:24'),
(269, 3, 2, 3, '2022-03-24', '20:43:24'),
(270, 3, 2, 1, '2022-03-24', '20:43:24'),
(271, 3, 2, 9, '2022-03-24', '20:43:24'),
(272, 3, 2, 4, '2022-03-24', '20:43:24'),
(273, 3, 2, 7, '2022-03-24', '20:43:24'),
(274, 3, 2, 9, '2022-03-24', '20:43:24'),
(275, 3, 2, 0, '2022-03-24', '20:43:24'),
(276, 3, 2, 10, '2022-03-24', '20:43:24'),
(277, 3, 2, 8, '2022-03-24', '20:43:24'),
(278, 3, 2, 9, '2022-03-24', '20:43:24'),
(279, 3, 2, 6, '2022-03-24', '20:43:24'),
(280, 3, 2, 7, '2022-03-24', '20:43:24'),
(281, 3, 2, 1, '2022-03-24', '20:43:24'),
(282, 3, 2, 5, '2022-03-24', '20:43:24'),
(283, 3, 2, 2, '2022-03-24', '20:43:24'),
(284, 3, 2, 6, '2022-03-24', '20:43:24'),
(285, 3, 2, 5, '2022-03-24', '20:43:24'),
(286, 3, 2, 1, '2022-03-24', '20:43:24'),
(287, 3, 2, 4, '2022-03-24', '20:43:24'),
(288, 3, 2, 9, '2022-03-24', '20:43:24'),
(289, 3, 2, 10, '2022-03-24', '20:43:24'),
(290, 3, 2, 6, '2022-03-24', '20:43:24'),
(291, 3, 2, 6, '2022-03-24', '20:43:24'),
(292, 3, 2, 2, '2022-03-24', '20:43:24'),
(293, 3, 2, 10, '2022-03-24', '20:43:24'),
(294, 3, 2, 5, '2022-03-24', '20:43:24'),
(295, 3, 2, 1, '2022-03-24', '20:43:24'),
(296, 3, 2, 8, '2022-03-24', '20:43:24'),
(297, 3, 2, 9, '2022-03-24', '20:43:24'),
(298, 3, 2, 8, '2022-03-24', '20:43:24'),
(299, 3, 2, 5, '2022-03-24', '20:43:24'),
(300, 3, 2, 3, '2022-03-24', '20:43:24'),
(301, 3, 2, 9, '2022-03-24', '20:43:24'),
(302, 3, 2, 5, '2022-03-24', '20:43:24'),
(303, 3, 2, 5, '2022-03-24', '20:43:24'),
(304, 3, 2, 0, '2022-03-24', '20:43:24'),
(305, 3, 2, 2, '2022-03-24', '20:43:24'),
(306, 3, 2, 0, '2022-03-24', '20:43:24'),
(307, 3, 2, 7, '2022-03-24', '20:43:24'),
(308, 3, 2, 6, '2022-03-24', '20:43:24'),
(309, 3, 2, 10, '2022-03-24', '20:43:24'),
(310, 3, 2, 0, '2022-03-24', '20:43:24'),
(311, 3, 2, 7, '2022-03-24', '20:43:24'),
(312, 3, 2, 10, '2022-03-24', '20:43:24'),
(313, 3, 2, 5, '2022-03-24', '20:43:24'),
(314, 3, 2, 3, '2022-03-24', '20:43:24'),
(315, 3, 2, 0, '2022-03-24', '20:43:24'),
(316, 3, 2, 7, '2022-03-24', '20:43:24'),
(317, 3, 2, 8, '2022-03-24', '20:43:24'),
(318, 3, 2, 0, '2022-03-24', '20:43:24'),
(319, 3, 2, 9, '2022-03-24', '20:43:24'),
(320, 3, 2, 3, '2022-03-24', '20:43:24'),
(321, 3, 2, 3, '2022-03-24', '20:43:24'),
(322, 3, 2, 4, '2022-03-24', '20:43:24'),
(323, 3, 2, 5, '2022-03-24', '20:43:24'),
(324, 3, 2, 3, '2022-03-24', '20:43:24'),
(325, 3, 2, 10, '2022-03-24', '20:43:24'),
(326, 3, 2, 2, '2022-03-24', '20:43:24'),
(327, 3, 2, 1, '2022-03-24', '20:43:24'),
(328, 3, 2, 4, '2022-03-24', '20:43:24'),
(329, 3, 2, 1, '2022-03-24', '20:43:24'),
(330, 3, 2, 2, '2022-03-24', '20:43:24'),
(331, 3, 2, 10, '2022-03-24', '20:43:24'),
(332, 3, 2, 5, '2022-03-24', '20:43:24'),
(333, 3, 2, 5, '2022-03-24', '20:43:24'),
(334, 3, 2, 6, '2022-03-24', '20:43:24'),
(335, 3, 2, 4, '2022-03-24', '20:43:24'),
(336, 3, 2, 8, '2022-03-24', '20:43:24'),
(337, 3, 2, 0, '2022-03-24', '20:43:24'),
(338, 3, 2, 8, '2022-03-24', '20:43:24'),
(339, 3, 2, 4, '2022-03-24', '20:43:24'),
(340, 3, 2, 1, '2022-03-24', '20:43:24'),
(341, 3, 2, 9, '2022-03-24', '20:43:24'),
(342, 3, 2, 3, '2022-03-24', '20:43:24'),
(343, 3, 2, 5, '2022-03-24', '20:43:24'),
(344, 3, 2, 9, '2022-03-24', '20:43:24'),
(345, 3, 2, 2, '2022-03-24', '20:43:24'),
(346, 3, 2, 4, '2022-03-24', '20:43:24'),
(347, 3, 2, 8, '2022-03-24', '20:43:24'),
(348, 3, 2, 10, '2022-03-24', '20:43:24'),
(349, 3, 2, 3, '2022-03-24', '20:43:24'),
(350, 3, 2, 10, '2022-03-24', '20:43:24'),
(351, 3, 2, 3, '2022-03-24', '20:43:24'),
(352, 3, 2, 10, '2022-03-24', '20:43:24'),
(353, 3, 2, 6, '2022-03-24', '20:43:24'),
(354, 3, 2, 7, '2022-03-24', '20:43:24'),
(355, 3, 2, 6, '2022-03-24', '20:43:24'),
(356, 3, 2, 10, '2022-03-24', '20:43:24'),
(357, 3, 2, 5, '2022-03-24', '20:43:24'),
(358, 3, 2, 3, '2022-03-24', '20:43:24'),
(359, 1, 2, 2, '2022-03-24', '20:43:51'),
(360, 1, 2, 8, '2022-03-24', '20:43:51'),
(361, 1, 2, 6, '2022-03-24', '20:43:51'),
(362, 1, 2, 6, '2022-03-24', '20:43:51'),
(363, 1, 2, 7, '2022-03-24', '20:43:51'),
(364, 1, 2, 10, '2022-03-24', '20:43:51'),
(365, 1, 2, 6, '2022-03-24', '20:43:51'),
(366, 1, 2, 6, '2022-03-24', '20:43:51'),
(367, 1, 2, 7, '2022-03-24', '20:43:51'),
(368, 1, 2, 10, '2022-03-24', '20:43:51'),
(369, 1, 2, 2, '2022-03-24', '20:43:51'),
(370, 1, 2, 0, '2022-03-24', '20:43:51'),
(371, 1, 2, 3, '2022-03-24', '20:43:51'),
(372, 1, 2, 4, '2022-03-24', '20:43:51'),
(373, 1, 2, 1, '2022-03-24', '20:43:51'),
(374, 1, 2, 4, '2022-03-24', '20:43:51'),
(375, 1, 2, 4, '2022-03-24', '20:43:51'),
(376, 1, 2, 1, '2022-03-24', '20:43:51'),
(377, 1, 2, 8, '2022-03-24', '20:43:51'),
(378, 1, 2, 7, '2022-03-24', '20:43:51'),
(379, 1, 2, 0, '2022-03-24', '20:43:51'),
(380, 1, 2, 8, '2022-03-24', '20:43:51'),
(381, 1, 2, 8, '2022-03-24', '20:43:51'),
(382, 1, 2, 4, '2022-03-24', '20:43:51'),
(383, 1, 2, 4, '2022-03-24', '20:43:51'),
(384, 1, 2, 9, '2022-03-24', '20:43:51'),
(385, 1, 2, 9, '2022-03-24', '20:43:51'),
(386, 1, 2, 1, '2022-03-24', '20:43:51'),
(387, 1, 2, 0, '2022-03-24', '20:43:51'),
(388, 1, 2, 9, '2022-03-24', '20:43:51'),
(389, 1, 2, 1, '2022-03-24', '20:43:51'),
(390, 1, 2, 1, '2022-03-24', '20:43:51'),
(391, 1, 2, 9, '2022-03-24', '20:43:51'),
(392, 1, 2, 8, '2022-03-24', '20:43:51'),
(393, 1, 2, 10, '2022-03-24', '20:43:51'),
(394, 1, 2, 4, '2022-03-24', '20:43:51'),
(395, 1, 2, 3, '2022-03-24', '20:43:51'),
(396, 1, 2, 2, '2022-03-24', '20:43:51'),
(397, 1, 2, 5, '2022-03-24', '20:43:51'),
(398, 1, 2, 1, '2022-03-24', '20:43:51'),
(399, 1, 2, 0, '2022-03-24', '20:43:51'),
(400, 1, 2, 9, '2022-03-24', '20:43:51'),
(401, 1, 2, 6, '2022-03-24', '20:43:51'),
(402, 1, 2, 7, '2022-03-24', '20:43:51'),
(403, 1, 2, 6, '2022-03-24', '20:43:51'),
(404, 1, 2, 10, '2022-03-24', '20:43:51'),
(405, 1, 2, 6, '2022-03-24', '20:43:51'),
(406, 1, 2, 8, '2022-03-24', '20:43:51'),
(407, 1, 2, 9, '2022-03-24', '20:43:51'),
(408, 1, 2, 4, '2022-03-24', '20:43:51'),
(409, 1, 2, 7, '2022-03-24', '20:43:51'),
(410, 1, 2, 1, '2022-03-24', '20:43:51'),
(411, 1, 2, 0, '2022-03-24', '20:43:51'),
(412, 1, 2, 8, '2022-03-24', '20:43:51'),
(413, 1, 2, 0, '2022-03-24', '20:43:51'),
(414, 1, 2, 8, '2022-03-24', '20:43:51'),
(415, 1, 2, 1, '2022-03-24', '20:43:51'),
(416, 1, 2, 5, '2022-03-24', '20:43:51'),
(417, 1, 2, 3, '2022-03-24', '20:43:51'),
(418, 1, 2, 4, '2022-03-24', '20:43:51'),
(419, 1, 2, 9, '2022-03-24', '20:43:51'),
(420, 1, 2, 7, '2022-03-24', '20:43:51'),
(421, 1, 2, 3, '2022-03-24', '20:43:51'),
(422, 1, 2, 4, '2022-03-24', '20:43:51'),
(423, 1, 2, 4, '2022-03-24', '20:43:51'),
(424, 1, 2, 6, '2022-03-24', '20:43:51'),
(425, 1, 2, 7, '2022-03-24', '20:43:51'),
(426, 1, 2, 10, '2022-03-24', '20:43:51'),
(427, 1, 2, 6, '2022-03-24', '20:43:51'),
(428, 1, 2, 5, '2022-03-24', '20:43:51'),
(429, 1, 2, 10, '2022-03-24', '20:43:51'),
(430, 1, 2, 1, '2022-03-24', '20:43:51'),
(431, 1, 2, 4, '2022-03-24', '20:43:51'),
(432, 1, 2, 6, '2022-03-24', '20:43:51'),
(433, 1, 2, 9, '2022-03-24', '20:43:51'),
(434, 1, 2, 4, '2022-03-24', '20:43:51'),
(435, 1, 2, 8, '2022-03-24', '20:43:51'),
(436, 1, 2, 4, '2022-03-24', '20:43:51'),
(437, 1, 2, 7, '2022-03-24', '20:43:51'),
(438, 1, 2, 8, '2022-03-24', '20:43:51'),
(439, 1, 2, 10, '2022-03-24', '20:43:51'),
(440, 1, 2, 4, '2022-03-24', '20:43:51'),
(441, 1, 2, 2, '2022-03-24', '20:43:51'),
(442, 1, 2, 4, '2022-03-24', '20:43:51'),
(443, 1, 2, 3, '2022-03-24', '20:43:51'),
(444, 1, 2, 0, '2022-03-24', '20:43:51'),
(445, 1, 2, 8, '2022-03-24', '20:43:51'),
(446, 1, 2, 9, '2022-03-24', '20:43:51'),
(447, 1, 2, 0, '2022-03-24', '20:43:51'),
(448, 1, 2, 1, '2022-03-24', '20:43:51'),
(449, 1, 2, 3, '2022-03-24', '20:43:51'),
(450, 1, 2, 10, '2022-03-24', '20:43:51'),
(451, 1, 2, 8, '2022-03-24', '20:43:51'),
(452, 1, 2, 0, '2022-03-24', '20:43:51'),
(453, 1, 2, 8, '2022-03-24', '20:43:51'),
(454, 1, 2, 2, '2022-03-24', '20:43:51'),
(455, 1, 2, 1, '2022-03-24', '20:43:51'),
(456, 1, 2, 4, '2022-03-24', '20:43:51'),
(457, 1, 2, 1, '2022-03-24', '20:43:51'),
(458, 1, 2, 9, '2022-03-24', '20:43:51'),
(459, 2, 2, 5, '2022-03-24', '20:44:39'),
(460, 2, 2, 9, '2022-03-24', '20:44:39'),
(461, 2, 2, 10, '2022-03-24', '20:44:39'),
(462, 2, 2, 2, '2022-03-24', '20:44:39'),
(463, 2, 2, 9, '2022-03-24', '20:44:39'),
(464, 2, 2, 1, '2022-03-24', '20:44:39'),
(465, 2, 2, 10, '2022-03-24', '20:44:39'),
(466, 2, 2, 8, '2022-03-24', '20:44:39'),
(467, 2, 2, 8, '2022-03-24', '20:44:39'),
(468, 2, 2, 6, '2022-03-24', '20:44:39'),
(469, 2, 2, 9, '2022-03-24', '20:44:39'),
(470, 2, 2, 9, '2022-03-24', '20:44:39'),
(471, 2, 2, 9, '2022-03-24', '20:44:39'),
(472, 2, 2, 9, '2022-03-24', '20:44:39'),
(473, 2, 2, 0, '2022-03-24', '20:44:39'),
(474, 2, 2, 6, '2022-03-24', '20:44:39'),
(475, 2, 2, 9, '2022-03-24', '20:44:39'),
(476, 2, 2, 6, '2022-03-24', '20:44:39'),
(477, 2, 2, 3, '2022-03-24', '20:44:39'),
(478, 2, 2, 1, '2022-03-24', '20:44:39'),
(479, 2, 2, 0, '2022-03-24', '20:44:39'),
(480, 2, 2, 0, '2022-03-24', '20:44:39'),
(481, 2, 2, 0, '2022-03-24', '20:44:39'),
(482, 2, 2, 5, '2022-03-24', '20:44:39'),
(483, 2, 2, 8, '2022-03-24', '20:44:39'),
(484, 2, 2, 2, '2022-03-24', '20:44:39'),
(485, 2, 2, 3, '2022-03-24', '20:44:39'),
(486, 2, 2, 0, '2022-03-24', '20:44:39'),
(487, 2, 2, 8, '2022-03-24', '20:44:39'),
(488, 2, 2, 10, '2022-03-24', '20:44:39'),
(489, 2, 2, 9, '2022-03-24', '20:44:39'),
(490, 2, 2, 2, '2022-03-24', '20:44:39'),
(491, 2, 2, 6, '2022-03-24', '20:44:39'),
(492, 2, 2, 3, '2022-03-24', '20:44:39'),
(493, 2, 2, 0, '2022-03-24', '20:44:39'),
(494, 2, 2, 5, '2022-03-24', '20:44:39'),
(495, 2, 2, 6, '2022-03-24', '20:44:39'),
(496, 2, 2, 3, '2022-03-24', '20:44:39'),
(497, 2, 2, 5, '2022-03-24', '20:44:39'),
(498, 2, 2, 2, '2022-03-24', '20:44:39'),
(499, 2, 2, 9, '2022-03-24', '20:44:39'),
(500, 2, 2, 9, '2022-03-24', '20:44:39'),
(501, 2, 2, 2, '2022-03-24', '20:44:39'),
(502, 2, 2, 6, '2022-03-24', '20:44:39'),
(503, 2, 2, 9, '2022-03-24', '20:44:39'),
(504, 2, 2, 5, '2022-03-24', '20:44:39'),
(505, 2, 2, 6, '2022-03-24', '20:44:39'),
(506, 2, 2, 5, '2022-03-24', '20:44:39'),
(507, 2, 2, 4, '2022-03-24', '20:44:39'),
(508, 2, 2, 3, '2022-03-24', '20:44:39'),
(509, 2, 2, 2, '2022-03-24', '20:44:39'),
(510, 2, 2, 6, '2022-03-24', '20:44:39'),
(511, 2, 2, 6, '2022-03-24', '20:44:39'),
(512, 2, 2, 1, '2022-03-24', '20:44:39'),
(513, 2, 2, 10, '2022-03-24', '20:44:39'),
(514, 2, 2, 1, '2022-03-24', '20:44:39'),
(515, 2, 2, 4, '2022-03-24', '20:44:39'),
(516, 2, 2, 0, '2022-03-24', '20:44:39'),
(517, 2, 2, 10, '2022-03-24', '20:44:39'),
(518, 2, 2, 8, '2022-03-24', '20:44:39'),
(519, 2, 2, 1, '2022-03-24', '20:44:39'),
(520, 2, 2, 9, '2022-03-24', '20:44:39'),
(521, 2, 2, 5, '2022-03-24', '20:44:39'),
(522, 2, 2, 9, '2022-03-24', '20:44:39'),
(523, 2, 2, 4, '2022-03-24', '20:44:39'),
(524, 2, 2, 8, '2022-03-24', '20:44:39'),
(525, 2, 2, 1, '2022-03-24', '20:44:39'),
(526, 2, 2, 8, '2022-03-24', '20:44:39'),
(527, 2, 2, 8, '2022-03-24', '20:44:39'),
(528, 2, 2, 6, '2022-03-24', '20:44:39'),
(529, 2, 2, 0, '2022-03-24', '20:44:39'),
(530, 2, 2, 3, '2022-03-24', '20:44:39'),
(531, 2, 2, 5, '2022-03-24', '20:44:39'),
(532, 2, 2, 1, '2022-03-24', '20:44:39'),
(533, 2, 2, 3, '2022-03-24', '20:44:39'),
(534, 2, 2, 4, '2022-03-24', '20:44:39'),
(535, 2, 2, 0, '2022-03-24', '20:44:39'),
(536, 2, 2, 2, '2022-03-24', '20:44:39'),
(537, 2, 2, 4, '2022-03-24', '20:44:39'),
(538, 2, 2, 1, '2022-03-24', '20:44:39'),
(539, 2, 2, 10, '2022-03-24', '20:44:39'),
(540, 2, 2, 7, '2022-03-24', '20:44:39'),
(541, 2, 2, 10, '2022-03-24', '20:44:39'),
(542, 2, 2, 1, '2022-03-24', '20:44:39'),
(543, 2, 2, 9, '2022-03-24', '20:44:39'),
(544, 2, 2, 5, '2022-03-24', '20:44:39'),
(545, 2, 2, 1, '2022-03-24', '20:44:39'),
(546, 2, 2, 9, '2022-03-24', '20:44:39'),
(547, 2, 2, 0, '2022-03-24', '20:44:39'),
(548, 2, 2, 8, '2022-03-24', '20:44:39'),
(549, 2, 2, 5, '2022-03-24', '20:44:39'),
(550, 2, 2, 5, '2022-03-24', '20:44:39'),
(551, 2, 2, 2, '2022-03-24', '20:44:39'),
(552, 2, 2, 6, '2022-03-24', '20:44:39'),
(553, 2, 2, 3, '2022-03-24', '20:44:39'),
(554, 2, 2, 10, '2022-03-24', '20:44:39'),
(555, 2, 2, 5, '2022-03-24', '20:44:39'),
(556, 2, 2, 8, '2022-03-24', '20:44:39'),
(557, 2, 2, 6, '2022-03-24', '20:44:39'),
(558, 2, 2, 3, '2022-03-24', '20:44:39'),
(559, 4, 2, 7, '2022-03-24', '20:45:49'),
(560, 4, 2, 3, '2022-03-24', '20:45:49'),
(561, 4, 2, 2, '2022-03-24', '20:45:49'),
(562, 4, 2, 9, '2022-03-24', '20:45:49'),
(563, 4, 2, 3, '2022-03-24', '20:45:49'),
(564, 4, 2, 2, '2022-03-24', '20:45:49'),
(565, 4, 2, 5, '2022-03-24', '20:45:49'),
(566, 4, 2, 1, '2022-03-24', '20:45:49'),
(567, 4, 2, 8, '2022-03-24', '20:45:49'),
(568, 4, 2, 3, '2022-03-24', '20:45:49'),
(569, 4, 2, 9, '2022-03-24', '20:45:49'),
(570, 4, 2, 9, '2022-03-24', '20:45:49'),
(571, 4, 2, 1, '2022-03-24', '20:45:49'),
(572, 4, 2, 5, '2022-03-24', '20:45:49'),
(573, 4, 2, 2, '2022-03-24', '20:45:49'),
(574, 4, 2, 5, '2022-03-24', '20:45:49'),
(575, 4, 2, 3, '2022-03-24', '20:45:49'),
(576, 4, 2, 2, '2022-03-24', '20:45:49'),
(577, 4, 2, 3, '2022-03-24', '20:45:49'),
(578, 4, 2, 2, '2022-03-24', '20:45:49'),
(579, 4, 2, 8, '2022-03-24', '20:45:49'),
(580, 4, 2, 2, '2022-03-24', '20:45:49'),
(581, 4, 2, 3, '2022-03-24', '20:45:49'),
(582, 4, 2, 5, '2022-03-24', '20:45:49'),
(583, 4, 2, 0, '2022-03-24', '20:45:49'),
(584, 4, 2, 6, '2022-03-24', '20:45:49'),
(585, 4, 2, 1, '2022-03-24', '20:45:49'),
(586, 4, 2, 1, '2022-03-24', '20:45:49'),
(587, 4, 2, 1, '2022-03-24', '20:45:49'),
(588, 4, 2, 0, '2022-03-24', '20:45:49'),
(589, 4, 2, 0, '2022-03-24', '20:45:49'),
(590, 4, 2, 8, '2022-03-24', '20:45:49'),
(591, 4, 2, 8, '2022-03-24', '20:45:49'),
(592, 4, 2, 4, '2022-03-24', '20:45:49'),
(593, 4, 2, 3, '2022-03-24', '20:45:49'),
(594, 4, 2, 3, '2022-03-24', '20:45:49'),
(595, 4, 2, 2, '2022-03-24', '20:45:49'),
(596, 4, 2, 6, '2022-03-24', '20:45:49'),
(597, 4, 2, 9, '2022-03-24', '20:45:49'),
(598, 4, 2, 3, '2022-03-24', '20:45:49'),
(599, 4, 2, 4, '2022-03-24', '20:45:49'),
(600, 4, 2, 3, '2022-03-24', '20:45:49'),
(601, 4, 2, 1, '2022-03-24', '20:45:49'),
(602, 4, 2, 4, '2022-03-24', '20:45:49'),
(603, 4, 2, 5, '2022-03-24', '20:45:49'),
(604, 4, 2, 0, '2022-03-24', '20:45:49'),
(605, 4, 2, 4, '2022-03-24', '20:45:49'),
(606, 4, 2, 2, '2022-03-24', '20:45:49'),
(607, 4, 2, 5, '2022-03-24', '20:45:49'),
(608, 4, 2, 9, '2022-03-24', '20:45:49'),
(609, 4, 2, 7, '2022-03-24', '20:45:49'),
(610, 4, 2, 7, '2022-03-24', '20:45:49'),
(611, 4, 2, 1, '2022-03-24', '20:45:49'),
(612, 4, 2, 7, '2022-03-24', '20:45:49'),
(613, 4, 2, 8, '2022-03-24', '20:45:49'),
(614, 4, 2, 1, '2022-03-24', '20:45:49'),
(615, 4, 2, 0, '2022-03-24', '20:45:49'),
(616, 4, 2, 4, '2022-03-24', '20:45:49'),
(617, 4, 2, 4, '2022-03-24', '20:45:49'),
(618, 4, 2, 2, '2022-03-24', '20:45:49'),
(619, 4, 2, 2, '2022-03-24', '20:45:49'),
(620, 4, 2, 8, '2022-03-24', '20:45:49'),
(621, 4, 2, 3, '2022-03-24', '20:45:49'),
(622, 4, 2, 4, '2022-03-24', '20:45:49'),
(623, 4, 2, 7, '2022-03-24', '20:45:49'),
(624, 4, 2, 0, '2022-03-24', '20:45:49'),
(625, 4, 2, 3, '2022-03-24', '20:45:49'),
(626, 4, 2, 1, '2022-03-24', '20:45:49'),
(627, 4, 2, 4, '2022-03-24', '20:45:49'),
(628, 4, 2, 7, '2022-03-24', '20:45:49'),
(629, 4, 2, 1, '2022-03-24', '20:45:49'),
(630, 4, 2, 8, '2022-03-24', '20:45:49'),
(631, 4, 2, 2, '2022-03-24', '20:45:49'),
(632, 4, 2, 3, '2022-03-24', '20:45:49'),
(633, 4, 2, 9, '2022-03-24', '20:45:49'),
(634, 4, 2, 5, '2022-03-24', '20:45:49'),
(635, 4, 2, 0, '2022-03-24', '20:45:49'),
(636, 4, 2, 6, '2022-03-24', '20:45:49'),
(637, 4, 2, 1, '2022-03-24', '20:45:49'),
(638, 4, 2, 0, '2022-03-24', '20:45:49'),
(639, 4, 2, 8, '2022-03-24', '20:45:49'),
(640, 4, 2, 6, '2022-03-24', '20:45:49'),
(641, 4, 2, 2, '2022-03-24', '20:45:49'),
(642, 4, 2, 8, '2022-03-24', '20:45:49'),
(643, 4, 2, 7, '2022-03-24', '20:45:49'),
(644, 4, 2, 7, '2022-03-24', '20:45:49'),
(645, 4, 2, 9, '2022-03-24', '20:45:49'),
(646, 4, 2, 2, '2022-03-24', '20:45:49'),
(647, 4, 2, 6, '2022-03-24', '20:45:49'),
(648, 4, 2, 0, '2022-03-24', '20:45:49'),
(649, 4, 2, 2, '2022-03-24', '20:45:49'),
(650, 4, 2, 9, '2022-03-24', '20:45:49'),
(651, 4, 2, 8, '2022-03-24', '20:45:49'),
(652, 4, 2, 1, '2022-03-24', '20:45:49'),
(653, 4, 2, 1, '2022-03-24', '20:45:49'),
(654, 4, 2, 0, '2022-03-24', '20:45:49'),
(655, 4, 2, 3, '2022-03-24', '20:45:49'),
(656, 4, 2, 1, '2022-03-24', '20:45:49'),
(657, 4, 2, 5, '2022-03-24', '20:45:49'),
(658, 4, 2, 3, '2022-03-24', '20:45:49');

-- --------------------------------------------------------

--
-- Структура таблицы `test_statuses`
--

CREATE TABLE `test_statuses` (
  `IDStatus` int NOT NULL,
  `Name` varchar(30) COLLATE utf8mb4_general_ci NOT NULL,
  `Description` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;

--
-- Дамп данных таблицы `test_statuses`
--

INSERT INTO `test_statuses` (`IDStatus`, `Name`, `Description`) VALUES
(1, 'Черновик', 'Отображается администратору, но не показывается пользователю'),
(2, 'Опубликован', 'Отображается всем'),
(3, 'Удален', 'Скрыт для всех');

-- --------------------------------------------------------

--
-- Структура таблицы `users`
--

CREATE TABLE `users` (
  `IDUser` int NOT NULL,
  `Name` varchar(100) COLLATE utf8mb4_general_ci NOT NULL,
  `Email` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `Password` varchar(30) COLLATE utf8mb4_general_ci NOT NULL,
  `IDRole` int NOT NULL,
  `SecretKey` varchar(150) COLLATE utf8mb4_general_ci NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;

--
-- Дамп данных таблицы `users`
--

INSERT INTO `users` (`IDUser`, `Name`, `Email`, `Password`, `IDRole`, `SecretKey`) VALUES
(1, 'Admin', 'admin@mail.ru', '123456', 1, ''),
(2, 'Гость', 'guest@mail.ru', '123456', 2, ''),
(13, 'Anton', 'guzikov.a@mail.ru', '111111', 2, '');

-- --------------------------------------------------------

--
-- Структура таблицы `user_roles`
--

CREATE TABLE `user_roles` (
  `IDRole` int NOT NULL,
  `Name` varchar(30) COLLATE utf8mb4_general_ci NOT NULL,
  `Description` varchar(200) COLLATE utf8mb4_general_ci DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;

--
-- Дамп данных таблицы `user_roles`
--

INSERT INTO `user_roles` (`IDRole`, `Name`, `Description`) VALUES
(1, 'Администратор', 'Имеет полный доступ ко всех функциям'),
(2, 'Пользователь', 'Стандартная роль'),
(3, 'Заблокирован', 'Пользователь не может войти в свой аккаунт'),
(4, 'Неподтверждённый ', 'Пользователь создал аккаунт, но не подтвердил почту');

--
-- Индексы сохранённых таблиц
--

--
-- Индексы таблицы `answers`
--
ALTER TABLE `answers`
  ADD PRIMARY KEY (`IDAnswer`),
  ADD KEY `IDQuestion` (`IDQuestion`);

--
-- Индексы таблицы `chapters`
--
ALTER TABLE `chapters`
  ADD PRIMARY KEY (`IDChapter`);

--
-- Индексы таблицы `common_statuses`
--
ALTER TABLE `common_statuses`
  ADD PRIMARY KEY (`IDStatus`);

--
-- Индексы таблицы `labs`
--
ALTER TABLE `labs`
  ADD PRIMARY KEY (`IDLab`),
  ADD KEY `IDStatus` (`IDStatus`);

--
-- Индексы таблицы `lectures`
--
ALTER TABLE `lectures`
  ADD PRIMARY KEY (`IDLecture`),
  ADD KEY `IDChapter` (`IDChapter`),
  ADD KEY `IDStatus` (`IDStatus`);

--
-- Индексы таблицы `lecture_recommended`
--
ALTER TABLE `lecture_recommended`
  ADD PRIMARY KEY (`IDString`),
  ADD KEY `IDResult` (`IDResult`),
  ADD KEY `IDLecture` (`IDLecture`);

--
-- Индексы таблицы `questions`
--
ALTER TABLE `questions`
  ADD PRIMARY KEY (`IDQuestion`),
  ADD KEY `IDType` (`IDType`),
  ADD KEY `IDTest` (`IDTest`);

--
-- Индексы таблицы `questions_lectures`
--
ALTER TABLE `questions_lectures`
  ADD PRIMARY KEY (`IDString`),
  ADD KEY `IDQuestion` (`IDQuestion`),
  ADD KEY `IDLecture` (`IDLecture`);

--
-- Индексы таблицы `question_type`
--
ALTER TABLE `question_type`
  ADD PRIMARY KEY (`IDType`);

--
-- Индексы таблицы `tests`
--
ALTER TABLE `tests`
  ADD PRIMARY KEY (`IDTest`),
  ADD KEY `IDLecture` (`IDComplexity`),
  ADD KEY `IDStatus` (`IDStatus`);

--
-- Индексы таблицы `test_complexity`
--
ALTER TABLE `test_complexity`
  ADD PRIMARY KEY (`IDСomplexity`);

--
-- Индексы таблицы `test_results`
--
ALTER TABLE `test_results`
  ADD PRIMARY KEY (`IDResult`),
  ADD KEY `IDUser` (`IDUser`),
  ADD KEY `IDTest` (`IDTest`);

--
-- Индексы таблицы `test_statuses`
--
ALTER TABLE `test_statuses`
  ADD PRIMARY KEY (`IDStatus`);

--
-- Индексы таблицы `users`
--
ALTER TABLE `users`
  ADD PRIMARY KEY (`IDUser`),
  ADD KEY `IDRole` (`IDRole`);

--
-- Индексы таблицы `user_roles`
--
ALTER TABLE `user_roles`
  ADD PRIMARY KEY (`IDRole`);

--
-- AUTO_INCREMENT для сохранённых таблиц
--

--
-- AUTO_INCREMENT для таблицы `answers`
--
ALTER TABLE `answers`
  MODIFY `IDAnswer` int NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=860;

--
-- AUTO_INCREMENT для таблицы `chapters`
--
ALTER TABLE `chapters`
  MODIFY `IDChapter` int NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=22;

--
-- AUTO_INCREMENT для таблицы `common_statuses`
--
ALTER TABLE `common_statuses`
  MODIFY `IDStatus` int NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=4;

--
-- AUTO_INCREMENT для таблицы `labs`
--
ALTER TABLE `labs`
  MODIFY `IDLab` int NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=18;

--
-- AUTO_INCREMENT для таблицы `lectures`
--
ALTER TABLE `lectures`
  MODIFY `IDLecture` int NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=73;

--
-- AUTO_INCREMENT для таблицы `lecture_recommended`
--
ALTER TABLE `lecture_recommended`
  MODIFY `IDString` int NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=78;

--
-- AUTO_INCREMENT для таблицы `questions`
--
ALTER TABLE `questions`
  MODIFY `IDQuestion` int NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=266;

--
-- AUTO_INCREMENT для таблицы `questions_lectures`
--
ALTER TABLE `questions_lectures`
  MODIFY `IDString` int NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=183;

--
-- AUTO_INCREMENT для таблицы `question_type`
--
ALTER TABLE `question_type`
  MODIFY `IDType` int NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=5;

--
-- AUTO_INCREMENT для таблицы `tests`
--
ALTER TABLE `tests`
  MODIFY `IDTest` int NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=10;

--
-- AUTO_INCREMENT для таблицы `test_complexity`
--
ALTER TABLE `test_complexity`
  MODIFY `IDСomplexity` int NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=4;

--
-- AUTO_INCREMENT для таблицы `test_results`
--
ALTER TABLE `test_results`
  MODIFY `IDResult` int NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=659;

--
-- AUTO_INCREMENT для таблицы `test_statuses`
--
ALTER TABLE `test_statuses`
  MODIFY `IDStatus` int NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=4;

--
-- AUTO_INCREMENT для таблицы `users`
--
ALTER TABLE `users`
  MODIFY `IDUser` int NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=15;

--
-- AUTO_INCREMENT для таблицы `user_roles`
--
ALTER TABLE `user_roles`
  MODIFY `IDRole` int NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=5;

--
-- Ограничения внешнего ключа сохраненных таблиц
--

--
-- Ограничения внешнего ключа таблицы `answers`
--
ALTER TABLE `answers`
  ADD CONSTRAINT `answers_ibfk_1` FOREIGN KEY (`IDQuestion`) REFERENCES `questions` (`IDQuestion`) ON DELETE CASCADE;

--
-- Ограничения внешнего ключа таблицы `labs`
--
ALTER TABLE `labs`
  ADD CONSTRAINT `labs_ibfk_1` FOREIGN KEY (`IDStatus`) REFERENCES `common_statuses` (`IDStatus`);

--
-- Ограничения внешнего ключа таблицы `lectures`
--
ALTER TABLE `lectures`
  ADD CONSTRAINT `lectures_ibfk_1` FOREIGN KEY (`IDChapter`) REFERENCES `chapters` (`IDChapter`),
  ADD CONSTRAINT `lectures_ibfk_2` FOREIGN KEY (`IDStatus`) REFERENCES `common_statuses` (`IDStatus`);

--
-- Ограничения внешнего ключа таблицы `lecture_recommended`
--
ALTER TABLE `lecture_recommended`
  ADD CONSTRAINT `lecture_recommended_ibfk_1` FOREIGN KEY (`IDResult`) REFERENCES `test_results` (`IDResult`),
  ADD CONSTRAINT `lecture_recommended_ibfk_2` FOREIGN KEY (`IDLecture`) REFERENCES `lectures` (`IDLecture`);

--
-- Ограничения внешнего ключа таблицы `questions`
--
ALTER TABLE `questions`
  ADD CONSTRAINT `questions_ibfk_1` FOREIGN KEY (`IDType`) REFERENCES `question_type` (`IDType`),
  ADD CONSTRAINT `questions_ibfk_2` FOREIGN KEY (`IDTest`) REFERENCES `tests` (`IDTest`);

--
-- Ограничения внешнего ключа таблицы `questions_lectures`
--
ALTER TABLE `questions_lectures`
  ADD CONSTRAINT `questions_lectures_ibfk_1` FOREIGN KEY (`IDLecture`) REFERENCES `lectures` (`IDLecture`),
  ADD CONSTRAINT `questions_lectures_ibfk_2` FOREIGN KEY (`IDQuestion`) REFERENCES `questions` (`IDQuestion`) ON DELETE CASCADE;

--
-- Ограничения внешнего ключа таблицы `tests`
--
ALTER TABLE `tests`
  ADD CONSTRAINT `tests_ibfk_1` FOREIGN KEY (`IDStatus`) REFERENCES `test_statuses` (`IDStatus`),
  ADD CONSTRAINT `tests_ibfk_2` FOREIGN KEY (`IDComplexity`) REFERENCES `test_complexity` (`IDСomplexity`);

--
-- Ограничения внешнего ключа таблицы `test_results`
--
ALTER TABLE `test_results`
  ADD CONSTRAINT `test_results_ibfk_1` FOREIGN KEY (`IDUser`) REFERENCES `users` (`IDUser`),
  ADD CONSTRAINT `test_results_ibfk_2` FOREIGN KEY (`IDTest`) REFERENCES `tests` (`IDTest`);

--
-- Ограничения внешнего ключа таблицы `users`
--
ALTER TABLE `users`
  ADD CONSTRAINT `users_ibfk_1` FOREIGN KEY (`IDRole`) REFERENCES `user_roles` (`IDRole`);
COMMIT;

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
